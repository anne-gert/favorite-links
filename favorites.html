<!DOCTYPE html>
<html>

<!--
For description of this file, see README.md
For syntax description of Links, see syntax.html
-->

<head>

<!-- This page may contain UTF-8 encoded text, especially in the Links definition. -->
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>Favorites</title>

<script>
var Links = null;

</script>

<style>
/* CSS styles {{{ */

:root, body, input, button {
	font-family:  'Segoe UI', 'Lucida Grande', Helvetica, sans-serif;
	font-size: 12pt;
}
/*
https://www.w3schools.com/css/css_rwd_mediaqueries.asp advices the following sizes:
- max-width=600px: Extra small devices (phones)
- min-width=600px: Small devices (portrait tablets and large phones)
- min-width=768px: Medium devices (landscape tablets)
- min-width=992px: Large devices (laptops/desktops)
- min-width=1200px: Extra large devices (large laptops and desktops)

https://www.w3schools.com/cssref/css_units.php makes the following recommendations:
- Use relative lengths (em, %, rem, vw, vh) for screen display.
- Use absolute lengths (cm, px, pt) for print display.
- Pixels (px) are only literal pixels for low-dpi devices. For high-dpi
  devices, 1px is multiple physical pixels.
  The ratio of physical to logical pixels can be retrieved in JavaScript with
  window.devicePixelRatio;
- Here it defines: 1in = 2.54cm = 25.4mm = 72pt = 6pc = 96px

https://stackoverflow.com/questions/8785643/what-exactly-is-device-pixel-ratio describes the direct use of device-pixel-ratio in CSS:
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	only screen and (min--moz-device-pixel-ratio: 1.5),
	only screen and (-o-device-pixel-ratio: 3/2),
	only screen and (min-device-pixel-ratio: 1.5) {
	... high-resolution screens ...
}

Also, disable automatic text-sizing, because that determines the font-size
for each block independently.
*/
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	only screen and (min--moz-device-pixel-ratio: 1.5),
	only screen and (-o-device-pixel-ratio: 3/2),
	only screen and (min-device-pixel-ratio: 1.5) {
	/* high-resolution screens */
	:root, body, input, button {
		/* Make text bigger, because otherwise it gets too small on
		   phones. (I'm not sure why, because 12pt should be the same
		   absolute size on every screen. */
		font-size: 18pt;
	}
	html {
		text-size-adjust: none;
		-moz-text-size-adjust: none;
		-webkit-text-size-adjust: none;
	}
}
:root, body {
	color: #50a0ee; background: #2E323B;
}
::selection {
	color: #000000; background: #ddddff;
}
.section {
	display: block;
}
.block {
	display: inline-block;
	vertical-align: top;
	border: .15em solid #eeeeee;
	border-radius: .5em;
	padding: 1em;
	margin: .5em;
	color: #000000; background: #C9CDD0;
}
.block .expand-icon, .block .collapse-icon {
	float: right;
	position: relative;
	top: -0.9em; right: -0.6em;
	cursor: pointer;
}
.block .collapse-icon {
	color: #888888;
}
.block>.items {  /* first level of children in a block */
	margin-left: 0.5em;
}
.items {
	margin-left: 2em;
}
.item {
	display: block;
	padding: 0.1em;
}
.group .item {
	display: inline;
	margin-left: 0.4em;
}
.group .item:first-child {
	margin-left: unset;
}
.item .icon {
	width: 1.0em; height: 1.0em;
	margin-right: 0.2em;
	vertical-align: -10%;
}
.item.link .icon {
	vertical-align: -20%;
}
.item .separator {
	margin: 0em -1em 0em -1em;
}

.text-icon {
	display: inline-block;
	padding: 0em;
	text-decoration: none;
}
.text-icon div {
	position: absolute;
	margin: 0em; padding: 0em;
	transform-origin: 0 0;
}

.search-form .box {
	font-size: 110%;
}
.search-form .button {
	margin: 0.3em;
}
.search-form .button .icon {
	width: 1.5em; height: 1.5em;
	vertical-align: -25%;
}
.search-form .button .label {
	margin: 0em 0.3em;
}
.blink {
	animation: blinker 0.5s 4;
	color: rgb(0, 0, 0, 0);  /* transparent (also placeholder) */
}
.blink::placeholder {
	opacity: 1;  /* in case browser has this lower by default */
}
@keyframes blinker {
	30% {
		border: .15em solid red;
		background: #FFCCCC;
		color: rgb(0, 0, 0, 1);  /* fully visible (also placeholder) */
	}
}

/* }}} */
</style>

<script>
// Parsing Links {{{

var IconDefs = null;  //specified icondef declarations
var PageTitle = null;  //specified title
var SearchButtonDefs = null;  //specified search buttons


// Parse the string in links.
// Returns array of Link objects that have no parents (i.e. roots).
// Also sets the IconDefs and PageTitle global variables.
function parseLinks(links) {
	// Parse the input lines
	var allLinks = [];  //specified Link objects
	IconDefs = {};
	SearchButtonDefs = [];
	var rootLinks = [];  //Link objects that are the roots
	var openParents = [];  //currently open parents: 0 is root, 1 its child, etc
	var openParentIndentSpaces = [];  //indentation level (number of spaces) for each open parent
	var lines = Links.split(/\r?\n\r?/);  //lines with Link specifications
	for (var i = 0; i < lines.length; ++i) {
		var line = lines[i];
		//console.log('Line=\'' + line + '\'');

		// Remove vim folding markers at the end of lines
		line = line.replace(/\s*(?:{{{|}}})\s*$/, '');

		// Skip empty lines
		if (line.match(/^\s*(?:\/\/|#|;|$)/))
			continue;

		// Check if it is a title definition
		var m = line.match(/^\s*!title\s+(.+?)\s*$/i);
		if (m) {
			// This is an title
			PageTitle = m[1];  //save string
			continue;
		}

		// Check if it is an icon definition
		var m = line.match(/^\s*!icondef\s+(\S+)(?:\s+|\s*=\s*)(\S+)\s*$/i);
		if (m) {
			// This is an icondef
			IconDefs[m[1]] = m[2];  //save mapping
			continue;
		}

		// Check if it is a search button definition
		var m = line.match(/^\s*!search\s+(.+?)\s*$/i);
		if (m) {
			// This is a search button definition
			var def = m[1].split(/\s*\|\s*/);  //split fields on '|', allowing whitespace
			SearchButtonDefs.push(def);  //save button def
			continue;
		}

		// Take out indentation
		var indent = 0;
		var m = line.match(/^(\s+)(.*)$/);
		if (m) {
			indent = m[1].replaceAll('\t', '        ').length;
			line = m[2];  //the rest
		}
		// Take out continucation: & ...
		var cont = false;
		var m = line.match(/^&\s*(.*)$/);
		if (m) {
			cont = true;
			line = m[1];  //the rest
		}
		// Take out Icon: /icon=non-whitespace/
		var icon = null;
		var m = line.match(/^(.*)(?:\s|^)icon=(\S*)(.*)$/i);
		if (m) {
			icon = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out Target: /target=non-whitespace/
		var target = null;
		var m = line.match(/^(.*)(?:\s|^)target=(\S*)(.*)$/i);
		if (m) {
			target = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out URL: /url=non-whitespace/ or last /schema:non-whitespace/
		var url = null;
		var m = line.match(/^(.*)(?:\s|^)url=(\S*)(.*)$/i);
		if (!m)
			m = line.match(/^(.*)(?:\s|^)([-+a-zA-Z]{2,}:\S+)(.*)$/);
		if (m) {
			url = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out Name: what remains without leading&trailing whitespae
		var name = line.trim();

		// Handle special items
		if (name.match(/^---+$/)) {  //name with 3 or more '-'
			// This is a separator
			name = '---';  //standardize to 3 '-'
			var minLevel = 2;  //item level
			if (openParentIndentSpaces.length <= minLevel) {
				continue;  //no open parent at this level yet, skip this item
			} else {
				if (indent < openParentIndentSpaces[minLevel]) {
					// Separator has lower indent than level 2, pretend it's
					// at the same level as the line before
					indent = openParentIndentSpaces[openParentIndentSpaces.length - 1];
				}
			}
		}

		// Create the Link object
		var link = {
			'name' : name,
			'url' : url,
			'icon' : icon,
			'target' : target,
			'cont' : [],
			'subs' : [],
			'toString' : function() { return '{ Name=\'' + this.name + '\', URL=' + this.url + ', Icon=' + this.icon + ', #SubItems=' + this.subs.length + ' }' },
		};
		//console.log('Indentation=' + indent + ', Link=' + link);

		if (cont) {
			// This link is a continuation of the previous link
			// Ignore the indentation and add it to the last parent
			var level = openParents.length - 1;
			openParents[level].cont.push(link);
			// Do not add this link as a possible parent itself
		} else {
			// Find parent level with indentation strictly less
			for (var level = openParentIndentSpaces.length - 1; level >= 0 && openParentIndentSpaces[level] >= indent; --level) {}
			// Remove all open parents after that
			openParentIndentSpaces.length = level + 1;
			openParents.length = level + 1;
			// Add this link to the parent's children
			if (level >= 0) {
				// It has a parent
				openParents[level].subs.push(link);
			} else {
				// It has no parent
				rootLinks.push(link);
			}
			// Add this link as open parent
			openParentIndentSpaces.push(indent);
			openParents.push(link);
		}

		// Add this Link
		allLinks.push(link);
	}

	// Log all links
	//for (var i = 0; i < allLinks.length; ++i) console.log('Link=' + allLinks[i]);
	// Log all roots
	//for (var i = 0; i < rootLinks.length; ++i) console.log('RootLink=' + rootLinks[i]);

	return rootLinks;
}

// }}}

// Rendering Links {{{

// Output Link {{{

// Render Link object, including its children to the container at specified level.
// Level 1 is called Section and is rendered with a heading.
// Level 2 is called Block and is rendered as a rectangular block.
// Level 3 is called Item and is rendered as a line in a Block.
// Level 4 and higher are called sub-Items and are rendered as indented Items.
function outputItem(link, level, container, parentPath) {
	// Copy input data
	var name = link.name;
	var url = link.url;
	var icon = link.icon;
	var target = link.target;
	var tooltip = null;
	var contItems = link.cont;
	if (contItems != null && contItems.length == 0) contItems = null;
	var subItems = link.subs;
	if (subItems != null && subItems.length == 0) subItems = null;
	if (name == '') name = null;
	if (url == '') url = null;
	if (icon == '') icon = null;
	if (target == '') target = null;
	var myPath = parentPath + '->' + name;
	// Fill in defaults for missing elements
	if (name == null) {
		if (url != null) {
			name = url;  //name defaults to url
		} else {
			name = 'LINK';  //default name
		}
	}
	// Change URL if target=manual
	if (target == 'manual') {
		var msg = 'Due to security reasons, this URL cannot be opened automatically.\nCopied URL \'' + url + '\' to clipboard.\n\nManually paste this to the address bar.';
		msg = msg.replaceAll('\'', '\\\'').replaceAll('\n', '\\n');
		tooltip = url;  //preserve original URL
		url = 'javascript:navigator.clipboard.writeText(\'' + url + '\');alert(\'' + encodeURI(msg) + '\');void(0)';
		target = null;
	}
	// Render the item
	// State variables for this item; will be used in closures
	var addItemContainer;  //function to add a container to put the Item into
	var addSubContainer;  //function to add a container to put the subItems into
	var addClosingElements = null;  //function to add closing elements to the container
	// Create element container
	if (level == 1) (function(){  //define function to have a separate variable scope
		// Render Item as Section
		//console.log('Render Section ' + name);
		var _itemContainer;
		var _subContainer;
		addItemContainer = function() {
			_itemContainer = document.createElement('h2');
			container.appendChild(_itemContainer);
			return _itemContainer;
		}
		addSubContainer = function() {
			_subContainer = document.createElement('div');
			_subContainer.className = 'section';
			container.appendChild(_subContainer);
			return _subContainer;
		};
		addClosingElements = function() {
			var closingElements = document.createElement('hr');
			container.appendChild(closingElements);
		}
	})();
	else if (level == 2) (function(){  //define function to have a separate variable scope
		// Render Item as Block
		//console.log('Render Block ' + name);
		var _itemContainer;
		var _subContainer;
		addItemContainer = function() {
			_itemContainer = document.createElement('div');
			_itemContainer.className = 'block';
			container.appendChild(_itemContainer);
			if (subItems != null) {
				var expandIcon = document.createElement('span');  //container to display '-' or '+'
				expandIcon.className = 'collapse-icon';
				_itemContainer.appendChild(expandIcon);
				var isExpanded = true;  //true if block is expanded
				var storageKey = 'expanded ' + myPath;
				if (localStorage) {
					// LocalStorage is available, use persistent value
					var v = localStorage.getItem(storageKey);
					console.log('Preset isExpanded for \'' + myPath + '\' to ' + v);
					if (v == 'false')
						isExpanded = false;
				}
				var displayExpandState = function() {
					console.log('Display isExpanded for \'' + myPath + '\' as ' + isExpanded);
					var vars = {
						'true': {  //expanded
							'icon': '\u25bc',  //'click to collapse' icon (U=25BC is black down-pointing triangle)
							'display': 'block',  //show children
							'className': 'collapse-icon'
						},
						'false': {  //collapsed
							'icon': '\u25b6',  //'click to expand' icon (U+25B6 is black right-pointing triangle)
							'display': 'none',  //hide children
							'className': 'expand-icon'
						}
					}[isExpanded];
					expandIcon.textContent = vars.icon;
					expandIcon.className = vars.className;
					if (_subContainer)
						_subContainer.style.display = vars.display;
				};
				expandIcon.onclick = function() {
					isExpanded = !isExpanded;
					console.log('Set isExpanded for \'' + name + '\' to ' + isExpanded);
					if (localStorage) {
						// LocalStorage is available, persist it
						localStorage.setItem(storageKey, isExpanded);
					}
					displayExpandState();
				};
				addClosingElements = function() {
					displayExpandState();  //display initial state
				}
			}
			return _itemContainer;
		}
		addSubContainer = function() {
			_subContainer = document.createElement('div');
			_subContainer.className = 'items';
			_itemContainer.appendChild(_subContainer);
			return _subContainer;
		}
	})();
	else (function(){  //define function to have a separate variable scope
		// Render Item is (sub-)Item
		//console.log('Render Item ' + name);
		var _itemContainer;
		var _subContainer;
		addItemContainer = function() {
			if (contItems != null) {
				_itemContainer = document.createElement('div');  //make a div for the continuation group
				_itemContainer.className = 'group';
				container.appendChild(_itemContainer);
			} else {
				_itemContainer = container;  //add item to the same container
			}
			return _itemContainer;
		}
		addSubContainer = function() {
			_subContainer = document.createElement('div');
			_subContainer.className = 'items';
			container.appendChild(_subContainer);
			return _subContainer;
		}
	})();
	// Create element itself
	if (name == '---') {
		// Special separator item
		var item = document.createElement('hr');
		item.className = 'separator';
		container.appendChild(item);
	} else {
		var itemContainer = addItemContainer();
		// Create hyperlink in Item container
		var innerContainer;
		if (url != null) {
			innerContainer = document.createElement('a');
			innerContainer.href = url;
			innerContainer.className = 'item link';
			if (target != null)
				innerContainer.target = target;
			if (tooltip != null)
				innerContainer.title = tooltip;
		} else {
			innerContainer = document.createElement('div');
			innerContainer.className = 'item';
		}
		itemContainer.appendChild(innerContainer);
		// Create icon in Item container
		var icon_present = outputIcon(innerContainer, null, icon, url);
		// Create text in Item container
		if (name != null) {
			if (icon_present && name == '_') {
				// Do not display the text
			} else {
				var text = document.createTextNode(name);
				innerContainer.appendChild(text);
			}
		}
		// If there is continuation, output those items in this container too
		if (contItems != null) {
			outputItems(contItems, level, itemContainer, myPath);
		}
	}
	// Create sub-Items in container
	if (subItems != null) {
		if (addSubContainer) {
			var subContainer = addSubContainer();
			outputItems(subItems, level+1, subContainer, myPath);
		}
	}
	// Add closing elements
	if (addClosingElements) {
		addClosingElements();
	}
}

// Render array of Links to the container at specified level.
function outputItems(links, level, container, parentPath = '') {
	for (var i = 0; i < links.length; ++i) {
		outputItem(links[i], level, container, parentPath);
	}
}

// }}}

// Output Icon {{{

// Create <img> item in the container.
// If alt_text is defined, use that.
// icon_url is what is specified in the icon=URL argument, see explanation at
// the top of this file.
// Returns true if a non-empty icon is generated.
//
// To retrieve the icon, first try the primary URL. If that fails and skip_alternatives==false,
// try these alternatives:
// - http://www.google.com/s2/favicons?domain=<target_url domain>
// - http://www.google.com/s2/favicons?domain=<icon_url domain>
function outputIcon(container, alt_text, icon_url, target_url, skip_alternatives = false) {
	// By default, construct icon_url from target_url
	if ((icon_url == null || icon_url == 'default') && target_url != null) {
		icon_url = getDefaultIconUrl(target_url);
	}

	// Resolve the IconDefs
	if (icon_url != null) {
		icon_url = resolveIconDefs(icon_url);
	}

	var icon_present = false;

	// Render icon_url
	var m;  //for regex matches
	if (icon_url == null) {
		console.log('Loading icon for target \'' + target_url + '\': null');
	} else if (icon_url == 'none') {
		console.log('Loading icon for target \'' + target_url + '\': \'' + icon_url + '\'');
	} else if (m = icon_url.match(/^html:(.+)/i)) {
		var html = m[1];
		// Create a 'data:...' pseudo URL that holds the data as SVG and put this text in a text node.
		var iconDiv = document.createElement('div');
		iconDiv.className = 'icon text-icon';
		var htmlDiv = document.createElement('div');
		htmlDiv.innerHTML = html;  //also takes care of HTML rendering
		FillScaler.observe(htmlDiv);
		iconDiv.appendChild(htmlDiv);
		container.appendChild(iconDiv);
		icon_present = true;
	} else {
		console.log('Loading icon for target \'' + target_url + '\': \'' + icon_url + '\'');
		var img = document.createElement('img');
		icon_present = true;
		if (icon_url == 'empty') {
			img.style.visibility = 'hidden';
			icon_present = false;  //there is an image, but still empty
		} else if (m = icon_url.match(/^char:(.+)/i)) {
			var text = m[1];
			// Create a 'data:...' pseudo URL that holds the data as SVG and put this text in a text node.
			icon_url = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">' + text + '</text></svg>';
			img.src = icon_url;
		} else {
			var alternatives = [], methods = [], urls = [];  //prepare options to use for the icon
			if (m = icon_url.match(/^alt(?::([^?]+))?(?:\?(.+))?/i)) {
				// icon_url contains an alt specification
				var method = m[1];
				var url = m[2];
				if (method == null || method == '' || method == 'any' || method == '*') {
					// Add all known methods
					methods.push('google');
				} else {
					// Add only the specified method
					methods.push(method);
				}
				if (url != null && url != '') {
					// Add the specified URL only
					urls.push(url);
				} else {
					// Add the icon_url (but that doesn't contain a URL) and target_url
					if (target_url != null && target_url != '') {
						urls.push(target_url);
					}
				}
			} else {
				// icon_url contains a URL of the icon
				alternatives.push(icon_url);
				if (!skip_alternatives) {
					// Try the alternatives in order of 'likely correct'.
					// Note that the google-favicons always returns an image, even a generic one, so it
					// will always prevent further alternatives to be attempted.
					methods.push('google');
					if (icon_url != null) {
						urls.push(icon_url);
					}
					if (target_url != null) {
						urls.push(target_url);
					}
				}
			}
			//console.log('All methods for ' + icon_url); console.log(methods);
			//console.log('All urls for ' + icon_url); console.log(urls);
			// Go through methods and urls and add alternatives
			for (var m = 0; m < methods.length; ++m) {
				var method = methods[m];
				for (var u = 0; u < urls.length; ++u) {
					if (method == 'google') {
						alternatives.push(getGoogleAltIconUrl(urls[u]));
					} else {
						console.error('Unknown alt icon method: ' + method);
					}
				}
			}
			//console.log('All alternatives for ' + icon_url); console.log(alternatives);
			// Remove duplicates
			var seen = {};
			var alt_list = alternatives;  //may have duplicates
			alternatives = [];  //get the unique ones
			for (var a = 0; a < alt_list.length; ++a) {
				if (!seen[alt_list[a]]) {
					seen[alt_list[a]] = true;
					alternatives.push(alt_list[a]);
				}
			}
			//console.log('All unique alternatives for ' + icon_url); console.log(alternatives);
			// Set the icon urls until we find one that works
			var try_next = function() {
				if (alternatives.length > 0) {
					// Try next alternative
					//console.log('alternatives.length=' + alternatives.length);
					//console.log('alternatives[0]=' + alternatives[0]);
					var alt = alternatives.shift();
					//console.log('alternatives.length=' + alternatives.length);
					if (img.src != null && img.src != '') {
						console.warn('Cannot load icon \'' + img.src + '\', try \'' + alt + '\'');
					}
					img.src = alt;
				} else {
					// Stop trying
					console.error('Cannot load icon: ' + img.src);
					if (alt_text != null) {
						// prepare to show the alt text
						img.src = '';
					} else {
						// hide entire image
						img.style.visibility = 'hidden';
					}
					img.onerror = null;  //stop handling errors
				}
			}
			img.onerror = try_next;
			try_next();  //set first alternative
		}
		if (alt_text != null) {
			img.alt = alt_text;
		}
		img.className = 'icon';
		container.appendChild(img);
	}

	return icon_present;
}

// Take icon_url and perform the icondef replacements.
// Returns the resolved value or the original value if no icondefs matched.
function resolveIconDefs(icon_url) {
	var retval = icon_url;
	var seen = {};  //to break cycles
	seen[icon_url] = 1;
	var override = IconDefs[icon_url];
	while (override !== undefined && !seen[override]) {
		console.log('Replace icon=' + icon_url + ' by IconDefs ' + override);
		retval = override;
		seen[override] = 1;
		override = IconDefs[override];
	}
	//console.log('Returning ' + retval);
	return retval;
};

// Define a ResizeObserver that is used to resize entries to 100% of their
// parent's size. This is used for icons that are defined with html:<x>.
var FillScaler = new ResizeObserver(function(entries) {
	for (var entry of entries) {
		var element = entry.target;
		// Get entries current size
		var w, h;
		if (entry.borderBoxSize) {
			var rect = entry.borderBoxSize[0];  //area of 1st (and only) fragment
			var writingMode = element.style.writingMode;
			//console.log('FillScaler: Writing mode ' + writingMode);
			if (writingMode.match(/^vertical/i)) {
				// Vertical writing-mode, so inline direction is vertical
				h = rect.inlineSize;
				w = rect.blockSize;
			} else {
				// Assume horizontal writing-mode, so inline direction is horizontal
				w = rect.inlineSize;
				h = rect.blockSize;
			}
		} else {
			var rect = entry.contentRect;
			w = entry.contentRect.width;
			h = entry.contentRect.height;
		}
		console.log('FillScaler: Element size ' + w + ' x ' + h);
		// Get parent's current size
		var parent = element.parentElement;
		var pw = parent.offsetWidth;
		var ph = parent.offsetHeight;
		//console.log('FillScaler: Parent size ' + pw + ' x ' + ph);
		// Calculate new scaling factor
		var scaleX = pw / w;
		var scaleY = ph / h;
		//console.log('FillScaler: Scale with ' + scaleX + ' x ' + scaleY);
		// Check if the change is big enough
		var changeX = element._scaleX / scaleX;
		var changeY = element._scaleY / scaleY;
		//console.log('FillScaler: Scale change ' + changeX + ' x ' + changeY);
		if (isNaN(changeX) || changeX < 0.98 || changeX > 1.02 || isNaN(changeY) || changeY < 0.98 || changeY > 1.02) {
			// More than 2% change
			console.log('FillScaler: Set scale ' + scaleX + ' x ' + scaleY);
			element._scaleX = scaleX;
			element._scaleY = scaleY;
			entry.target.style.scale = scaleX + ' ' + scaleY;
		} else {
			console.log('FillScaler: Scale change too small ' + changeX + ' x ' + changeY);
		}
	}
});

// Return the URL where the default icon should be.
function getDefaultIconUrl(site_url) {
	return site_url.replace(/(?:(?:(?<!\/)\/(?!\/)|\?|#).*)?$/, '/favicon.ico');  //replace first single '/', '?' or '#' and onwards
}

// Return the URL for an icon of the site_url's domain.
// This method uses the Google database.
function getGoogleAltIconUrl(site_url) {
	var domain = site_url
		.replace(/^[^\/]*\/\//, '')  //remove scheme
		.replace(/\/.*/, '');  //remove path
	return 'http://www.google.com/s2/favicons?domain=' + domain;
}

// }}}

// }}}

// SearchBox related functions {{{

// The search functions will be accessed by name (lower case identifier).
// Every identifier has sub-keys for different functions.
// A search function has the search query as input and should return a URL to
// go to for the results.

var SearchFunction = {
	'duck' : {
		'text'   : getTemplateUrl('https://duckduckgo.com?q=%urlinput'),
	},
	'google' : {
		'text'   : getTemplateUrl('https://www.google.com/search?q=%urlinput'),
	},
	'wikipedia' : {
		'text'   : getTemplateUrl('https://www.wikipedia.org/wiki/Special:Search?go=Go&search=%urlinput'),
	},
	'youtube' : {
		'text'   : getTemplateUrl('https://www.youtube.com/results?search_query=%urlinput'),
	},
	'wayback' : {
		'text'   : getWaybackSearchUrl,
		'domain' : getWaybackDomainUrl,
	},
	'googlemaps' : {
		'text'   : getTemplateUrl('https://maps.google.com/?q=%urlinput'),
	},
	'default' : {
		'text'   : getNoUrl,
		'domain' : getWithSchemaUrl,
	},
};

// Return a URL to handle the address (ie beautify it to go to it).
function getWithSchemaUrl(address) {
	var url = address;
	if (!url.match(/^[\w+-]+:/)) {
		url = 'http://' + url;  //add default scheme
	}
	return url;
}

// This is a dummy search function, that can be used as a default.
function getNoUrl(intput) {
	return null;
}

// This function returns a functions that uses the template to construct a URL.
// The template is a URL with the following placeholders:
// - %input: Replaced with the supplied input value.
// - %urlinput: Replaced with the URL-encoded input value.
function getTemplateUrl(template) {
	return function(input) {
		var encoded_input = encodeURIComponent(input).replace(' ', '+');
		return template
			.replace('%input', input)
			.replace('%urlinput', encoded_input);
	};
}

// Returns a URL to perform a lookup for the domain with Wayback Machine.
function getWaybackDomainUrl(domain) {
	var ts = getWaybackTimestamp();
	return 'https://web.archive.org/web/' + ts + '/' + domain;
};

// Returns a URL to perform a search for input with Wayback Machine.
function getWaybackSearchUrl(input) {
	var ts = getWaybackTimestamp();
	var encoded_input = encodeURIComponent(input).replace(' ', '+');
	return 'https://web.archive.org/web/' + ts + '/' + encoded_input;
};

// Create a Wayback Machine timestamp that can be used in queries.
function getWaybackTimestamp(date = new Date()) {
	var pad = function(number, positions) {
		var neg = false;
		if (number < 0) {
			neg = true;
			positions--;  //space for '-'
			number = -number;
		}
		var s = '';
		for (var i = 2, limit = 10; i <= positions; ++i, limit *= 10) {
			if (number < limit) s += '0';
		}
		s += number;
		if (neg) s = '-' + s;
		return s;
	};
	// I assume the format is 'yyyymmddhhmmss*' with yyyy the year
	// to query and the rest '0'.
	var timestamp = pad(date.getFullYear(), 4) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		'*';
	return timestamp;
}

var UNICODE_ANGRY_FACE = '\u{1F620}';  //angry face
var UNICODE_POUTING_FACE = '\u{1F621}';  //red angry face
var UNICODE_FACE_WITH_LOOK_OF_TRIUMPH = '\u{1F624}';  //steamy nose angry face
var UNICODE_SERIOUS_FACE_WITH_SYMBOLS_COVERING_MOUTH = '\u{1F92C}';  //red swearing face

var EmptySearchCounter = 0;

// Process search input.
// Redirects to search.
// May return if search input is not clear.
function processSearchInput(searchBox, getSearchUrl, getDomainSearchUrl = getWithSchemaUrl) {
	var input = searchBox.value;
	if (input.match(/^\s*$/)) {
		console.log('Empty search string');
		// Set the blink anymated style
		searchBox.classList.add('blink');
		//console.log('searchBox.className=' + searchBox.className);
		// Set the funny feedback text with angry faces
		++EmptySearchCounter;
		var funny_feedback;
		if (EmptySearchCounter <= 2)
			funny_feedback = '';
		else if (EmptySearchCounter <= 3)
			funny_feedback = UNICODE_ANGRY_FACE;
		else if (EmptySearchCounter <= 6)
			funny_feedback = UNICODE_POUTING_FACE.repeat(EmptySearchCounter - 3);
		else
			funny_feedback = UNICODE_FACE_WITH_LOOK_OF_TRIUMPH.repeat(EmptySearchCounter - 3);
		searchBox.placeholder = funny_feedback;
		// Set the event to clean up
		searchBox.onanimationend = function() {
			//console.log('animation end');
			searchBox.classList.remove('blink');
			//console.log('searchBox.className=' + searchBox.className);
			searchBox.placeholder = '';  //remove funny feedback
		};
	} else {
		EmptySearchCounter = 0;
		var m = input.match(/^\s*(\S+\.\S+)\s*$/);
		var url = null;
		if (m && getDomainSearchUrl) {
			//console.log('Looks like URL');
			url = getDomainSearchUrl(m[1]);
			console.log('Go to URL \'' + url + '\'');
		} else {
			url = getSearchUrl(input);
			console.log('Search \'' + url + '\'');
		}
		if (url) {
			window.location.href = url;
		} else {
			console.log('No URL to go to');
		}
	}
}

// }}}

// Initialization {{{

// This function should be called at the top of the body.
// It is responsible for ultimately setting the Links variable as described at
// the top of this file.
//
// The contents of Links can be obtained in the following way:
// 1) If the links= query string is set on the URL, that contents is used.
//    This can also be a url:xxx value.
// 2) Otherwise if there is a 'links' key in LocalStorage, that value is used.
// 3) If Links matches 'url:url', the contents of that URL is downloaded and
//    evaluated as script. It should set the Links variable.
// 4) If Links is empty at this point, use a default contents.
// 5) Links should now have a value that can be parsed as specified below.
function resolveLinks() {
	// Step 1) Check if Links is defined in the query string
	var params = new URLSearchParams(location.search);
	var v = params.get('links');
	if (v) {
		console.log('Use links= from the query string');
		Links = v;

	} else {
		// Step 2) Check if Links is defined in LocalStorage
		if (localStorage) {
			// LocalStorage is available, use persistent value
			var v = localStorage.getItem('links');
			if (v) {
				console.log('Use links from the LocalStorage');
				Links = v;
			}
		}
	}

	// Step 3) If Links is a URL, resolve it
	if (Links != null) {
		var m = Links.match(/^\s*url\s*:\s*(\S+)\s*$/i);
		if (m) {
			// It specifies a URL, output code to download and evaluate it
			var url = m[1];
			Links = '';
			console.log('Links defined by URL \'' + url + '\'');
			// To use document.write(), we must be inside the <body>.
			// It should be loaded in blocking mode, because we need the
			// value of the Links.
			document.write('<script src="' + url + '" type="text/javascript"><\/script>');  //this URL should set Links
		}
	}

	// Step 4) If Links is still empty, use a default contents.
	if (Links == null || Links == "") {
		console.log('Use standard example Links');
		Links = `
// See also example-links.js

!title Example Favorites
General
    Search
        DuckDuckGo https://duckduckgo.com
        Google Maps icon=alt https://maps.google.com
        Wikipedia https://www.wikipedia.org
        YouTube https://www.youtube.com
    Source
        GitHub favorite-links https://github.com/anne-gert/favorite-links
        & Direct icon=none https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html
Other
    News
        nu.nl https://nu.nl
    Socials
        Facebook https://www.facebook.com
            Instagram https://www.instagram.com/
            WhatsApp Web https://web.whatsapp.com/
        ---
        LinkedIn https://www.linkedin.com/
    Firefox
        Settings icon=firefox about:preferences target=manual
            All Configuration icon=firefox about:config target=manual
        All about:* icon=firefox about:about target=manual

// Icon definitions
!icondef firefox    https://support.mozilla.org

// Search button definitions
//      Identifier | Label  | Tooltip      | Icon
!search Duck       | Search | Duck Duck Go |
!search Google     | Search |              |
!search Wikipedia  |        |              |
!search YouTube    |        |              |
!search GoogleMaps | Maps   | Google Maps  | alt
		`;
	}

	// Step 5) Now Links can be parsed when init() is called.
}

// Function to set the title to the specified string.
function setPageTitle(title) {
	var titleCtl = document.getElementById('title');
	if (titleCtl)
		titleCtl.innerText = title;
}

// Create search button to container and set up the event callback.
// This also adds icons to the buttons. Do that here instead of with
// static HTML, because I saw that the browser tries to render static
// images before the JavaScript generated ones and I'd like to render
// the links as soon as possible.
// The displayed icon is specified by icon_url. If this is 'alt', the
// target domain is derived from getSearchUrl().
function addSearchButton(container, search_box, button_id, label_text, tooltip, icon_url, getSearchUrl, getDomainSearchUrl) {
	var btn = document.createElement('button');
	if (btn) {
		// Configure the button
		btn.id = 'BtnSearch' + button_id;
		btn.className = 'button';
		btn.onclick = function() {
			processSearchInput(search_box, getSearchUrl, getDomainSearchUrl);
			return false;  //skip default handling
		}
		btn.title = tooltip;

		// Add icon
		var target_domain = getSearchUrl('dummy');
		//console.log('target_domain=' + target_domain);
		//console.log('favicon=' + getDefaultIconUrl(target_domain));
		// When determining the icon, don't consider alternatives,
		// except when icon_url == 'alt...'
		outputIcon(btn, tooltip, icon_url, target_domain, true);

		// Add link text
		var label = document.createElement('span');
		label.className = 'label';
		var textNode = document.createTextNode(label_text);
		label.appendChild(textNode);
		btn.appendChild(label);

		// Add the button to the container
		container.appendChild(btn);
	}
}

function addSearchButtons(searchBox, container) {
	for (var i = 0; i < SearchButtonDefs.length; ++i) {
		// Get the fields from the definition
		var def = SearchButtonDefs[i];
		var f = 0;

		// Determine Identifier
		var id = def[f++];
		if (!id) continue;  //id is mandatory, ignore this entry if absent
		var key = id.toLowerCase();  //lower case version

		// Determine referenced Search URL Function
		var getSearchUrl = SearchFunction[key]['text'];

		// Determine referenced Domain Search URL Function
		var getDomainSearchUrl = SearchFunction[key]['domain'];

		// Determine Label
		var label = def[f++] || id;

		// Determine Tooltip
		var tooltip = def[f++] || id;

		// Determine Icon
		var icon = def[f++];
		if (!icon) {
			if (getSearchUrl) {
				// Search URL function is defined. This is
				// needed to retrieve the 'default' icon.
				icon = 'default';
			} else {
				// There is no Search URL function, use a
				// standard magnifying glass icon.
				icon = 'html:&#x1F50D;';
			}
		}

		// Determine final Search URL Function
		if (!getSearchUrl) {
			// No Search Function, use default (assume it exists)
			getSearchUrl = SearchFunction['default']['text'];
		}

		// Determine final Domain Search URL Function
		if (!getDomainSearchUrl) {
			// No Search Function, use default (assume it exists)
			getDomainSearchUrl = SearchFunction['default']['domain'];
		}

		// Log the fields
		console.log('addSearchButtons: Identifier=\'' + id + '\'');
		console.log('addSearchButtons: Label=\'' + label + '\'');
		console.log('addSearchButtons: Tooltip=\'' + tooltip + '\'');
		console.log('addSearchButtons: Icon=\'' + icon + '\'');
		console.log('addSearchButtons: getSearchUrl=\'' + getSearchUrl + '\'');
		console.log('addSearchButtons: getDomainSearchUrl=\'' + getDomainSearchUrl + '\'');
		console.log(SearchFunction);

		// Create the button
		addSearchButton(container, searchBox, id, label, tooltip, icon, getSearchUrl, getDomainSearchUrl);
	}
}

// Initialize the JavaScript on the page
function init() {
	// Parse Links
	var rootLinks = parseLinks(Links);

	// Set page title
	if (PageTitle) {
		setPageTitle(PageTitle);
	}

	// Render Links
	var container = document.getElementById('LinksBox');
	outputItems(rootLinks, 1, container);

	// Fill SearchForm
	// Use a static input field, so that the browser retains its contents
	// after going back to this page.
	if (SearchButtonDefs != null && SearchButtonDefs.length > 0) {
		// There are SearchButtens, fill SearchForm
		console.log('There are ' + SearchButtonDefs.length + ' SearchButtonDefs');
		// Focus SearchBox
		var searchBox = document.getElementById('SearchBox');
		if (searchBox) {
			searchBox.focus();
			searchBox.select();
		}
		// Initialize the search buttons
		var buttonBox = document.getElementById('SearchButtons');
		addSearchButtons(searchBox, buttonBox);
	} else {
		// No SearchButtons defined, hide SearchForm
		console.log('There are no SearchButtonDefs');
		var searchForm = document.getElementById('SearchForm');
		if (searchForm) {
			console.log('Hide SearchForm');
			searchForm.style.display = 'none';
		}
	}
}
window.onload = init;

// }}}
</script>

</head>

<body>

<script>
resolveLinks();
</script>

<h1 id="title">Favorites</h1>

<form id="SearchForm" class="search-form">
Search:
<input id="SearchBox" name="q" type="text" size="40" class="box"/>
<span id="SearchButtons"></span>
</form>

<div id="LinksBox"></div>

</body>

</html>

<!-- vim: set fdm=marker: -->

