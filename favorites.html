<!DOCTYPE html>
<html>

<!--
For description of this file, see README.md
For syntax description of Links, see help.html
-->

<head>

<!-- This page may contain UTF-8 encoded text, especially in the Links definition. -->
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Cache-Control" content="public">

<title>Favorites</title>

<style>
/* CSS styles {{{ */

/****************************************************************************
 * Global definitions
 ****************************************************************************/

/* Color palette - dark theme */
.dark-theme {
	--foreground: #DDDDDD;
	--background: #181818;
	--accent-color: #50A0EE;
	--block-foreground: #000000;
	--block-background: #C9CDD0;
	--block-border: #EEEEEE;
	--selection-foreground: #000000;
	--selection-background: #DDDDFF;
	--code-foreground: #FFFFFF;
	--code-background: #292D36;
	--link-color: #6666FF;
	--disabled-color: #888888;
	--error-foreground: #FF6600;
	--error-background: #FFD8C0;
	--error-border: var(--error-foreground);
}

/* Color palette - light theme */
.light-theme {
	--foreground: #444444;
	--background: #E8F0F8;
	--accent-color: #4444EE;
	--block-foreground: #222222;
	--block-background: #D9DDE0;
	--block-border: #999999;
	--selection-foreground: #FFFFFF;
	--selection-background: #000099;
	--code-foreground: #000000;
	--code-background: #E3EBF3;
	--link-color: #2222AA;
	--disabled-color: #888888;
	--error-foreground: #FF8844;
	--error-background: #FFEEDD;
	--error-border: #FFBB88;
}

:root {
	/* Define variables that will be used on visible elements */
	--font-family: 'Segoe UI', 'Lucida Grande', Helvetica, sans-serif;
	--font-size: 100%
	/* Set default font and size */
	font-family: var(--font-family);
	font-size: 12pt;  /* absolute, so --font-size can be relative too */
	scrollbar-width: thin;
}

/** Internet Explorer */
@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {
}

/** Microsoft Edge (pre-Chromium) */
@supports (-ms-ime-align: auto) {
	.dark-theme {
		--background: #3B3B3B;
	}
	.light-theme {
		--background: #F7F7F7;
	}
}

/** Safari */
@media not all and (min-resolution: 0.001dpcm) {
}

/** Chromium (Chrome, Edge) but also Firefox */
@media screen and (-webkit-min-device-pixel-ratio: 0) and (min-resolution: 0.001dpcm) {
	.dark-theme {
		--background: #3B3B3B;
	}
	.light-theme {
		--background: #F7F7F7;
	}
}

/** Mozilla Firefox */
@supports (-moz-appearance: none) {
	.dark-theme {
		--background: #1C1B22;
	}
	.light-theme {
		--background: #EAEAED;
	}
}


/****************************************************************************
 * Resizing for mobile devices
 ****************************************************************************/

/*
https://www.w3schools.com/css/css_rwd_mediaqueries.asp advices the following sizes:
- max-width=600px: Extra small devices (phones)
- min-width=600px: Small devices (portrait tablets and large phones)
- min-width=768px: Medium devices (landscape tablets)
- min-width=992px: Large devices (laptops/desktops)
- min-width=1200px: Extra large devices (large laptops and desktops)

https://www.w3schools.com/cssref/css_units.php makes the following recommendations:
- Use relative lengths (em, %, rem, vw, vh) for screen display.
- Use absolute lengths (cm, px, pt) for print display.
- Pixels (px) are only literal pixels for low-dpi devices. For high-dpi
  devices, 1px is multiple physical pixels.
  The ratio of physical to logical pixels can be retrieved in JavaScript with
  window.devicePixelRatio;
- Here it defines: 1in = 2.54cm = 25.4mm = 72pt = 6pc = 96px

https://stackoverflow.com/questions/8785643/what-exactly-is-device-pixel-ratio describes the direct use of device-pixel-ratio in CSS:
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	only screen and (min--moz-device-pixel-ratio: 1.5),
	only screen and (-o-device-pixel-ratio: 3/2),
	only screen and (min-device-pixel-ratio: 1.5) {
	... high-resolution screens ...
}

Also, disable automatic text-sizing, because that determines the font-size
for each block independently.
*/
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	only screen and (min--moz-device-pixel-ratio: 1.5),
	only screen and (-o-device-pixel-ratio: 3/2),
	only screen and (min-device-pixel-ratio: 1.5) {
	/* high-resolution screens */
	:root {
		/* Make text bigger, because otherwise it gets too small on
		   phones. (I'm not sure why, because 12pt should be the same
		   absolute size on every screen. */
		font-size: 18pt;
	}
	html {
		text-size-adjust: none;
		-moz-text-size-adjust: none;
		-webkit-text-size-adjust: none;
	}
	input[type=checkbox] {
		/* For mobile, make checkboxes bigger with more padding for fat fingers. */
		transform: scale(2);
		margin: 0.7em;
		position: relative; left: -0.5em;
	}
	/* For some reason, the right-hand side of the items is hidden (if overflow=clip it
	   *is* shown, but then the animation does not work correctly. Also using another
	   unit besides fr makes the animation not work correctly.
	   Since this only happens on mobile (I tested Firefox as well as Chrome on Android),
	   I can force a bit of extra padding on the block-items level.
	   I also tested if the font-adjustment had any influence. It didn't. */
	.block-items {
		padding-right: 1em;
	}
}

body, input, textarea, button {
	font-family: var(--font-family);
	font-size: var(--font-size);
}

body {
	color: var(--accent-color); background: var(--background);
}
::selection {
	color: var(--selection-foreground); background: var(--selection-background);
}

.normal {
	color: var(--foreground);
}
.alert {
	color: var(--error-foreground);
}
.accent {
	color: var(--accent-color);
}
.hidden {
	display: none;
}
.alert-box {
	color: var(--foreground);
	margin: 1em 3em 0.5em;
	padding: 0.5em 1em;
	border-left: 0.2em solid var(--error-foreground);
}
.alert-box .label {
	color: var(--error-foreground);
}
.debug-box {
	color: #600;
	background: #FFC;
	border: 2px solid #F90;
	white-space: pre-wrap;
	border-radius: 0.4em;
	margin: 0.2em; padding: 0.3em;
}


/****************************************************************************
 * Shared styles for displaying text-blocks
 * These syles are shared between all pages
 ****************************************************************************/

.text-block {
	color: var(--foreground); background: var(--background);
}
.text-block h1, .text-block h2, .text-block h3, .text-block dt {
	color: var(--accent-color);
}
.text-block code, .text-block pre {
	color: var(--code-foreground); background: var(--code-background);
}
.text-block code {
	padding: 0.1em 0.4em;
}
.text-block pre {
	padding: 0.6em 1em;
	margin: 0.5em 4em;
	overflow: scroll;
}
.text-block dt {
	display: inline;
}
.text-block a {
	color: var(--link-color);
	text-decoration: none;
}
.text-block a:hover {
	text-decoration: underline;
}
.text-block .important {
	color: var(--error-foreground);
}


/****************************************************************************
 * Section styles
 ****************************************************************************/

.section {
	display: block;
}


/****************************************************************************
 * Block styles
 ****************************************************************************/

.block {
	display: inline-block;
	vertical-align: top;
	border: .15em solid var(--block-border);
	border-radius: 0.5em;
	padding: 1em;
	margin: 0.5em;
	color: var(--block-foreground); background: var(--block-background);
}
.items {
	margin-left: 2em;
}
.block-items {  /* First indentatiion level in a Block (kind-of like the title of a Block) */
	margin-left: 0.5em;
}


/****************************************************************************
 * Icons
 ****************************************************************************/
/* Icons can be one of three types:
 * - Image: img.icon.img-icon
 * - SVG: .icon.svg-icon > svg  (also used for char:x icons)
 * - HTML: .icon.html-icon > div
 * Icons can be used in one of two places:
 * - Link icon: .link > .icon
 * - Custom checkbox: .custom-checkbox > .icon
 */

.icon {
	width: 1.0em; height: 1.0em;
	margin-right: 0.2em;
	vertical-align: -10%;
}
.icon * {
	overflow: visible;
}

.html-icon, .svg-icon {
	display: inline-block;
	padding: 0em;
	text-decoration: none;
}
.html-icon div {
	position: relative;
	margin: 0em; padding: 0em;
	transform-origin: 0 0;
}
.svg-icon svg {
	position: relative;
	width: 100%; height: 100%;
	margin: 0em; padding: 0em;
	top: -0.20em;
	transform-origin: 0 0;
}
svg {
	fill: currentColor; stroke: none;  /* default color */
}

/****************************************************************************
 * Item and SubItem styles
 ****************************************************************************/

.item {
	display: table;
	padding: 0.1em;
}

.strong {
	& .delim-open, & .delim-close {
		font-size: 80%;
		letter-spacing: -0.1em;
		visibility: hidden;
	}
	& .delim-text {
		font-weight: bold;
	}
}
.strong:hover {
	& .delim-open, & .delim-close {
		visibility: visible;
	}
}

/* Item Groups for continuation */

.group > .item {
	display: inline;
}
.group > .item:first-of-type {  /* Group leader */
}
.group > .item:not(.item:first-of-type) {  /* Continuation items */
	margin-left: 0.4em;
}

/* Item Checkboxes */

.todo-checkbox {
	margin-right: 0.2em;
}
.checkbox-label {
}
.cbx-opt-default-check {
	.todo-checkbox { }
	a {
		text-decoration: none;
	}
	a:hover {
		text-decoration: underline;
	}
	.checkbox-label {
		color: var(--disabled-color);
		text-decoration: line-through;
	}
}

.custom-checkbox {
	display: inline-block;
	cursor: default;
	/* Add padding to the left, so that icon is not cut off when transformed bigger */
	padding-left: 0.2em;
	padding-right: 0.2em;
	transition: transform 0.05s ease-out;  /* used when hover -> not-hover */
}
.custom-checkbox:hover {
	transform: scale(1.3);
	transition: transform 0.2s ease-out;  /* used when not-hover -> hover */
}
.custom-checkbox .icon {
	margin: 0px;
}
.custom-checkbox .img-icon {
	transform: scale(1.2);
}
.custom-checkbox .svg-icon {
	padding-top: 0.1em;
	transform: scale(1.2);
}
.custom-checkbox .html-icon {
	transform: scale(1.4);
}
.checkbox-label.not-first-option {
}

.custom-checkbox:first-of-type {  /* checkbox at the left */
	margin-right: 0.2em;
}
.custom-checkbox:last-of-type {  /* checkbox at the front */
	margin-left: 0.3em;
}

.any-parent-checked {
}
.any-child-checked {
}
.self-checked {
}
.any-child-checked:not(.self-checked) {
}

/* Item Icons */

.link .item-icon {
	vertical-align: -15%;
}
.items > .item {  /* selects all non-grouped elements */
}
.link {  /* selects all links */
}
.items > .item .link {  /* selects all non-grouped links */
	vertical-align: 15%;
}
.items > .group > .item .link {  /* selects all grouped links */
}

/* Item Separator */

.item .separator {
	margin: 0em -1em 0em -1em;
}


/****************************************************************************
 * Search Form
 ****************************************************************************/

.search-form .textbox {
	font-size: 110%;
}
.search-form .button {
	margin: 0.3em;
}
.search-form .button .icon {
	width: 1.5em; height: 1.5em;
	vertical-align: -25%;
}
.search-form .button .label {
	margin: 0em 0.3em;
}


/****************************************************************************
 * Settings Form
 ****************************************************************************/

.settings-iconbar {
	position: absolute;
	top: 10px; right: 10px;
	text-align: right;
}
.settings-icon {
	font-size: 200%;
	cursor: pointer;
	padding: 0px 0.1em;
}
/* Zoom on hover */
.settings-icon {
	display: inline-block;
	height: 1.5em;
	/* Default transform-origin is the center of the bounding box. With
	   this height, this center matches the caracter center. */
	transition: transform 0.3s ease-out;
}
.settings-icon:hover {
	transform: scale(1.3);
}
.settings-icon:active {
	transform: scale(1);
	/* After activation, do the transition quickly, so that it better
	   combines with the following buttonbar animation. */
	transition: transform 0.1s ease-out;
}

.settings-form {
	overflow: hidden;
	display: grid;
	grid-template-rows: auto max-content;
}
.settings-form .panel {
	height: 49em;
	overflow: auto;
}
.settings-form .client {
	width: 95%;
}
.settings-form .textbox {
	width: 100%;
	height: 46em;
	resize: both;
	overflow: scroll;
	color: var(--foreground); background: var(--background);
	font-family: monospace;
}
.settings-form .buttonbar {
	text-align: right;
}
.settings-form .button {
	margin: 0.3em;
}

.settings-form .options {
	display: grid;
	gap: 1em;
	grid-template-columns: max-content auto;
	padding: 1em 1em 1em 0.2em;
}
.input input {
	width: 100%;
}


/****************************************************************************
 * Status line
 ****************************************************************************/

.status-line {
	font-size: 80%;
	color: var(--background);
	background: var(--background);
}
.status-line.visible {
	color: var(--foreground);
}
.status-line:hover {
	background: color-mix(in hsl, var(--background), #777 20%);
}


/****************************************************************************
 * blink animation
 ****************************************************************************/

.blink {
	border: .15em solid transparent;
	animation: 500ms 4 blinker;
}
@keyframes blinker {
	30% {
		color: var(--error-foreground);
		background-color: var(--error-background);
		border-color: var(--error-border);
	}
}


/****************************************************************************
 * settings-form and settings-iconbar animation
 ****************************************************************************/

.settings-form {
	display: none;
	height: 50em;
}
.settings-form.show {
	display: block;
}
.settings-form.expanding {
	animation: 700ms ease settings-form-grow;
}
.settings-form.collapsing {
	animation: 700ms ease reverse settings-form-grow;
}
@keyframes settings-form-grow {
	0% {
		height: 0em;
	}
	100% {
		height: 50em;
	}
}
.settings-form.expanding .client {
	animation: 700ms ease settings-form-scale;
}
.settings-form.collapsing .client {
	animation: 700ms ease reverse settings-form-scale;
}
@keyframes settings-form-scale {
	0% {
		transform: scaleY(0);
		transform-origin: top;
	}
	100% {
		transform: scaleY(1);
		transform-origin: top;
	}
}

.settings-iconbar .slide-in {
	animation: 200ms ease-in settings-iconbar-slider;
}
.settings-iconbar .slide-out {
	animation: 200ms ease-out reverse settings-iconbar-slider;
}
@keyframes settings-iconbar-slider {
	0% {
		transform: scale(0, 0.4);
		transform-origin: right;
	}
	100% {
		transform: scale(1, 1);
		transform-origin: right;
	}
}


/****************************************************************************
 * slider-container and resize-button animation
 ****************************************************************************/

/* Note: On Firefox, if all collapsing/expanding animations do not take the
   same amount of time, it becomes jerky. Therefore, use the same amount of
   time and arrange different animation speeds with the @keyframes. */

.slider-container {
	/* As described in https://keithjgrant.com/posts/2023/04/transitioning-to-height-auto/,
	   animating height to height:auto is not always possible, e.g. on Firefox. A solution
	   is to animate grid-template-rows and add an extra intermediate <div>. */
	display: grid;
	grid-template-rows: 1fr;
	grid-template-columns: 1fr;
}
.slider-container > * {  /* the slider-container items */
	overflow: hidden;
	white-space: nowrap;
	/* For the grow animation, the grid-item must have overflow:hidden,
	   otherwise the container's size is not shrunk.
	   In this setup, the size of the container and its single item is
	   always the same. For Firefox on Linux, there is a quirk where the
	   width of the container is about 1em smaller than the container and
	   because of the overflow:hidden, this part is removed.
	   It works to add 1em padding to the item and compensate this with
	   -1em margin, so that the total width is the same.
	   This behavior can be made visible by adding 1px borders to
	   .slider-container and its items. */
	padding-right: 1em;
	margin-right: -1em;
}
.collapsing .slider-container {
	animation:
		400ms ease-out reverse block-expanding-x,
		400ms ease-out reverse block-expanding-y;
}
.expanding .slider-container {
	animation:
		400ms ease-out block-expanding-x,
		400ms ease-out block-expanding-y;
}
.collapsed .slider-container {
	grid-template-rows: 0fr;
	grid-template-columns: 0fr;
}
.expanded .slider-container > * {
	overflow-x: auto;
}
@keyframes block-expanding-x {
	0% {
		grid-template-columns: 0fr;
	}
	60%, 100% {
		grid-template-columns: 1fr;
	}
}
@keyframes block-expanding-y {
	0%, 20% {
		transform: scaleY(0);
		transform-origin: top;
		grid-template-rows: 0fr;
	}
	100% {
		transform: scaleY(1);
		transform-origin: top;
		grid-template-rows: 1fr;
	}
}

/* resize-button animation */

.resize-icon {
	float: right;
	position: relative;
	top: -0.9em; right: -0.6em;
	cursor: pointer;
	color: var(--disabled-color);
	transform: rotate(90deg);
}
.collapsing .resize-icon {
	animation: 400ms ease animate-resize-icon;
}
.expanding .resize-icon {
	animation: 400ms ease reverse animate-resize-icon;
}
.collapsed .resize-icon {
	color: var(--block-foreground);
	transform: rotate(0deg);
}
@keyframes animate-resize-icon {
	0%, 30% {
		color: var(--disabled-color);
		transform: rotate(90deg);
	}
	70%, 100% {
		color: var(--block-foreground);
		transform: rotate(0deg);
	}
}

/* }}} */
</style>

<!-- Unit test hooks {{{ -->

<script>
// The following variables do nothing if they are not set.
// If they are set, they provide hook functions for unit tests.

// Define a function to be called just before init() is executed.
// This can be used to preset elements for the test.
let HOOK_Init = null;

// Define a function to be called instead of rendering the Links.
// Note: This may be an async function.
let HOOK_Run = null;

// Define an object that contains the QueryString to be used instead of
// location.search. This object contains the following fields:
// - get(): Returns the value for the QueryString.
// - onreset(callback): Register an event that should be called in test
//   situations when values should be recalculated.
let HOOK_QueryString = null;

// Define an object that is used for localStorage. This object contains the
// following fields:
// - getItem(key): Returns the value for the key.
// - setItem(key, value): Sets the value for the key.
// - removeItem(key): Removes the key.
// - onreset(callback): Register an event that should be called in test
//   situations when values should be recalculated.
let HOOK_LocalStorage = null;

// Define an object that describes the next response of the downloadLinks()
// call. This object contains the following fields:
// - response(url, headers, body): Method to return a Promise for a the
//   response for the url + headers + body. This response object contains the
//   following fields:
//   - status: Status code of the response.
//   - text: Contents of the response.
let HOOK_Download = null;

// Define an object that describes the next response of the uploadLinks() call.
// Fields are the same as HOOK_Download.
let HOOK_Upload = null;

// Define an object that controls the next access to Settings. This object
// contains the following fields:
// - update(config, loadOptions, saveOptions, hideFunction): Method to be
//   called with the current controls for the fields. Should modify the
//   controls and then call the hideFunction() to 'save', 'clear' or 'cancel'.
let HOOK_ChangeSettings = null;

// Define an object with the following methods:
// - start(): Called before a Promise operation is started.
// - stop(): Called after the Promise resolved.
// This object can contain a wait() function that can wait for the stop() call
// that matches the first start() call.
// The operation is one of:
// - Open-Change-Close Settings.
// - downloadUploadLinks(), also covers download.
let HOOK_Ready = null;
</script>
<!--script src="test/unittest.js"></script-->

<!-- }}} -->

<script>
// Constants {{{

const LogUnicode = CreateLogger();
const LogEvents = CreateLogger();
const LogStorage = CreateLogger();
const LogUrlResolver = CreateLogger('log');
const LogUpDownload = CreateLogger();
const LogUpDownloadDefer = CreateLogger();
const LogParse = CreateLogger();
const LogRender = CreateLogger();
const LogBlockExpand = CreateLogger();
const LogCheckbox = CreateLogger();
const LogIcon = CreateLogger();
const LogSearch = CreateLogger();
const LogSettings = CreateLogger('log');
const LogStatusLine = CreateLogger();
const LogInit = CreateLogger();
const LogLinksUpdate = CreateLogger('log');

const IconRefLoopDefault = 'char:!ND!';
const IconUndefinedDefault = 'char:!ND!';
const CheckboxEmpty = 'char:!EE!';
const CheckboxRefLoop = 'char:!RL!';
const CheckboxError = 'char:!FF!';

// Unicode Plane: Basic Multilingual Plane (U+0000 - U+FFFF)
// Unicode Block: Arrows
const UNICODE_LEFTWARDS_ARROW_WITH_HOOK = '\u{21A9}';  //a 'swoosh' arrow
const UNICODE_RIGHTWARDS_ARROW_WITH_HOOK = '\u{21AA}';  //a 'swoosh' arrow
const UNICODE_ANTICLOCKWISE_TOP_SEMICIRCLE_ARROW = '\u{21B6}';  //a 180 degree arc
const UNICODE_CLOCKWISE_TOP_SEMICIRCLE_ARROW = '\u{21B7}';  //a 180 degree arc
const UNICODE_ANTICLOCKWISE_OPEN_CIRCLE_ARROW = '\u{21BA}';  //a 270 degree arc
const UNICODE_CLOCKWISE_OPEN_CIRCLE_ARROW = '\u{21BB}';  //a 270 degree arc
// Unicode Block: Geometric Shapes
const UNICODE_WHITE_SQUARE_CONTAINING_BLACK_SMALL_SQUARE = '\u{25A3}';  //checkbox with square
const UNICODE_BLACK_DOWN_POINTING_TRIANGLE = '\u{25BC}';
const UNICODE_BLACK_RIGHT_POINTING_TRIANGLE = '\u{25B6}';
// Unicode Block: Miscellaneous Symbols
const UNICODE_BALLOT_BOX = '\u{2610}';  //empty checkbox
const UNICODE_BALLOT_BOX_WITH_CHECK = '\u{2611}';  //checked checkbox
const UNICODE_BALLOT_BOX_WITH_CROSS = '\u{2612}';  //crossed checkbox
const UNICODE_GEARS = '\u{2699}';  //gears wheel
// Unicode Block: Dingbats
const UNICODE_CHECK_MARK = '\u{2713}';
const UNICODE_HEAVY_CHECK_MARK = '\u{2714}';
const UNICODE_CROSS_MARK = '\u{274C}';  //cross
// Unicode Block: Variation Selectors
const UNICODE_VARIATION_SELECTOR_15 = '\u{FE0E}';  //suffix to use monochrome text-character
const UNICODE_VARIATION_SELECTOR_16 = '\u{FE0F}';  //suffix to use color emoji
// Unicode Block: Specials
const UNICODE_REPLACEMENT_CHARACTER = '\u{FFFD}';  //character used for non-mappable characters
const UNICODE_NOT_A_CHARACTER_1 = '\u{FFFE}';  //character without representation
const UNICODE_NOT_A_CHARACTER_2 = '\u{FFFF}';  //character without representation

// Unicode Plane: Supplementary Multilingual Plane (U+10000 - U+1FFFF)
// Unicode Block: Miscellaneous Symbols and Pictographs
const UNICODE_LEFT_POINTING_MAGNIFYING_GLASS = '\u{1F50D}';
const UNICODE_RIGHT_POINTING_MAGNIFYING_GLASS = '\u{1F50E}';
const UNICODE_FLOPPY_DISK = '\u{1F4BE}';  //colored floppy disk
const UNICODE_BLACK_HARD_SHELL_FLOPPY_DISK = '\u{1F5AA}';  //black&white 3½" floppy disk
const UNICODE_WHITE_HARD_SHELL_FLOPPY_DISK = '\u{1F5AB}';  //black&white 3½" floppy disk
const UNICODE_SOFT_SHELL_FLOPPY_DISK = '\u{1F5AC}';  //black&white 5¼" floppy disk
const UNICODE_EMPTY_DOCUMENT = '\u{1F5CB}';
const UNICODE_CANCELLATION = '\u{1F5D9}';  //cross
const UNICODE_LIGHT_CHECK_MARK = '\u{1F5F8}';

// DefaultLinks is a textual part with a copy of example-links.txt at the end.
const DefaultLinks =
// {{{
`// For the syntax description, see help.html.

!title Example Favorites

!text
<a name="description"></a>
<h2>Description</h2>

<p>
<a href="favorites.html">favorites.html</a> is a single page that can be
configured to show <u>links</u> and <u>todo lists</u>, organized in
<u>sections</u>, <u>blocks</u> and <u>items</u>. This configuration can be
downloaded via a URL and/or edited in the browser's LocalStorage (see below).
<br>
This page can be set as home page in the browser's settings and as the Tab
start page via an add-on like <a
href="https://addons.mozilla.org/en-US/firefox/addon/new-tab-override/">New Tab
Override</a>.
</p>
!endtext

Section

!text
<p>
The configuration consists primarily of a list of <a
href="help.html#link-syntax">Link Definitions</a>.  The Links form an
hierarchical structure, indicated by the line's indentation:
<ul>
<li><dt>Section</dt>: The first indentation level is the Section. Sections are
    separated by horizontal lines.
<li><dt>Block</dt>: The second indentation level are the blocks within a
    Section. Each Block is a visual area that can be collapsed and expanded.
<li><dt>Item</dt>: The third indentation level are the Items that populate
    the Blocks.
<li><dt>SubItem</dt>: The fourth and higher indentation levels are SubItems
    that are displayed under their respective parent Items
</ul>
</p>
!endtext

    Block
        Item
            SubItem
                SubSubItem
                SubSubItem
                    ...
            SubItem
        Item
            SubItem

!text
<p>
Each link can be a hyperlink, have an icon and/or a checkbox.
</p>
!endtext

!text
<a name="usage"></a>
<h2>Usage</h2>

<p>
The standard usage is to open the page favorites.html (or possibly set it as
your home page). Upon first opening, it shows a default example page.  This
page can be edited by going to the Settings (gears (&#x2699;) icon) and just
edit and save the textual configuration. Optionally, this configuration can be
maintained in a separate text file and copy-pasted into the Settings.
<br>
Since GitHub provides for a way to serve HTML pages directly, this can be used
to open and use favorites.html directly from <a
href="https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html">GitHub</a>.
Save the target of this link to your home page and you're set.
</p>

<p>
See <a href="help.html#usage">Help</a> for more information on how to use a
separate URL to retrieve the configuration.
</p>

<p>
In addition to Links, the configuration also supports comments, different
web-search functions and other directives, see <a
href="help.html#line-syntax">Line Syntax</a> for further details.
</p>
!endtext

Examples

!text
<p>
These are some examples of the available features.
</p>
!endtext

    Search
        DuckDuckGo https://duckduckgo.com
        Google Maps https://maps.google.com
        Wikipedia https://www.wikipedia.org
        YouTube https://www.youtube.com
    Source
        GitHub favorite-links https://github.com/anne-gert/favorite-links
            Use favorites.html https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html
            Example Links override https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html&links-override=example-links.txt
            Help https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/help.html
        Firefox
            Home page settings icon=firefox target=manual about:preferences#home
            Plugins
                New Tab Override https://addons.mozilla.org/en-US/firefox/addon/new-tab-override/
    To Do
        Shopping
            [ ] Books
            [x] Presents
        At work
            [x] icon=firefox Install Firefox https://www.mozilla.org/firefox/download
            [ ] icon=github Start using *favorite-links* as **todo-list**
            []  icon=empty Write review
                & Goto Blog icon=none url=https://blog.example.com
        Poll
            [ ]:3 I like shapes
                [ ]:3 Square
                [ ]:3 Circle
                [ ]:3 Triangle
            [ ]:yesno Yes or No
    Socials
        Facebook https://www.facebook.com
            Instagram https://www.instagram.com/
            WhatsApp Web https://web.whatsapp.com/
        ---
        LinkedIn https://www.linkedin.com/

// Icon definitions
!icon maps.google.com        alt
!icon html-preview.github.io github
!icon firefox                https://www.mozilla.org/media/img/favicons/firefox/browser/favicon.ico
!icon github                 https://github.com

// Checkbox definitions
!checkbox 3 uncheck check mcheck
!checkbox yesno [_]U+2753 [yes]U+1F44D [no]U+1F44E !after

// Search button definitions
//      Identifier   | Label  | Tooltip | Icon | URL-Template
!search Duck Duck Go | Search |
!search Wikipedia
!search YouTube
!search Google Maps  | Maps
`;
// }}}

const KrulSvg_alt = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M16.5,.4C13.9,.7 11.5,2.2 9.5,3.9 7.9,5.4 6.1,7 5.8,9.3 5.5,10.2 6.6,11.1 6.6,11.5 4.7,12.7 2.9,13.9 1,14.9-0,15.6.5,17.4 1.8,17.1 3.2,16.5 4.5,15.6 5.9,14.8 7.2,14 8.5,13.2 9.8,12.3c.8,-0.4 1.6,.1 2.5,.1 1.2,.1-0.5,1-0.7,1.4-0.9,.9-2.2,2-2,3.4.1,1.5 1.7,2.3 3.1,2.2 1.2,0 2.4,-0.2 3.6,-0.5 1.5,-0.4.7,-2.8-0.7,-2.3-1.1,.1-2.6,.7-3.4,.2 1,-1.4 2.7,-2.3 3.2,-3.9.4,-1.1-0.4,-2.2-1.4,-2.5-0.5,-0.2-1.1,-0.3-0.3,-0.7C15.5,8.4 17.5,7 18.9,5 19.8,3.9 19.8,2.1 18.6,1.1 18.1,.6 17.3,.4 16.5,.4Zm.2,2.5c1.1,.3-0.4,1.6-0.8,2-1.8,1.9-4.1,3.2-6.2,4.7-0.7,.4-2.1,-0-1.2,-0.9C10.1,6.2 12.6,4.3 15.4,3.1c.4,-0.2.9,-0.3 1.3,-0.2z"/></svg>'
const KrulSvg = '<svg viewBox="0 0 25 25"xmlns="http://www.w3.org/2000/svg"><path d="M9.7,-0.6C8.1,-0.5 7,.8 6,1.8 4.8,3.2 3.6,4.6 3.2,6.3 2.7,7.6 3.7,8.9 4.1,9.7 2.5,11.2.9,12.7-0.7,14.3c-0.6,1.3 1.3,1.9 1.9,.7 1.6,-1.6 3.2,-3.1 4.8,-4.7 1.3,.2 3.4,1.3 2.1,2.8-1,2-2.1,3.9-2.9,5.9-0.7,1.6.8,3.5 2.5,3 1.8,-0.6 3.4,-1.7 5,-2.8C21.8,12.6 25.2,5.9 24,6.7 19.5,11.8 14.3,16.5 8.3,19.8c-1,.9-1.9,.2-1,-0.9 1,-2 2.1,-3.9 2.9,-5.9.5,-1.4-0.2,-2.9-1.5,-3.6-0.7,-0.4-1.7,-0.5-0.6,-1.2 1.5,-1.6 3,-3.1 4.2,-4.9.9,-1.4-0.1,-3.4-1.6,-3.9-0.3,-0.1-0.7,-0.2-1,-0.2zm.1,1.9c1.5,.1.9,1.7.1,2.3C8.5,5.2 7.1,6.7 5.5,8.2 4.2,7.3 5.4,5.7 6,4.7 7,3.4 8.1,2.1 9.5,1.3l.2,-0z"/></svg>';

// }}}

// Utility Functions {{{

// This function returns a reference to a console-like object with the
// following methods:
// - error
// - warn
// - important
// - log
// - debug
// - devlog
// Depending on the value of level, these methods log or do nothing:
// - level=='none': only error and warn
// - level=='important': important and above
// - level=='log': log and above
// - level=='debug': debug and above
// - level=='devlog': devlog and above
// - level=='all': all available functions
function CreateLogger(level = 'important') {
	let levels = { none: 0, important: 1, log: 2, debug: 3, devlog: 4, all: 9999 };
	let _level;
	function setLevel(level = 'all') {
		_level = levels[level];
		if (_level == null) {
			console.error('Unknown log level: ' + level);
			_level = levels.none;
		}
		return this;  //allow this function to be chained.
	}
	setLevel(level);

	// Log the first line in the given style, the rest is logged normally.
	function logColor(style, args) {
		if (style != null) {
			let format = [];
			let args2 = [];
			for (let i = 0; i < args.length; ++i) {
				let type = typeof args[i];
				if (type === 'object') {
					// Render as object, see https://developer.mozilla.org/en-US/docs/Web/API/console
					format.push('%o');
					args2.push(args[i]);
				} else {
					// Render as string with style
					format.push('%c%s');
					args2.push(style, args[i]);
				}
			}
			args2.unshift(format.join(' '));
			console.log.apply(console, args2);
		} else {
			console.log.apply(console, args);
		}
	}

	function Func(level, style) {
		function logger(...args) {
			if (level <= _level) logColor(style, args);
		}
		return logger;
	}
	let obj = {
		setLevel    : setLevel,
		all         : function() { return this.setLevel('all') },  //alias
		defineLevel : (name, level, style) => obj[name] = Func(level, style),
		error       : console.error,
		warn        : console.warn,
		important   : Func(1, 'color:cyan;font-weight:bold'),
		log         : Func(2, null),
		debug       : Func(3, 'color:#888888'),
		devlog      : Func(4, 'color:black;background-color:#008888'),
	};
	return obj;
}

// Constructor function to construct a Promise in a pending state with
// additional functions resolve(value) and reject(error) to settle it.
function PendingPromise()
{
	let resolve, reject;
	let result = new Promise((resolveFunc, rejectFunc) => {  //Promise in pending state
		// Expose callbacks to be called later
		resolve = resolveFunc;
		reject = rejectFunc;
	});
	result['resolve'] = resolve;
	result['reject'] = reject;
	return result;
}

// Unicode Support {{{

// Function to detect if a unicode character is supported by the specified font.
// - character: Character to test.
// - font: Font to test. Defaults to font as specified for the body.
// - recursion is for internal use.
// Return true if supported, false if not.
function characterIsSupported(character, font = null, recursion = false) {
	// This function is copied from https://stackoverflow.com/questions/1911000/detecting-individual-unicode-character-support-with-javascript

	// This function creates a referenceCanvas with the character U+FFFF,
	// which does not have a representation.
	// It then creates the testCanvas with the character to test.
	// The final test is to see if both canvases are the same (by testing
	// the contents of the BASE64 data: URL). If they are the same, the
	// test character cannot be represented either.

	if (font === null) font = getComputedStyle(document.body).fontFamily;

	const Debug = false;
	const Transparent = false;

	// Create the canvases
	let testCanvas = document.createElement('canvas');
	let referenceCanvas = document.createElement('canvas');
	testCanvas.width = referenceCanvas.width = testCanvas.height = referenceCanvas.height = 100;
	if (Debug) {
		testCanvas.style.backgroundColor = referenceCanvas.style.backgroundColor = 'magenta';
		testCanvas.style.margin = referenceCanvas.style.margin = '10px';
	}

	// Render the characters
	let testContext = testCanvas.getContext('2d');
	let referenceContext = referenceCanvas.getContext('2d');
	testContext.font = referenceContext.font = '100px ' + font;
	testContext.fillStyle = referenceContext.fillStyle = 'black';
	testContext.fillText(character, 0, 100);
	referenceContext.fillText(UNICODE_NOT_A_CHARACTER_2, 0, 100);

	// Firefox renders unsupported characters by placing their character
	// code inside the rectangle making each unsupported character look
	// different.  As a workaround, in Firefox, we hide the inside of the
	// character by placing a black rectangle on top of it.
	// The rectangle we use to hide the inside has an offset of 10px so it
	// can still see part of the character, reducing the risk of false
	// positives.  We check for Firefox and browers that behave similarly
	// by checking if U+FFFE is supported, since U+FFFE is, just like
	// U+FFFF, guaranteed not to be supported.
	if (!recursion && characterIsSupported(UNICODE_NOT_A_CHARACTER_1, font, true)) {
		let fillStyle = Transparent ? 'rgba(0, 0, 0, 0.6)' : 'black';
		testContext.fillStyle = referenceContext.fillStyle = fillStyle;
		testContext.fillRect(5, 5, 90, 90);
		referenceContext.fillRect(5, 5, 90, 90);
	}

	// Check if the canvases are identical
	let displayedSame = testCanvas.toDataURL() == referenceCanvas.toDataURL();

	// Output images at the end of the body for debugging
	if (Debug) {
		var div = document.createElement('div');
		document.body.appendChild(div);
		div.appendChild(document.createTextNode('Character U+' +
			character.charCodeAt(0).toString(16).toUpperCase() +
			', recursion=' + recursion));
		div.appendChild(referenceCanvas);
		div.appendChild(testCanvas);
		div.appendChild(document.createTextNode(displayedSame ? ' => Not supported' : ' => Unique'));
	}

	// Character is not supported if it looks the same as the reference
	return !displayedSame;
}

// Helper function.
// If character is supported by the control, set the property with the
// specified name. Use the control's fontFamily if available.
function setIfSupported(control, character, property = 'textContent') {
	let style = getComputedStyle(control);
	let font = style ? style.fontFamily : null;
	if (!font) font = null;
	let supported = characterIsSupported(character, font);
	if (supported) {
		control[property] = character;
	}
	return supported;
}

// If the control's font supports any of the (unicode) characters, set it in
// the textContent, otherwise use altText.
// This function may test multiple characters and uses the first one that is
// supported. Often Supplementary Multilingual Plane codepoints (U+10000 and
// above) are less supported than lower ones (Basic Multilangual Plan).
// Therefore, try to end with a lower codepoint.
function setUnicodeText(control, unicodeCharacter, /* more unicodeCharacters, */ altText) {
	//LogUnicode.log('setUnicodeText', arguments);
	for (let i = 1; i < arguments.length - 1; ++i) {
		let ch = arguments[i];
		if (setIfSupported(control, ch)) {
			LogUnicode.log('setUnicodeText: character #' + i + ' supported: \'' + ch + '\'');
			return;
		}
	}
	// If we get here, none matched. Now set the altText.
	altText = arguments[arguments.length - 1];  //the last argument
	control['textContent'] = altText;
}

// }}}

// General function to add/remove a CSS class for a specified widget.
// If the widget is not defined, do nothing.
// Operation:
// - op==true  : add class
// - op==false : remove class
// - op=='*'   : remove all classes that match the regex in className
function addClass(widget, className, op) {
	if (widget != null) {
		if (op === true) {
			widget.classList.add(className);
		} else if (op === false) {
			widget.classList.remove(className);
		} else if (op === '*') {
			let rm = [];
			let lst = widget.classList;
			for (let i = 0; i < lst.length; ++i) {
				let c = lst[i];
				if (c.match(className))
					rm.push(c);
			}
			if (rm.length > 0) lst.remove(rm);
		} else {
			LogEvents.error('Unknown value for operation: \'' + op +'\'');
		}
	}
}

class UserInputError extends Error {
	constructor(message, lineNumber) {
		// Update message
		let fileName = 'configuration';
		if (lineNumber != null) {
			message += ' on line ' + lineNumber;
		}

		// Construct object
		super(message, fileName, lineNumber);
		this.name = 'UserInputError';
	}
}

// Evaluate keyEvent:
// - ensure the the correct key is pressed
// - ensure the required modifier keys are true
// - ensure the non-required, non-optional modifier keys are false
// state is a string of the format 'r?o', where r represents the letters of the
// required modifier keys and o the ones that are optional. The ones not
// mentioned are forbidden.
// The used letters are:
// - 'a' : altKey
// - 'c' : ctrlKey
// - 'm' : metaKey
// - 's' : shiftKey
// Returns true if valid.
function isKey(keyEvent, state, key) {
	let ok = true;
	if (keyEvent.key.toUpperCase() == key.toUpperCase()) {
		let st = { a: false, c: false, m: false, s: false };  //null=optional, true=required, false=forbidden
		let v = true;
		for (let i = 0; i < state.length; ++i) {
			let c = state.charAt(i);
			if (c == '?') {
				v = null;  //go to optional part
				continue;
			}
			st[c] = v;  //expected state
		}
		// Check the state
		if (st.a != null) ok = ok && (st.a == keyEvent.altKey);
		if (st.c != null) ok = ok && (st.c == keyEvent.ctrlKey);
		if (st.m != null) ok = ok && (st.m == keyEvent.metaKey);
		if (st.s != null) ok = ok && (st.s == keyEvent.shiftKey);
	} else {
		ok = false;
	}
	LogEvents.log(`isKey(state='${state}',key='${key}'): Key='${keyEvent.key}' -> ${ok}`);
	return ok;
}

// }}}

// Links Data {{{

// Global object to hold Links and other data.
const Data = CreateData();

// Function to create the object to hold and maintain the Links data.
// This object uses LocalStorage if available.
// If getResolver is set, call that to get UrlResolvere object. Else,
// UrlResolver is used.
function CreateData(getResolver = () => UrlResolver) {
	const LSKey_Prefix = 'favlist_';

	let storage;
	if (HOOK_LocalStorage != null) {
		storage = HOOK_LocalStorage;
		HOOK_LocalStorage.onreset(reset);
	} else if (localStorage) {
		storage = localStorage;
	} else {
		// Dummy implementation of LocalStorage
		let data = {};
		storage = {
			getItem : key => data[key],
			setItem : (key, value) => data[key] = value,
			removeItem : key => delete data[key],
		};
	}

	// Clear all the cached values
	function reset() {
		displayedLinks = null;
		conflictState = false;
	}

	// Read value from Storage.
	// Return value or undefined in case of error or if it does not exist.
	function readStorage(key) {
		LogStorage.debug('Read storage key \'' + key + '\'');
		let v = storage.getItem(key);
		return (v != null) ? v : undefined;
	}

	// Store value in Storage.
	// If value is null, empty or whitespace, delete key from Storage.
	// Returns if value changed:
	// - 0: no change
	// - 1: presence changed
	// - 2: value changed and precence stayed the same
	function writeStorage(key, value) {
		let changed;
		let old = storage.getItem(key);
		if (value == null || value.toString().match(/^\s*$/)) {
			if (old == null) {
				LogStorage.debug('Storage key \'' + key + '\' already empty');
				changed = 0;
			} else {
				LogStorage.debug('Remove storage key \'' + key + '\'');
				storage.removeItem(key);
				changed = 1;
			}
		} else if (old !== value) {
			if (old == null) {
				LogStorage.debug('Add storage key \'' + key + '\'');
				changed = 1;
			} else {
				LogStorage.debug('Change storage key \'' + key + '\'');
				changed = 2;
			}
			storage.setItem(key, value);
		} else {
			LogStorage.debug('Storage key \'' + key + '\' already correct value');
			changed = 0;
		}
		return changed;
	}

	// Functions to construct Storage keys
	function getLinksLSKey() {
		return LSKey_Prefix + 'links_' + getResolver().getConfigLoadKey();
	}
	function getCleanLinksLSKey() {
		return LSKey_Prefix + 'clean-links_' + UrlResolver.getConfigLoadKey();
	}
	function getItemExpandedLSKey(itemPath) {
		return LSKey_Prefix + 'expanded_' + getResolver().getConfigLoadKey() + '_' + itemPath;
	}
	function getOptionsLSKey(loadOrSave, configName) {
		if (configName != null) {
			return LSKey_Prefix + loadOrSave + '_' + configName;
		} else {
			return LSKey_Prefix + loadOrSave + '_default';
		}
	}

	// Read/Write Links from Storage.
	// Returns null if not available.
	function readLocalLinks() {
		let key = getLinksLSKey();
		LogStorage.log('localLinks: Read from ' + key);
		let links = readStorage(key);
		if (links === undefined) links = null;
		return links;
	}
	function writeLocalLinks(links) {
		let key = getLinksLSKey();
		if (writeStorage(key, links) == 1) {
			// LocalLinks' presence changed.
			// This may have consequences for the order of the sources
			getResolver().resetSources();
		}
	}

	// Read/Write CleanLinks from Storage. CleanLinks are basically the
	// last downloaded version. This is used as the common ancestor for
	// determining if LocalLinks or newly DownloadedLinks have changed.
	// Returns null if not available.
	function readCleanLinks() {
		let key = getCleanLinksLSKey();
		let links = readStorage(key);
		if (links === undefined) links = null;
		return links;
	}
	function writeCleanLinks(links) {
		let key = getCleanLinksLSKey();
		writeStorage(key, links);
	}

	// Return true if LocalLinks is different from CleanLinks.
	function linksDirty() {
		let localLinks = readLocalLinks();
		let cleanLinks = readCleanLinks();
		if (localLinks != null && cleanLinks != null) {
			// Both Local and Clean are set
			return localLinks.trim() != cleanLinks.trim();
		} else {
			return false;
		}
	}

	// Get/Set ConflictState. This is not saved in Storage, but exists
	// only in memory. ConflictState s true if the current Links are in a
	// state where there is no automatic resolution of the 'current' value
	// and the user should take action..
	let conflictState = false;
	function getConflictState() {
		return conflictState;
	}
	function setConflictState(state) {
		conflictState = state;
	}

	// Get/Set DisplayedLinks. This is not saved in Storage, but exists
	// only in memory. DisplayLinks is the contents currently being
	// displayed. This is used to determine if the display should be
	// re-rendered
	let displayedLinks = null;
	function getDisplayedLinks() {
		return displayedLinks;
	}
	function setDisplayedLinks(value) {
		displayedLinks = value;
	}

	// Read/write expanded/collapsed status of this itemPath.
	function readItemExpanded(itemPath) {
		let key = getItemExpandedLSKey(itemPath);
		return readStorage(key);
	}
	function writeItemExpanded(itemPath, value) {
		let key = getItemExpandedLSKey(itemPath);
		writeStorage(key, value);
	}

	// Read/Write LoadOverrideOptions from Storage.
	// Return empty string if not set or empty.
	function readLoadOverrideOptions() {
		let configName = getResolver().getLoadOverrideConfigName();
		let key = getOptionsLSKey('load', configName);
		let s = readStorage(key);
		if (s === undefined || s.toString().match(/^\s*$/)) s = '';
		return s;
	}
	function writeLoadOverrideOptions(value) {
		let configName = getResolver().getLoadOverrideConfigName();
		let key = getOptionsLSKey('load', configName);
		if (writeStorage(key, value)) {
			// Value changed
			getResolver().resetLoadOverrideOptions();
		}
	}

	// Read/Write LoadOptions from Storage.
	// Return empty string if not set or empty.
	function readLoadOptions() {
		let configName = getResolver().getLoadConfigName();
		let key = getOptionsLSKey('load', configName);
		let s = readStorage(key);
		if (s === undefined || s.toString().match(/^\s*$/)) s = '';
		return s;
	}
	function writeLoadOptions(value) {
		let configName = getResolver().getLoadConfigName();
		let key = getOptionsLSKey('load', configName);
		if (writeStorage(key, value) != 0) {
			// Value changed
			getResolver().resetLoadOptions();
		}
	}

	// Read/Write SaveOptions from Storage.
	// Return empty string if not set or empty.
	function readSaveOptions() {
		let configName = getResolver().getSaveConfigName();
		let key = getOptionsLSKey('save', configName);
		let s = readStorage(key);
		if (s === undefined || s.toString().match(/^\s*$/)) s = '';
		return s;
	}
	function writeSaveOptions(value) {
		let configName = getResolver().getSaveConfigName();
		let key = getOptionsLSKey('save', configName);
		if (writeStorage(key, value)) {
			// Value changed
			getResolver().resetSaveOptions();
		}
	}

	return {
		// Functions to read/write Links
		readLocalLinks : readLocalLinks,
		writeLocalLinks : writeLocalLinks,
		readCleanLinks : readCleanLinks,
		writeCleanLinks : writeCleanLinks,
		linksDirty : linksDirty,
		getConflictState : getConflictState,
		setConflictState : setConflictState,
		getDisplayedLinks : getDisplayedLinks,
		setDisplayedLinks : setDisplayedLinks,

		// Functions to read/write expanded/collapsed state of Items
		readItemExpanded : readItemExpanded,
		writeItemExpanded : writeItemExpanded,

		// Function so read/write Load/Override/Save Options
		readLoadOverrideOptions : readLoadOverrideOptions,
		writeLoadOverrideOptions : writeLoadOverrideOptions,
		readLoadOptions : readLoadOptions,
		writeLoadOptions : writeLoadOptions,
		readSaveOptions : readSaveOptions,
		writeSaveOptions : writeSaveOptions,
	};
}

// }}}

// Resolving Links (UrlResolver) {{{

// Global object to hold the Load- and SaveOptions for the Links.
const UrlResolver = CreateUrlResolver();

// This function retrieves the parameters, parses them and determines which
// URLs to use for loading and saving.
// If getData is set, call that to get the persistent storage object. Else,
// Data is used.
// It returns a UrlResolver object with LoadOptions, SaveOptions and URLs.
function CreateUrlResolver(getData = () => Data) {
	LogUrlResolver.important('Resolving Links source...');

	// Parse links=, links-override= and save= and set internal variables
	// loadOptions, loadOverrideOptions and saveOptions.
	// Return an object to access these.

	// The normal order of sources is:
	// 1) links-override=
	// 2) LocalStorage
	// 3) links=
	//
	// If saveOptions is set, the order of LocalStorage and links= is
	// swapped, resulting in a modified table:
	// 1) links-override=
	// 2) links=
	// 3) LocalStorage

	let queryString;
	if (HOOK_QueryString != null) {
		queryString = HOOK_QueryString.get();
		HOOK_QueryString.onreset(reset);
	} else {
		queryString = location.search;
	}

	let loadOverrideArg, loadArg, saveArg;
	let loadOverrideConfigName, loadConfigName, saveConfigName;
	init();

	// The functions below denote the information they calculate and the
	// information they depend on.
	// The notation is with title-case to avoid naming specific fields or
	// methods.
	// When some information changes, check the From fields which other
	// fields should be reset.

	// Calculate: LoadOverrideArg, LoadArg, SaveArg, LoadOverrideConfigName, LoadConfigName, SaveConfigName
	// From: QueryString
	function init() {
		// Get arguments
		let params = new URLSearchParams(queryString);
		loadOverrideArg = params.get('links-override');
		loadArg = params.get('links');
		saveArg = params.get('save');
		//LogUrlResolver.log(params);

		// Resolve the config names
		const reConfigName = /^([^\s\/\\.]+)$/;  //config-name is non-emtpy and contains no space, '/', '\' or '.'

		loadOverrideConfigName = null;
		if (loadOverrideArg) {
			let m = loadOverrideArg.match(reConfigName);
			if (m) {
				// This is a config name
				loadOverrideConfigName = m[1];
				LogUrlResolver.debug('Found loadOverrideConfigName=' + loadOverrideConfigName);
				// Use the same config name for save unless already set
				if (saveArg == null) saveArg = loadOverrideConfigName;
			}
		}

		loadConfigName = null;
		if (loadArg) {
			let m = loadArg.match(reConfigName);
			if (m) {
				// This is a config name
				loadConfigName = m[1];
				LogUrlResolver.debug('Found loadConfigName=' + loadConfigName);
				// Use the same config name for save unless already set
				if (saveArg == null) saveArg = loadConfigName;
			}
		}

		saveConfigName = null;
		if (saveArg) {
			let m = saveArg.match(reConfigName);
			if (m) {
				// This is a config name
				saveConfigName = m[1];
				LogUrlResolver.debug('Found saveConfigName=' + saveConfigName);
			}
		}
	}

	// Reset object
	function reset() {
		LogUrlResolver.log('UrlResolver.reset()');
		queryString = HOOK_QueryString.get();

		_loadOverrideOptions = undefined;
		_loadOptions = undefined;
		_saveOptions = undefined;

		resetDownloadUrl();
		resetUploadUrl();
		resetSources();

		_saveOptionsDisabled = null;

		init();
	}

	let _usedLoadConfigName = undefined;
	let _loadName = undefined;

	// Methods to get the correct LocalStorage keys
	// From: UsedLoadConfigName, LoadName
	function getConfigLoadKey() {
		if (_usedLoadConfigName === undefined || _loadName === undefined) calcDownloadUrl();
		let key = [];
		if (_usedLoadConfigName != null) key.push(_usedLoadConfigName);
		if (_loadName != null) key.push(_loadName);
		return key.join('_');
	}

	// Calculate: LoadOverrideOptions
	// From: LoadOverrideConfigName, LoadOverrideArg
	let _loadOverrideOptions = undefined;
	function getLoadOverrideOptions() {
		if (_loadOverrideOptions === undefined) {
			if (loadOverrideConfigName != null) {
				// Read from config
				_loadOverrideOptions = getData().readLoadOverrideOptions();
			} else if (loadOverrideArg != null) {
				_loadOverrideOptions = loadOverrideArg;
			} else {
				_loadOverrideOptions = '';
			}
		}
		return _loadOverrideOptions;
	}
	function resetLoadOverrideOptions() {
		LogUrlResolver.log('Reset LoadOverrideOptions');
		_loadOverrideOptions = undefined;
		resetDownloadUrl();
	}

	// Calculate: LoadOptions
	// From: LoadConfigName, LoadArg
	let _loadOptions = undefined;
	function getLoadOptions() {
		if (_loadOptions === undefined) {
			if (loadConfigName != null) {
				// Read from config
				_loadOptions = getData().readLoadOptions();
			} else if (loadArg != null) {
				_loadOptions = loadArg;
			} else {
				_loadOptions = '';
			}
		}
		return _loadOptions;
	}
	function resetLoadOptions() {
		LogUrlResolver.log('Reset LoadOptions');
		_loadOptions = undefined;
		resetDownloadUrl();
	}

	// Calculate: SaveOptions
	// From: SaveConfigName, SaveArg
	let _saveOptions = undefined;
	function getSaveOptions() {
		if (_saveOptions === undefined) {
			if (saveConfigName != null) {
				// Read from config
				_saveOptions = getData().readSaveOptions();
			} else if (saveArg != null) {
				_saveOptions = saveArg;
			} else {
				_saveOptions = '';
			}
		}
		return _saveOptions;
	}
	function resetSaveOptions() {
		LogUrlResolver.log('Reset SaveOptions');
		_saveOptions = undefined;
		resetUploadUrl();
	}

	// Variables and access methods for the download URL
	let _downloadUrl = undefined;
	function getDownloadUrl() {
		if (_downloadUrl === undefined) calcDownloadUrl();
		return _downloadUrl;
	}
	function getLoadName() {
		if (_loadName === undefined) calcDownloadUrl();
		return _loadName;
	}
	let _downloadHeaders = undefined;
	function getDownloadHeaders() {
		if (_downloadHeaders === undefined) calcDownloadUrl();
		return _downloadHeaders;
	}
	let _downloadUrlPrivate = undefined;
	function isDownloadUrlPrivate() {
		if (_downloadUrlPrivate === undefined) calcDownloadUrl();
		return _downloadUrlPrivate;
	}

	// Reset the download URL variables, so that it gets recalculated when needed
	function resetDownloadUrl() {
		_downloadUrl = _loadName = _downloadHeaders = _usedLoadConfigName = _downloadUrlPrivate = undefined;
		resetSources();
		resetUploadUrl();
	}

	// Calculate: LoadName, UsedLoadConfigName, DownloadUrl, DownloadHeaders, DownloadUrlPrivate
	// From: LoadOverrideOptions, LoadOptions, SaveOptions, LoadOverrideConfigName, LoadConfigName, SaveConfigName
	function calcDownloadUrl() {
		// Note: The LinksLSKey depends on the _usedLoadConfigName and
		// on the _loadName, so these have to be calculated before
		// we can call getConfigLoadKey().

		// Derive _downloadUrl and _usedConfigName: The first of Load or
		// LoadOverride that is set.
		// Also adjust preliminary and fallback flags.
		let loadOverrideOptions = getLoadOverrideOptions();
		let loadOptions = getLoadOptions();
		let saveOptions = getSaveOptions();
		if (loadOverrideOptions) {
			if (saveOptions) {
				LogUrlResolver.log('Both loadOverrideOptions and saveOptions set');
				addStatus('Saveable');
			} else {
				LogUrlResolver.log('loadOverrideOptions without saveOptions set');
			}
			_downloadUrl = loadOverrideOptions;
			_usedLoadConfigName = loadOverrideConfigName;
			addStatus('Override');
		} else if (loadOptions) {
			if (saveOptions) {
				LogUrlResolver.log('Both loadOptions and saveOptions set');
				addStatus('Saveable');
			} else {
				LogUrlResolver.log('loadOptions without saveOptions set');
			}
			_downloadUrl = loadOptions;
			_usedLoadConfigName = loadConfigName;
		} else {
			LogUrlResolver.log('Both loadOverrideOptions and loadOptions not set');
			_downloadUrl = null;
			// No options set, but a ConfigName might be set. A ConfigName
			// is used to scope configurations in LocalStorage too.
			if (loadOverrideConfigName != null) {
				_usedLoadConfigName = loadOverrideConfigName;
			} else if (loadConfigName != null) {
				_usedLoadConfigName = loadConfigName;
			} else {
				_usedLoadConfigName = null;
			}
			addStatus('Local');
		}
		console.assert(_usedLoadConfigName !== undefined);
		LogUrlResolver.log('_usedLoadConfigName=' + _usedLoadConfigName);
		LogUrlResolver.log('_downloadUrl=' + _downloadUrl);

		// Derive loadToken and loadName
		_loadName = null;
		_downloadHeaders = [];
		_downloadUrlPrivate = false;
		if (_downloadUrl != null) {
			let parts = _downloadUrl.split('\\');
			//LogUrlResolver.log(parts);
			_downloadUrl = parts.shift();
			// The other parts are additional headers in either value or
			// name:value format
			let implicitNames = [ 'x-name', 'x-token' ];
			for (let i = 0; i < parts.length; ++i) {
				let name_value = parts[i].match(/^([^:]+)?:(.+)$/);
				if (name_value) {
					// This is a name:value header
					_downloadHeaders.push(name_value.slice(1,3));
					_downloadUrlPrivate = true;  //may contain secrets
				} else {
					// A header with an implicit name
					if (implicitNames.length > 0) {
						let name = implicitNames.shift();
						_downloadHeaders.push([ name, parts[i] ]);
						if (name == 'x-name') _loadName = parts[i];
						if (name == 'x-token') _downloadUrlPrivate = true;  //contains token
					} else {
						LogUrlResolver.error('Too many implicit headers in ' + _downloadUrl);
						// Just discard this header
					}
				}
			}
		}
		if (_loadName == null && _downloadUrl != null) {
			// No name found, now take the name from the URL
			_loadName = _downloadUrl.replace(/[?#].*$/, '').replace(/^[^\/]*\//, '');
		}
		console.assert(_loadName !== undefined);
		LogUrlResolver.log('_loadName=' + _loadName);
		//LogUrlResolver.log('HTTP headers=' + _downloadHeaders);

		// If _downloadUrl set, check special cases
		if (_downloadUrl != null) {
			let matchTargetUrl = _downloadUrl.match(/^\s*((https?:\/\/)?(.*?))\s*$/i);  //always matches
			//LogUrlResolver.log(matchTargetUrl);
			// Captured:
			// 1: url
			// 2: protocol
			// 3: domain + path + rest
			_downloadUrl = matchTargetUrl[1];  //trim whitespace
			if (!matchTargetUrl[2]) {
				// URL is relative, check if we need to adjust it
				let matchBaseUrl = window.location.href.match(/^([^\/]*?:\/\/)([^\/]*\bhtml-?preview\.github\.[^\/]*)([^?#]*)/i);
				//LogUrlResolver.log(matchBaseUrl);
				// Captured:
				// 1: protocol
				// 2: host ('html-preview.github.io')
				// 3: path without query string or fragment
				if (matchBaseUrl) {
					// The current URL is html-preview.github.io (or similar)
					// This should have a url= parameter that contains the real location
					let referredUrl = params.get('url');
					//LogUrlResolver.log(referredUrl);
					let matchReferredUrl = referredUrl.match(/^([^\/]*:\/\/)([^\/]*\bgithub\.[^\/]*)([^?#]*)/i);
					//LogUrlResolver.log(matchReferredUrl);
					// Captured:
					// 1: protocol
					// 2: host ('github.com')
					// 3: path without query string or fragment
					if (matchReferredUrl) {
						// The referred URL is on github.com

						// We are now in a situation where this page is hosted
						// on GitHub and links tries to point to a file on
						// there as well.
						// If you have a normal link to github.com, you get the
						// file inside the environment. If you use
						// raw.githubusercontent.com, you get the content of the
						// file, but with Content-Type=text/plain. When
						// html-preview.github.io is used, it uses
						// raw-githubcontent.com and serves it with
						// Content-Type=text/html.
						LogUrlResolver.log('Fix _downloadUrl relative URL for GitHub');
						// To make this relative link work, it should be grafted
						// onto githubusercontent.
						let matchReferredPath = matchReferredUrl[3].match(/(.*?)([^\/]*)$/);
						//LogUrlResolver.log(matchReferredPath);
						// Captured:
						// 1: directory
						// 2: filename (everything after last '/')
						_downloadUrl = matchReferredUrl[1] + 'raw.githubusercontent.com' + matchReferredPath[1] + matchTargetUrl[3];
					}
				}
			}
		}
	}

	// Variables and access methods for the sources
	let _preliminaryLinks = undefined;
	function getPreliminaryLinks() {
		if (_preliminaryLinks === undefined) calcSources();
		return _preliminaryLinks;
	}
	let _loadUrl = undefined;
	function getLoadUrl() {
		if (_loadUrl === undefined) calcSources();
		return _loadUrl;
	}
	let _fallbackLinks = undefined;
	function getFallbackLinks() {
		if (_fallbackLinks === undefined) calcSources();
		return _fallbackLinks;
	}

	// Reset the source variables, so that it gets recalculated when needed
	function resetSources() {
		_preliminaryLinks = _loadUrl = _fallbackLinks =  undefined;
	}

	// Calculate: PreliminaryLinks, LoadUrl, FallbackLinks
	// From: LoadOverrideOptions, LoadOptions, SaveOptions, UsediLoadConfigName, LoadName, Data.LocalLinks
	function calcSources() {
		// Get Links from LocalStorage (needs _usedLoadConfigName and _loadName)
		// Derive _preliminaryLinks and _fallbackLinks.
		let loadOverrideOptions = getLoadOverrideOptions();
		let loadOptions = getLoadOptions();
		let saveOptions = getSaveOptions();
		let localLinks = getData().readLocalLinks();

		// Derive _fallbackLinks: The final links text, unless download was successful
		_fallbackLinks = null;
		let fallbackLinksMsg = 'same as preliminaryLinks';

		// Derive _loadUrl: Set if links should be downloaded
		_loadUrl = _downloadUrl;
		let loadUrlMsg;
		let localBeforeDownload = false;
		if (loadOverrideOptions) {
			// Source selection: override - default  (do not consider LoadOptions or LocalStorage)
			// Note: The override might be te same as localLinks, in which case
			// preliminary-render would have helped.
			loadUrlMsg = 'loadOverrideOptions';
			_fallbackLinks = DefaultLinks;
			fallbackLinksMsg = 'default';
		} else if (loadOptions) {
			loadUrlMsg = 'loadOptions';
			if (saveOptions) {
				// Source selection: download - local - default  (LoadOptions before LocalStorage, because saveOptions is set)
			} else {
				// Source selection: local - download - default
				localBeforeDownload = true;
			}
		} else {
			// Source selection: local - default
			loadUrlMsg = 'none';
		}

		// Derive _preliminaryLinks: Generally LocalStorage if available,
		// because it might be equal to the downloaded Links in which case
		// rendering doesn't need to be restarted.
		let preliminaryLinksMsg;
		if (localLinks != null) {
			// localLinks present
			if (!loadOverrideOptions) {
				_preliminaryLinks = localLinks;
				preliminaryLinksMsg = 'LocalStorage (' + localLinks.length + ' characters)';
			} else {
				_preliminaryLinks = null;
				preliminaryLinksMsg = 'none (ignore LocalStorage)';
			}
			let localBeforeDownload = getLoadOptions() && !getSaveOptions();
			if (localBeforeDownload) {
				// The first option is LocalStorage and that is set.
				// No need to download
				_loadUrl = null;
				loadUrlMsg = 'none (use LocalStorage instead)';
				addStatus('Local');
			} else {
				addStatus('Links');
			}
		} else {
			// localLinks not present
			_preliminaryLinks = null;
			preliminaryLinksMsg = 'none (LocalStorage is empty)';
			_fallbackLinks = DefaultLinks;
			fallbackLinksMsg = 'default (LocalStorage is empty)';
		}
		LogUrlResolver.log('* preliminaryLinks: Use ' + preliminaryLinksMsg);
		LogUrlResolver.log('* loadUrl: Use ' + loadUrlMsg);
		LogUrlResolver.log('* fallbackLinks: Use ' + fallbackLinksMsg);
	}

	// Variables and access methods for the upload URL
	let _uploadUrl = undefined;
	function getUploadUrl() {
		if (_uploadUrl === undefined) calcUploadUrl();
		return _uploadUrl;
	}
	let _uploadMethod = undefined;
	function getUploadMethod() {
		if (_uploadMethod === undefined) calcUploadUrl();
		return _uploadMethod;
	}
	let _uploadHeaders = undefined;
	function getUploadHeaders() {
		if (_uploadHeaders === undefined) calcUploadUrl();
		return _uploadHeaders;
	}
	let _uploadUrlPrivate = undefined;
	function isUploadUrlPrivate() {
		if (_uploadUrlPrivate === undefined) calcUploadUrl();
		return _uploadUrlPrivate;
	}

	// Reset the upload URL variables, so that it gets recalculated when needed
	function resetUploadUrl() {
		_uploadUrl = _uploadMethod = _uploadHeaders = _uploadUrlPrivate = undefined;
	}
	function noUploadUrl() {
		_uploadUrl = '';
		_uploadMethod = '';
		_uploadHeaders = [];
		_uploadUrlPrivate = false;
	}

	// Calculate: UploadUrl, UploadMethod, UploadHeaders, UploadUrlPrivate
	// From: SaveOptions, SaveOptionsDisabled, DownloadUrl, LoadName
	function calcUploadUrl() {
		let saveOptions = getSaveOptions();
		if (saveOptions.match(/^\s*$/)) {
			LogUrlResolver.log('SaveOptions empty, no UploadUrl');
			noUploadUrl();
			return;
		}
		let uploadDisabled = getSaveOptionsDisabled();
		if (uploadDisabled) {
			LogUrlResolver.log('SaveOptions disabled, no UploadUrl');
			noUploadUrl();
			return;
		}
		let downloadUrl = getDownloadUrl();

		// Split into parts
		let parts = saveOptions.split('\\');

		// The first part should specify the method and the URL
		let saveUrl, special = false;
		let method_url = parts.shift();
		let method_url_parts = method_url.match(/^(put|post)(?::(.*))?$/i);
		if (method_url_parts) {
			// This is the standard syntax 'method:url' or 'method' ("Save to URL")
			_uploadMethod = method_url[1].toUpperCase();
			LogUrlResolver.debug('Explicit method for upload: ' + _uploadMethod);
			saveUrl = method_url[2];
		} else {
			// This is the special syntax 'url' ("Save to data.php")
			_uploadMethod = 'POST';
			LogUrlResolver.debug('Method for special upload: ' + _uploadMethod);
			special = true;
			saveUrl = method_url;
		}
		if (saveUrl) {
			// A URL has been specified
			LogUrlResolver.debug('Specified upload URL: ' + saveUrl);
		} else if (downloadUrl) {
			// No URL has been specified, use the URL for reading
			saveUrl = null;
			LogUrlResolver.debug('Upload URL is download URL: ' + downloadUrl);
		} else {
			// No URL to use
			LogUrlResolver.error('Cannot find read nor write URL');
			noUploadUrl();
			return;
		}

		// Derive absolute URL to save
		if (downloadUrl) {
			// downloadUrl may be relative to this script and saveUrl may be relative to downloadUrl
			let loadUrlAbs = new URL(downloadUrl, window.location).href;
			if (saveUrl === null) {
				_uploadUrl = loadUrlAbs;
			} else {
				_uploadUrl = new URL(saveUrl, loadUrlAbs).href;
			}
		} else {
			// No downloadUrl known, assume base of saveUrl is this script
			_uploadUrl = new URL(saveUrl, window.location).href;
		}

		// The other parts are additional headers
		_uploadHeaders = [];
		if (special) {
			// For the special syntax, the next part is the token
			if (parts.length > 0) {
				_uploadHeaders.push([ 'x-token', parts.shift() ]);
			}
			// Create the x-name header
			let loadName = getLoadName();
			if (loadName) {
				_uploadHeaders.push([ 'x-name', loadName ]);
			} else {
				LogUrlResolver.error('Special save cannot find loadName for x-name');
				noUploadUrl();
				return;
			}
		}
		// The other parts are additional headers in name:value format
		for (let i = 0; i < parts.length; ++i) {
			let name_value = parts[i].match(/([^:]+):(.+)/);
			if (name_value) {
				_uploadHeaders.push(name_value.slice(1,3));
			} else {
				LogUrlResolver.warn('Expected header: ' + parts[i]);
			}
		}

		_uploadUrlPrivate = _uploadHeaders.length > 0;  //may contain secrets

		//LogUrlResolver.log('Request headers: ', _uploadHeaders);
	}

	// Handling of SaveOptionsDisabled
	let _saveOptionsDisabled = null;  //set to string with the reason why saving is disabled
	function getSaveOptionsDisabled() {
		return _saveOptionsDisabled;
	}
	function setSaveOptionsDisabled(value) {
		if (_saveOptionsDisabled !== value) {
			LogUrlResolver.log('Change _saveOptionsDisabled to \'' + value + '\'');
			_saveOptionsDisabled = value;
			resetUploadUrl();
		}
	}

	// Return the object with the appropriate functions
	return {
		// Fields to manage LoadOptions
		getLoadConfigName : () => loadConfigName,
		getLoadOptions : getLoadOptions,
		resetLoadOptions : resetLoadOptions,

		// Fields to manage LoadOptions override
		getLoadOverrideConfigName : () => loadOverrideConfigName,
		getLoadOverrideOptions : getLoadOverrideOptions,
		resetLoadOverrideOptions : resetLoadOverrideOptions,

		// Fields to manage SaveOptions
		getSaveConfigName : () => saveConfigName,
		getSaveOptions : getSaveOptions,
		resetSaveOptions : resetSaveOptions,

		// Fields for downloading Links
		getDownloadHeaders : getDownloadHeaders,
		isDownloadUrlPrivate : isDownloadUrlPrivate,
		getLoadName : getLoadName,

		// Fields for uploading Links
		getUploadUrl : getUploadUrl,
		getUploadMethod : getUploadMethod,
		getUploadHeaders : getUploadHeaders,
		isUploadUrlPrivate : isUploadUrlPrivate,
		getUploadDisabled : getSaveOptionsDisabled,
		setUploadDisabled : setSaveOptionsDisabled,

		// Fields for Links sources
		getPreliminaryLinks : getPreliminaryLinks,
		getLoadUrl : getLoadUrl,
		getFallbackLinks : getFallbackLinks,
		getConfigLoadKey : getConfigLoadKey,
		resetSources : resetSources,
	};
}

// }}}

// Loading/Saving Links {{{

// This function uses the UrlResolver object to find the correct URL to download.
// It starts the download and returns a Promise.
// The Promise resolves normally if the download finished successfully. Otherwise
// the Promise is rejected.
// The global Links variable is not used or updated.
function downloadLinks() {
	let url = UrlResolver.getLoadUrl();
	if (url == null) return null;
	let headers = UrlResolver.getDownloadHeaders();

	LogUpDownload.important('Downloading URL \'' + url + '\'');
	if (HOOK_Ready != null) HOOK_Ready.start();

	function handleResponse(status, text, resolveFunc, rejectFunc) {
		//LogUpDownload.devlog('downloadLinks: Response received');
		if (status == 200) {
			// Success
			LogUpDownload.log('downloadLinks: Download successful');
			addStatus('Load OK');
			UrlResolver.setUploadDisabled(null);
			resolveFunc(text);
		} else {
			// Failed
			LogUpDownload.error('downloadLinks: Download failed');
			addStatus('Load ' + status);
			if (status == 404) {
				// If download failed because the file doesn
				// not exist, allow upload to create it.
				UrlResolver.setUploadDisabled(null);
				resolveFunc(null);  //triggers the file does not exist
			} else {
				// If the download failed because of another
				// reason, disable upload to not accidentally
				// overwrite the file.
				UrlResolver.setUploadDisabled('Saving disabled because downloading \'' + url + '\' failed');
				rejectFunc(false);
			}
		}
	};

	let downloadPromise;
	if (HOOK_Download != null) {
		downloadPromise = new PendingPromise();
		HOOK_Download.response(url, headers, null)
		.then(response => {
			handleResponse(response.status, response.text, downloadPromise.resolve, downloadPromise.reject);
			if (HOOK_Ready != null) HOOK_Ready.stop();
		})
		.catch(error => {
			downloadPromise.reject(error);
			if (HOOK_Ready != null) HOOK_Ready.stop();
		});
	} else if (window.fetch) {
		//LogUpDownload.devlog('Using fetch() to download');
		let hdrs = new Headers();
		for (let i = 0; i < headers.length; ++i) {
			hdrs.append(headers[i][0], headers[i][1]);
		}
		downloadPromise = new PendingPromise();
		let status;
		fetch(url, { headers : hdrs })
		.then(response => {
			//LogUpDownload.devlog('downloadLinks: Request sent');
			status = response.status;
			return response.text();
		})
		.then(text => {
			handleResponse(status, text, downloadPromise.resolve, downloadPromise.reject);
			if (HOOK_Ready != null) HOOK_Ready.stop();
		})
		.catch(error => {
			downloadPromise.reject(error);
			if (HOOK_Ready != null) HOOK_Ready.stop();
		});
	} else {
		//LogUpDownload.devlog('Using XMLHttpRequest to download');
		downloadPromise = new Promise((resolveFunc, rejectFunc) => {
			let xhr = new XMLHttpRequest();
			xhr.open('GET', url);
			for (let i = 0; i < headers.length; ++i) {
				xhr.setRequestHeader(headers[i][0], headers[i][1]);
			}
			xhr.onreadystatechange = function() {
				if (this.readyState == 4) {
					// Request has been handled
					handleResponse(this.status, xhr.responseText, resolveFunc, rejectFunc);
					if (HOOK_Ready != null) HOOK_Ready.stop();
				}
			};
			xhr.send();  //send the request
		});
	}

	return downloadPromise;
}

// Save links online by the method specified.
// If the value is null, empty or whitespace, save an empty string.
// CleanLinks and LinksDirty are also updated if save successful.
// Returns Promise of the upload or false if not saving.
// The Promise returns true if successful.
function uploadLinks(value) {
	let url = UrlResolver.getUploadUrl();
	if (!url) {
		LogUpDownload.warn('No UploadUrl, skip saving');
		return false;
	}
	let method = UrlResolver.getUploadMethod();
	if (!method) {
		LogUpDownload.warn('No UploadMethod, skip saving');
		return false;
	}
	let headers = UrlResolver.getUploadHeaders();

	// If value is null or whitespace, send an empty string
	if (value == null || value.match(/^\s*$/)) {
		value = '';
	}

	LogUpDownload.important('Uploading to URL ' + url + ': ' + method + ' ' + value.length + ' characters');
	if (HOOK_Ready != null) HOOK_Ready.start();

	function handleResponse(status, resolveFunc, rejectFunc) {
		//LogUpDownload.devlog('downloadLinks: Response received');
		if (status == 200) {
			// Success
			LogUpDownload.log('Uploaded links successfully');
			addStatus('Save OK');
			LogUpDownload.log('Update CleanLinks');
			Data.writeCleanLinks(value);  //assume upload & download are same content
			updateSettingsConflict(false);
			resolveFunc(true);
		} else {
			// Failed
			LogUpDownload.error('Failed to upload Links, better luck next time (' + status + ')');
			addStatus('Save ' + status);
			updateSettingsConflict(Data.linksDirty());
			resolveFunc(false);  //do not see this as a fail
		}
	};

	let uploadPromise;
	if (HOOK_Upload != null) {
		uploadPromise = new PendingPromise();
		HOOK_Upload.response(url, headers, value)
		.then(response => {
			handleResponse(response.status, uploadPromise.resolve, uploadPromise.reject);
			if (HOOK_Ready != null) HOOK_Ready.stop();
		})
		.catch(error => {
			downloadPromise.reject(error);
			if (HOOK_Ready != null) HOOK_Ready.stop();
		});
	} else {
		uploadPromise = new Promise((resolveFunc, rejectFunc) => {
			let xhr = new XMLHttpRequest();
			xhr.open(method, url);
			for (let i = 0; i < headers.length; ++i) {
				xhr.setRequestHeader(headers[i][0], headers[i][1]);
			}
			xhr.onreadystatechange = function() {
				if (this.readyState == 4) {
					// Request has been handled
					handleResponse(this.status, resolveFunc, rejectFunc);
					if (HOOK_Ready != null) HOOK_Ready.stop();
				}
			};
			xhr.send(value);  //send the request
		});
	}

	return uploadPromise;
}

// List of pending upload callbacks.
var PendingUpload = CreatePending('PendingUpload', 3, true);

// Create object to handle pending actions.
// - name [string]: Name of the object for debugging
// - timeout [seconds]: Time after which the action should be executed.
// - onlyLast [bool]: If true, only the last action is maintaind.
// The action is done after timeout. If the window.onunload is called before
// the timeout, the action is also executed.
function CreatePending(name, timeout, onlyLast) {
	let actions = [];
	let timer = null;
	let onunload = false;
	let has_ready_lock = false;

	function clearTimer() {
		if (timer) {
			window.clearTimeout(timer);
			timer = null;
		}
	}

	function clearActions() {
		actions.length = 0;
	}

	function doActions() {
		LogUpDownloadDefer.log(name + ': Execute actions');
		for (let i = 0; i < actions.length; ++i) actions[i]();
		clearActions();
		if (has_ready_lock) {
			HOOK_Ready.stop();
			has_ready_lock = false;
		}
	}

	// Add new action
	function add(callback) {
		if (HOOK_Ready != null && !has_ready_lock) {
			HOOK_Ready.start();
			has_ready_lock = true;
		}
		// (Re)set timer
		if (timer) window.clearTimeout(timer);
		timer = window.setTimeout(doActions, timeout*1000);
		// Update actions
		if (onlyLast) {
			LogUpDownloadDefer.log(name + ': Set pending action (in ' + timeout + 's)');
			actions.length = 0;
		} else {
			LogUpDownloadDefer.log(name + ': Add pending action (in ' + timeout + 's)');
		}
		actions.push(callback);
		// Set unload event
		if (!onunload) {
			window.addEventListener('beforeunload', onBeforeUnload);
			onunload = true;
		}
	}

	function onBeforeUnload(event) {
		// I don't think onbeforeunload is allowed to perform blocking
		// actions like uploading. Also, it doesn't seem to be allowed
		// to await Promises.
		// I leave this code for now in case a solution is found.
		// Maybe https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker
		doActions();
		dispose();
	}

	// Function to release resources
	function dispose() {
		clearTimer();
		clearActions();
		if (onunload) {
			window.removeEventListener('beforeunload', onBeforeUnload);
			onunload = false;
		}
		if (has_ready_lock) {
			HOOK_Ready.stop();
			has_ready_lock = false;
		}
	}

	return {
		add        : add,
		getTimeout : () => timeout,
		setTimeout : value => timeout = value,
		dispose    : dispose,
	};
}

// }}}

// Parsing Links {{{

// Parse the string in links and returns object with the following fields:
// - pageTitle: Specified title
// - pageTheme: Specified color theme
// - fontSize: Specified font-size (may be relative, but that doesn't work very well)
// - blocksCollapsedInitially: If blocks are initially collapsed by default
// - blocksCollapsedAlwaysInitial: If initial is always used or if local value is used
// - searchButtonDefs: Specified search button declarations
// - rootLinks: Array of Link objects that have no parents (i.e. are roots)
// - _iconDefs: Specified icondef declarations
// - _checkboxDefs: Specified checkbox declarations
// - styleBlocks: Array of !style...!endstyle blocks
// - scriptBlocks: Array of !script...!endscript blocks
// And member functions:
// - resolveIconDefs(icon_url)
// - resolveCheckboxDefs(name, lineNum)
function parseLinks(links) {
	LogParse.important('Parsing Links...');

	// Parse the input lines and construct a list of objects
	let allLinks = [];  //specified Link objects
	let parsed = {
		pageTitle                    : null,
		pageTheme                    : null,
		fontSize                     : null,
		blocksCollapsedInitially     : false,
		blocksCollapsedAlwaysInitial : false,
		autoUploadDelay              : null,
		searchButtonDefs             : [],
		rootLinks                    : [],
		_iconDefs                    : {
			// Set them here, so they always exist, but can be overridden too
			'refloop'   : IconRefLoopDefault,
			'undefined' : IconUndefinedDefault,
		},
		_checkboxDefs                : {},
		styleBlocks                  : [],
		scriptBlocks                 : [],
		noEdit                       : false,

		// Member functions

		// Take icon_url and perform the icondef replacements.
		// Returns the resolved value or the original value if no icondefs matched.
		resolveIconDefs(icon_url) {
			let retval = icon_url;
			let seen = {};  //to break cycles
			let refloop = 1;
			seen[icon_url] = 1;
			let override = this._iconDefs[icon_url];
			while (override !== undefined) {
				LogIcon.debug('Replace icon=' + retval + ' by IconDefs \'' + override + '\'');
				if (!seen[override]) {
					// Go to the next in the reference-chain
					retval = override;
					seen[override] = 1;
					override = this._iconDefs[override];
				} else if (refloop == 1) {
					// Got in a reference-loop for the first time
					override = 'refloop';  //does exist
					++refloop;
				} else {
					// Got in a reference-loop again, give up
					retval = IconRefLoopDefault;
					break;
				}
			}
			LogIcon.log('Icon=' + icon_url + ' -> use icon \'' + retval + '\'');
			return retval;
		},

		// Look up the CheckboxDef name and lineNum to find the correct definition
		resolveCheckboxDefs(name, lineNum) {
			let defs = this._checkboxDefs[name];
			// If not found, try (re-)definition of 'default'
			if (defs == undefined && name != 'default') {
				defs = this._checkboxDefs['default'];
			}
			let def = null;
			if (defs != null && defs.length > 0) {
				if (defs.length > 1) {
					// Search for most recent definition before lineNum
					//LogParse.devlog('Find lineNum=' + lineNum + ' in: ', defs);
					def = defs.findLast(d => d.lineNum < lineNum);
					//LogParse.devlog('Found: ', def);
				}
				// If multiple definitions, but all after lineNum, assume this is meant
				// as re-definitions and take the final one.
				// If there is a single definition, take that, even if it is defined later.
				if (def == null) {
					def = defs[defs.length-1];
				}
			}
			LogParse.debug('Resolve checkbox reference from line ' + lineNum + ' to ', def);
			return def;
		}
	};
	let textBlock = null;  //used for literal !text ... !endtext blocks
	let styleBlock = null;  //used for literal !style ... !endstyle blocks
	let scriptBlock = null;  //used for literal !script ... !endscript blocks
	let lastCheckboxType = 'default';  //name of last !checkbox definition
	let openIndentLevels = [];  //indentation level (number of spaces) for each open level
	let maxLevel = null;  //keep track of the maximum level
	let lines = links.split(/\r?\n\r?/);  //lines with Link specifications
	for (let i = 0; i < lines.length; ++i) {
		let line = lines[i];
		//LogParse.log('Line=\'' + line + '\'');
		let m;  //for regex matches

		// If we're in a !text block, add this line to the block
		if (textBlock != null) {
			// Check if it is the end of a literal block
			m = line.match(/^\s*!endtext\s*$/i);
			if (m) {
				// It is the end, save the object and reset textBlock.
				allLinks.push(textBlock);  //all items go here
				textBlock = null;  //reset
				continue;
			}
			// Otherwise add this line too
			textBlock.lines.push(line);
			continue;
		}

		// If we're in a !style block, add this line to the block
		if (styleBlock != null) {
			// Check if it is the end of a literal block
			m = line.match(/^\s*!endstyle\s*$/i);
			if (m) {
				// It is the end, save the object and reset styleBlock.
				LogParse.log('Add !style block (' + styleBlock.lines.length + ' lines)');
				parsed.styleBlocks.push(styleBlock);
				styleBlock = null;  //reset
				continue;
			}
			// Otherwise add this line too
			styleBlock.lines.push(line);
			continue;
		}

		// If we're in a !script block, add this line to the block
		if (scriptBlock != null) {
			// Check if it is the end of a literal block
			m = line.match(/^\s*!endscript\s*$/i);
			if (m) {
				// It is the end, save the object and reset scriptBlock.
				LogParse.log('Add !script block (' + scriptBlock.lines.length + ' lines)');
				parsed.scriptBlocks.push(scriptBlock);
				scriptBlock = null;  //reset
				continue;
			}
			// Otherwise add this line too
			scriptBlock.lines.push(line);
			continue;
		}

		// Remove vim folding markers at the end of lines
		line = line.replace(/\s*(?:{{{|}}})\s*$/, '');

		// Skip empty lines
		if (line.match(/^\s*(?:\/\/|#|;|$)/))
			continue;

		// Check if it is a title definition
		m = line.match(/^\s*!title\s+(.+?)\s*$/i);
		if (m) {
			// This is an title
			parsed.pageTitle = m[1];  //save string
			continue;
		}

		// Check if it is a theme definition
		m = line.match(/^\s*!theme\s+(.+?)\s*$/i);
		if (m) {
			// This is a theme
			parsed.pageTheme = m[1];  //save string
			continue;
		}

		// Check if it is a font-size definition
		m = line.match(/^\s*!size\s+(.+?)\s*$/i);
		if (m) {
			// This is a size
			parsed.fontSize = m[1];  //save string
			continue;
		}

		// Check if it is a blocks-closed definition
		m = line.match(/^\s*!collapsed\s+(always|never|yes|no)\s*$/i);
		if (m) {
			// This is a blocks-closed definition
			let v = m[1].toLowerCase();
			parsed.blocksCollapsedInitially = (v == 'always' || v == 'yes');
			parsed.blocksCollapsedAlwaysInitial = (v == 'always' || v == 'never');
			continue;
		}

		// Check if it is a upload-delay definition
		m = line.match(/^\s*!auto-upload-delay\s+(.+?)\s*$/i);
		if (m) {
			// This is a delay time
			parsed.autoUploadDelay = 1*m[1];  //save value
			continue;
		}

		// Check if it is a no-edit definition
		m = line.match(/^\s*!no-edit\s*$/i);
		if (m) {
			// This is a no-edit flag
			parsed.noEdit = true;  //save flag
			continue;
		}

		// Check if it is an icon definition (also support old syntax
		// with !icondef.
		m = line.match(/^\s*!icon(?:def)?\s+(\S+)(?:\s+|\s*=\s*)(\S+)\s*$/i);
		if (m) {
			// This is an icon definition
			parsed._iconDefs[m[1]] = m[2];  //save mapping
			continue;
		}

		// Check if it is a checkbox definition
		m = line.match(/^\s*!checkbox\s+(\S+)(?:\s+(.+?))?\s*$/i);
		if (m) {
			// This is a checkbox definition
			let name = m[1], args = m[2];
			let def = {
				name    : name,
				lineNum : i+1,
				options : null,
				first   : null,
				place   : null,
				// Intermediate fields
				_args   : args,
			};
			if (args != null && args.match(/(?:^|\s)!debug(?:\s|$)/i)) {
				// !debug pragma is given
				let debugBlock = {  //special type of Link object
					lineNum  : i+1,  //start of this block
					type     : 'debug',
					level    : null,  //adjusted later
					lines    : [ 'Line ' + (i+1) + ': ' + line.replace(/^\s*/, '') ],
					toString : function() { return '{ !debug, #Lines=' + this.lines.length + ' }' },
				};
				allLinks.push(debugBlock);
				def._debug = debugBlock;
			}
			//LogParse.devlog('!checkbox found ', def);
			if (parsed._checkboxDefs[name] == null) {
				parsed._checkboxDefs[name] = [ def ];
			} else {
				parsed._checkboxDefs[name].push(def);
			}
			lastCheckboxType = name;
			continue;
		}

		// Check if it is a search button definition
		m = line.match(/^\s*!search\s+(.+?)\s*$/i);
		if (m) {
			// This is a search button definition
			let def = m[1].split(/\s*\|\s*/);  //split fields on '|', allowing whitespace
			parsed.searchButtonDefs.push(def);  //save button def
			continue;
		}

		// Check if it is the start of a literal !text block
		m = line.match(/^\s*!text\s*$/i);
		if (m) {
			// Mark the start of the block
			textBlock = {  //special type of Link object
				lineNum  : i+1,  //start of this block
				type     : 'text',
				level    : null,  //adjusted later
				lines    : [],
				toString : function() { return '{ !text, #Lines=' + this.lines.length + ' }' },
			};
			continue;
		}

		// Check if it is the start of a literal !style block
		m = line.match(/^\s*!style\s*$/i);
		if (m) {
			// Mark the start of the block
			styleBlock = {
				lineNum  : i+1,  //start of this block
				lines    : [],
				toString : function() { return '{ !style, #Lines=' + this.lines.length + ' }' },
			};
			continue;
		}

		// Check if it is the start of a literal !script block
		m = line.match(/^\s*!script\s*$/i);
		if (m) {
			// Mark the start of the block
			scriptBlock = {
				lineNum  : i+1,  //start of this block
				lines    : [],
				toString : function() { return '{ !script, #Lines=' + this.lines.length + ' }' },
			};
			continue;
		}

		// Take out indentation
		let indent = 0;
		m = line.match(/^(\s+)(.*)$/);
		if (m) {
			indent = m[1].replaceAll('\t', '        ').length;
			line = m[2];  //the rest
		}
		// Take out continucation: & ...
		let cont = false;
		m = line.match(/^&\s*(.*)$/);
		if (m) {
			cont = true;
			line = m[1];  //the rest
		}
		// Take out Icon: /icon=non-whitespace/
		let icon = null;
		m = line.match(/^(.*)(?:\s|^)icon=(\S*)(.*)$/i);
		if (m) {
			icon = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out Check: start with '[]', '[value]' or '[value]:checkbox-type'.
		let checkType = null, checkValue = null;
		m = line.match(/^(\s*)(?:[-*]\s*)?(?:\[(\S+|\s+)\]|(\[\]))(?::(\S*))?(.*)$/);
		// The above regex matches the following:
		// - Capture 1: Initial whitespace (indentation)
		// - Capture 2: The checkbox value (either non-space string or only-space string)
		// - Capture 3: The empty []
		// - Capture 4: The checkbox type
		// - Capture 5: The rest of the line
		if (m) {
			if (m[2]) checkValue = m[2];  //value is set
			if (m[3]) checkValue = null;  //value is empty
			checkType = m[4];
			if (checkType === undefined) {
				checkType = 'default';
				LogParse.debug('Line ' + (i+1) + ': Checkbox with no type -> \'' + checkType + '\'');
			} else if (checkType === '') {
				checkType = lastCheckboxType;
				LogParse.debug('Line ' + (i+1) + ': Checkbox with empty type -> \'' + checkType + '\'');
			} else {
				LogParse.debug('Line ' + (i+1) + ': Checkbox with type \'' + checkType + '\'');
			}
			line = m[1] + m[5];  //the rest
		}
		// Take out Target: /target=non-whitespace/
		let target = null;
		m = line.match(/^(.*)(?:\s|^)target=(\S*)(.*)$/i);
		if (m) {
			target = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out CSS class name: /css=non-whitespace/
		let cssName = null;
		m = line.match(/^(.*)(?:\s|^)css=(\S*)(.*)$/i);
		if (m) {
			cssName = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out URL: /url=non-whitespace/ or last /schema:non-whitespace/
		let url = null;
		m = line.match(/^(.*)(?:\s|^)url=(\S*)(.*)$/i);
		if (!m) m = line.match(/^(.*)(?:\s|^)([-+a-zA-Z]{2,}:\S+)(.*)$/);
		if (m) {
			url = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out Name: what remains without leading&trailing whitespae
		let name = line.trim();

		// Handle special items
		if (name.match(/^---+$/)) {  //name with 3 or more '-'
			// This is a separator
			name = '---';  //standardize to 3 '-'
		}

		// Determine level of this object
		let level;
		if (cont) {
			// This link is a continuation, ignore the indentation
			level = null;
		} else {
			// Find level with indentation strictly less
			for (level = openIndentLevels.length - 1; level >= 0 && openIndentLevels[level] >= indent; --level) {}
			// We found the parent's level (-1 if no parent), add 1 for this level
			++level;
			if (maxLevel == null || level > maxLevel) maxLevel = level;
			// Remove all open levels after that
			openIndentLevels.length = level;
			// Add this link as open parent
			openIndentLevels.push(indent);
		}

		// Create the Link object
		let link = {
			lineNum    : i+1,
			type       : 'link',
			level      : level,
			name       : name,
			url        : url,
			icon       : icon,
			checkType  : checkType,
			checkValue : checkValue,
			target     : target,
			cssName    : cssName,
			cont       : [],
			subs       : [],
			toString   : function() { return '{ Name=\'' + this.name + '\', URL=' + this.url + ', Icon=' + this.icon + ', check=' + check + ', #SubItems=' + this.subs.length + ' }' },
		};
		//LogParse.log('Indentation=' + indent + ', Link=' + link);

		// Add this Link
		if (cont) {
			// This link is a continuation, add it to the previous link
			var previous = allLinks[allLinks.length - 1];
			previous.cont.push(link);
		} else {
			allLinks.push(link);
		}
	}

	// Search from position to the front in allLinks and find the first
	// link item that has a level set.
	// Returns item or null if not found.
	let findLinkBefore = function(position) {
		for (let i = position - 1; i >= 0; --i) {
			let item = allLinks[i];
			if (item.level != null) return item;
		}
		return null;
	}

	// Search from position to the end in allLinks and find the first
	// link item that has a level set.
	// Returns item or null if not found.
	let findLinkAfter = function(position) {
		for (let i = position + 1; i < allLinks.length; ++i) {
			let item = allLinks[i];
			if (item.level != null) return item;
		}
		return null;
	}

	// If maxLevel==0, all items are at root level. It was probably
	// intended to have all items in a block. To fix this, add a
	// dummy Section (level 0) and Block (level 1).
	// Similarly with maxLevel==0. Now all items are separate blocks.
	// Fix this by adding a dummy Section (level 0).
	if (maxLevel < 2) {
		// These are the special cases
		let firstLink = findLinkAfter(-1);
		if (firstLink == null) {
			// There are no links at all.
			// In this case, there is nothing to adjust
		} else {
			// Add 1 or 2 levels in the front of allLinks
			// In either case, we need to add a Section
			let section = {
				lineNum    : 0,
				type       : 'link',
				level      : 0,
				name       : '_',  //this makes this section not render
				url        : null,
				icon       : null,
				checkType  : null,
				checkValue : null,
				target     : null,
				cssName    : null,
				cont       : [],
				subs       : [],
				toString   : function() { return '{ Dummy Section }' },
			};
			if (maxLevel == 0) {
				// Only in this case, we need to add a Block level too
				let block = {
					lineNum    : 0,
					type       : 'link',
					level      : 1,
					name       : firstLink.name,  //give it the same name as the first link
					url        : null,
					icon       : null,
					checkType  : null,
					checkValue : null,
					target     : null,
					cssName    : null,
					cont       : [],
					subs       : [],
					toString   : function() { return '{ Dummy Block }' },
				};
				LogParse.log('Add dummy Block');
				allLinks.unshift(block);
			}
			LogParse.log('Add dummy Section');
			allLinks.unshift(section);
			// Increase level of all existing items
			//  maxLevel | num items added | start original items | increase
			// ----------|-----------------|----------------------|----------
			//         0 |               2 |                    2 |        2
			//         1 |               1 |                    1 |        1
			//        >2 |               0 |                  n/a |      n/a
			let x = 2 - maxLevel;
			for (let i = x; i < allLinks.length; ++i) {
				let level = allLinks[i].level;
				if (level != null) {
					allLinks[i].level = level + x;
				}
			}
		}
	}
	//LogParse.log(allLinks);

	// Go through allLinks and adjust the level if needed
	for (let i = 0; i < allLinks.length; ++i) {
		let item = allLinks[i];
		if (item.type == 'text' || item.type == 'debug') {
			// This is a text block
			// Make its level the lowest of the item before and the item after
			let before = findLinkBefore(i);
			let after = findLinkAfter(i);
			if (before != null) {
				if (after != null) {
					// There is a line before and a line after
					if (before.level < after.level) {
						// Indent in -> regard this item as 1 below before
						item.level = before.level + 1;
					} else if (before.level == after.level) {
						// Same indent -> regard this item as that level too
						item.level = before.level;
					} else {
						// Indent out -> regard this item as 1 deeper than after
						item.level = after.level + 1;
					}
				} else {
					// There is a line before, but no line after
					// This is at the end of the page -> root level
					item.level = 0;
				}
			} else {
				// There is a line after, but no line before
				// This is at the start of the page -> root level
				item.level = 0;
			}
		} else if (item.type == 'link' && item.name == '---') {
			// This is a separator.
			// A separator is only useful at block level or lower
			if (item.level <= 1) {
				item.level = null;
			}
		}
	}

	// Go through allLinks and create a parent-child structure
	let openParents = [];  //currently open parents: 0 is root, 1 its child, etc
	for (let i = 0; i < allLinks.length; ++i) {
		let item = allLinks[i];
		if (item.level == null) {
			// This has no level and should not be put in the parent-child structure
		} else {
			if (item.level > 0) {
				// This is a regular item, find a parent
				let parent = openParents[item.level - 1];
				parent.subs.push(item);
			} else {
				// This item does not have a parent, it's a root
				parsed.rootLinks.push(item);
			}

			// If this item can be a parent too, replace from this level and below
			if ('subs' in item) {
				openParents.length = item.level;
				openParents.push(item);
			}
		}
	}

	// Complete CheckboxDefs
	function iterateCheckboxDefs(func) {
		for (name in parsed._checkboxDefs) {
			let defs = parsed._checkboxDefs[name];
			for (let i = 0; i < defs.length; ++i) {
				//LogParse.devlog('Interate Checkbox \'' + name + '[' + i + ']\'');
				func(defs[i]);
			}
		}
	}
	// Resolve individual options and pragmas (sets _options, place)
	iterateCheckboxDefs(def => {
		// Parse the arguments
		let args = (def._args != null) ? def._args.split(/\s+/) : [];  //split on whitespace
		let opts = [];
		for (let i = 0; i < args.length; ++i) {
			let arg = args[i];
			//LogParse.devlog('!checkbox arg: ' + arg);
			if (parsed._checkboxDefs[arg] != null) {
				// Reference
				opts.push(arg);
				continue;
			}

			let mPragma = arg.match(/^!(?:(\w+)=)?(.+)$/);
			if (mPragma) {
				// Possible Pragma
				let name = mPragma[1];
				let val = mPragma[2];
				let reFront = /^(?:front|before)$/i;  //front, before
				let reBack = /^(?:back|after)$/i;  //back, after
				if (name != null) {
					// It is a !name=value pragma
					LogParse.log(`Checkbox '${def.name}' pragma '${arg}' matches !'${name}'='${val}'`);
					name = name.toLowerCase();
					if (name == 'place') {
						if (val.match(reBack)) {
							def.place = 'B';
							continue;
						} else if (val.match(reFront)) {
							def.place = 'F';
							continue;
						}
					}
				} else {
					// It is a !value pragma
					LogParse.log(`Checkbox '${def.name}' pragma '${arg}' matches !'${val}'`);
					if (val.match(reBack)) {
						def.place = 'B';
						continue;
					} else if (val.match(reFront)) {
						def.place = 'F';
						continue;
					} else if (val == 'debug') {
						// already handled
						continue;
					}
				}
				LogParse.debug('\'' + arg + '\' looked like a pragma, but it was not');
			}

			let id, token, val;
			let mOpt = arg.match(/^(?:(\w+)=)?(?:\[([^\]]+)\])?(.+)$/);
			if (mOpt) {
				// Option
				id = mOpt[1];  //undefined if not specified
				token = mOpt[2];  //undefined if not specified
				val = mOpt[3];
				LogParse.log(`Checkbox '${def.name}' option '${arg}' matches '${id}=[${token}]${val}'`);
			}
			let orgId = id, orgToken = token, orgVal = val;

			if (val == null) {
				// Invalid
				LogParse.error(`Checkbox '${def.name}' invalid checkbox argument '${arg}'`);
				val = CheckboxError;
			}

			// Check icondef
			let icondef = parsed.resolveIconDefs(val);
			if (icondef == val) icondef = null;
			// Check special values
			let lval = val.toLowerCase();
			if (lval == '_' || lval == 'empty') {
				if (token == null) token = ' ';
				if (id == null) id = lval;
				val = 'empty';  //a valid icon
			} else if (lval == 'uncheck') {
				if (token == null) token = ' ';
				if (id == null) id = lval;
				val = UNICODE_BALLOT_BOX;
			} else if (lval == 'check') {
				if (id == null) id = lval;
				val = UNICODE_BALLOT_BOX_WITH_CHECK;
			} else if (lval == 'cross') {
				if (id == null) id = lval;
				val = UNICODE_BALLOT_BOX_WITH_CROSS;
			} else if (lval == 'mcheck') {
				if (id == null) id = lval;
				val = UNICODE_WHITE_SQUARE_CONTAINING_BLACK_SMALL_SQUARE;
			} else if (lval == 'krul') {
				if (token == null) token = 'g';
				if (id == null) id = lval;
				val = 'krul';  //a valid icon
			}
			// Set id and token if not yet set
			// Complete option is <id>=[<token>]<value> with <id> and <token> optional.
			// Derive them as follows:
			// 1) <value>          -> <token> is equal to cleaned <value>,
			//                        <id> is cleaned <token> or empty (compare rule 3)
			// 2) <id>=<value>     -> <token> is equal to <id>
			// 3) [<token>]<value> -> <id> is cleaned <token> or <value> or empty
			if (id == null && token == null) {  //rule 1
				token = val.replace(/^char:(?!$)/, '');  //remove prefix from char:X
				let n = token.replaceAll(/\W+/g, '');
				if (n != '') id = '+' + n;  //'+' will be replaces with name
			} else if (token == null) {  //rule 2
				token = id;
			} else if (id == null) {  //rule 3
				let n = token.replaceAll(/\W+/g, '');
				if (n == '') n = val.replaceAll(/\W+/g, '');  //remove non-word
				if (n != '') id = '+' + n;  //'+' will be replaces with name
			}
			if (token == '_') token = ' ';
			// If icondef, use that value instead, but retain token
			if (icondef != null) val = icondef;
			// Represent single char, surrogate pair or 'U+xxxxx' as char:x
			if (val.length == 1 ||
				(val.length == 2 && val.codePointAt(0) >= 0x10000) ||
				val.match(/^U\+[0-9a-f]{1,6}$/i)) {
				val = 'char:' + val;
			}
			// Add option to options structure
			if (id != orgId || token != orgToken || val != orgVal) {
				LogParse.log(`Checkbox '${def.name}' option '${arg}' changed to '${id}=[${token}]${val}'`);
			}
			let opt = {
				id    : id,
				token : token,
				value : val,
			}
			opts.push(opt);
		}
		if (opts.length <= 0) {
			LogParse.warn(`Checkbox '${def.name}' has no options`);
			opts = 'empty';
		}
		def._options = opts;
	});
	// Resolve all checkbox references (sets _options, _resolved, place)
	function resolve(def) {
		if (def._resolved == 2) return;  //done
		if (def._resolved == 1) {
			// Already busy
			LogParse.warn('Reference Loop detected for Checkbox \'' + def.name + '\'');
			def._options = 'refloop';
		} else {
			def._resolved = 1;  //start calculate
			let opts = def._options;
			if (opts == 'empty') {
				// Leave empty
			} else {
				// Go through all options to resolve
				def._options = [];
				for (let i = 0; i < opts.length; ++i) {
					let opt = opts[i];
					if (typeof opt === 'string') {
						// Reference
						let def2 = parsed.resolveCheckboxDefs(opt, def.lineNum);
						if (def2 != null) {
							// Found reference, resolve and insert options
							resolve(def2);
							let opts2 = def2._options;
							if (opts2 == 'empty') {
								// No options to add
								LogParse.log('Checkbox \'' + def.name + '\' extends Empty \'' + def2.name + '\'');
							} else if (opts2 == 'refloop') {
								// If refloop, then we are also refloop
								LogParse.warn('Checkbox \'' + def.name + '\' extends RefLoop \'' + def2.name + '\'');
								def._options = 'refloop';
								break;
							} else {
								// Add options
								LogParse.log('Checkbox \'' + def.name + '\' extends \'' + def2.name + '\'');
								for (let j = 0; j < opts2.length; ++j) {
									LogParse.debug('Add option \'' + opts2[j].value + '\'');
									// Not owned, clone it
									let opt2 = opts2[j];
									def._options.push({
										id    : opt2.id,
										token : opt2.token,
										value : opt2.value,
									});
								}
							}
							// Inherit pragmas
							if (def2.place != null && def.place == null) def.place = def2.place;
						} else {
							// Unknown reference, skip
							LogParse.warn('Checkbox \'' + def.name + '\' extends undefined \'' + def2.name + '\'');
						}
					} else {
						// Option
						def._options.push(opt);  //already owned, no need to clone
					}
				}
			}
		}
		def._resolved = 2;  //done calculate
	}
	iterateCheckboxDefs(resolve);
	// Finalize options (sets options, first, place)
	iterateCheckboxDefs(def => {
		let opts = def._options;
		if (typeof opts === 'string') {
			def.options = opts;
		} else if (opts.length <= 0) {
			def.options = 'empty';
		} else {
			// Iterate options and finalize them
			let numopt = opts.length;
			for (let i = 0; i < numopt; ++i) {
				// Link options together (sets next)
				let opt = opts[i];
				let next = opts[(i+1) % numopt];
				opt.next = next.token;
				// Set id if not already set
				if (opt.id == null) {
					opt.id = def.name + '-i' + (i+1);
					LogParse.log(`Checkbox '${def.name}' option changed to '${opt.id}=[${opt.token}]${opt.value}'`);
				} else {
					let m = opt.id.match(/^\+(.*)$/);
					if (m) {
						opt.id = def.name + '-' + m[1];
						LogParse.log(`Checkbox '${def.name}' option changed to '${opt.id}=[${opt.token}]${opt.value}'`);
					}
				}
			}
			// Convert array to a lookup hash
			let hash = {};
			for (let i = 0; i < numopt; ++i) {
				let opt = opts[i];
				hash[opt.token] = opt;
			}
			def.options = hash;
			def.first = opts[0].token;
		}
		// Set defaults
		if (def.place == null) def.place = 'F';
		// Render debug
		if (def._debug) {
			let line = `Interpreted: !checkbox ${def.name}`;
			// Add pragmas
			if (def.place == 'B') line += ' !back';
			else if (def.place == 'F') line += ' !front';
			def._debug.lines.push(line);
			// Add options
			if (typeof def.options === 'string') {
				def._debug.lines.push(`- <${def.options}>`);
			} else {
				let num = 0;
				for (let opt = def.options[def.first]; ; opt = def.options[opt.next]) {
					let line = `${++num}) ${opt.id}=[${opt.token}]${opt.value}`;
					if (opt.token == def.first) line += '    <-- first';
					def._debug.lines.push(line);
					if (opt.next == def.first) break;
				}
			}
		}
	});
	//LogParse.devlog('CheckboxDefs ', parsed._checkboxDefs);

	// Check if all blocks have been closed
	if (textBlock) {
		throw new UserInputError('Missing !endtext for !text', textBlock.lineNum);
	}
	if (styleBlock) {
		throw new UserInputError('Missing !endstyle for !style', styleBlock.lineNum);
	}
	if (scriptBlock) {
		throw new UserInputError('Missing !endscript for !script', scriptBlock.lineNum);
	}

	// Log all links
	//for (let i = 0; i < allLinks.length; ++i) LogParse.log('Link=' + allLinks[i]);
	// Log all roots
	//for (let i = 0; i < parsed.rootLinks.length; ++i) LogParse.log('RootLink=' + parsed.rootLinks[i]);

	return parsed;
}

// }}}

// Rendering Links {{{

function render(parsed, container, cancel) {
	// Render the RootLinks in the container.
	container.textContent = '';
	let rendered = outputItems(parsed.rootLinks, 1, container, '', cancel);

	// Set/update event handler to quick-open Settings
	addQuickShowSettingsPanelEvent(container, rendered);

	// Collect all checkboxes in a hierarchy
	let toplevel = [];
	function discover(links, parent) {
		for (let i = 0; i < links.length; ++i) {
			let link = links[i];
			let here = parent;
			if (link.output && link.output.checkbox && link.output.checkbox.present) {
				// This item has a checkbox
				let cb = link.output.checkbox;
				if (parent == null) {
					toplevel.push(cb);
				} else {
					parent.children.push(cb);
				}
				cb.parent = parent;
				here = cb;  //descend a level
			}
			if (link.cont) discover(link.cont, parent);  //add these to same parent
			if (link.subs) discover(link.subs, here);  //add these below here
		}
	}
	discover(parsed.rootLinks, null);
	// For all the toplevels, calculate the hierarchical status
	for (let i = 0; i < toplevel.length; ++i) {
		toplevel[i].updateSelFirst(true);
	}

	// Render array of Links to the container at specified level.
	function outputItems(links, level, container, parentPath, cancel) {
		let rendered = [];
		for (let i = 0; i < links.length; ++i) {
			let link = links[i];
			let subrendered = null;
			if (link.type == 'link') {
				subrendered = outputItem(link, level, container, parentPath, cancel);
			} else if (link.type == 'text') {
				let ctl = outputText(link.lines, container);
				subrendered = { ctl: ctl, lineNum: link.lineNum };
			} else if (link.type == 'debug') {
				let ctl = outputDebug(link.lines, container);
				subrendered = { ctl: ctl, lineNum: link.lineNum };
			}
			if (cancel()) return;
			if (subrendered) {
				if (subrendered.length)
					rendered.push(...subrendered);
				else
					rendered.push(subrendered);
			}
		}
		return rendered;
	}

	// Output Link {{{

	// Render Link object, including its children to the container at specified level.
	// Level 1 is called Section and is rendered with a heading.
	// Level 2 is called Block and is rendered as a rectangular block.
	// Level 3 is called Item and is rendered as a line in a Block.
	// Level 4 and higher are called sub-Items and are rendered as indented Items.
	function outputItem(link, level, container, parentPath, cancel) {
		//LogRender.log('outputItem ' + link.toString());
		// Copy input data
		let name = link.name;
		let url = link.url;
		let icon = link.icon;
		let checkType = link.checkType;
		let checkValue = link.checkValue;
		let target = link.target;
		let cssName = link.cssName;
		let tooltip = null;
		let contItems = link.cont;
		if (contItems != null && contItems.length == 0) contItems = null;
		let subItems = link.subs;
		if (subItems != null && subItems.length == 0) subItems = null;
		if (name == '') name = null;
		if (url == '') url = null;
		if (icon == '') icon = null;
		if (target == '') target = null;
		if (cssName == '') cssName = null;
		let myPath = parentPath + '->' + name;
		link['output'] = {
			icon     : null,
			checkbox : null,
		};
		// Fill in defaults for missing elements
		if (name == null) {
			if (url != null) {
				name = url;  //name defaults to url
			} else {
				name = '_';  //indicates the name may be hidden
			}
		}
		// Change URL if target=manual
		if (target == 'manual') {
			let msg = 'Due to security reasons, this URL cannot be opened automatically.\nCopied URL \'' + url + '\' to clipboard.\n\nManually paste this to the address bar.';
			msg = msg.replaceAll('\'', '\\\'').replaceAll('\n', '\\n');
			tooltip = url;  //preserve original URL
			url = 'javascript:navigator.clipboard.writeText(\'' + url + '\');alert(\'' + encodeURI(msg) + '\');void(0)';
			target = null;
		}
		// If the url is a 'search:', replace it with the proper call
		if (url != null) {
			let m = url.match(/^search:(.+)/);
			if (m) {
				let searcher = m[1];
				url = getRegisteredSearchUrl(searcher, name);
			}
		}
		// Render the item
		// State variables for this item; will be used in closures
		let addItemContainer;  //function to add a container to put the Item into
		let addSubContainer;  //function to add a container to put the subItems into
		let addClosingElements = null;  //function to add closing elements to the container
		// Create element container
		if (level == 1) {
			// Render Item as Section
			//LogRender.log('Render Section ' + name);
			let _itemContainer;
			let _subContainer;
			addItemContainer = function() {
				_itemContainer = document.createElement('h2');
				_itemContainer.className = 'section-name level1';
				if (cssName != null) _itemContainer.classList.add(cssName);
				container.appendChild(_itemContainer);
				return _itemContainer;
			}
			addSubContainer = function() {
				_subContainer = document.createElement('div');
				_subContainer.className = 'section';
				container.appendChild(_subContainer);
				return _subContainer;
			};
			addClosingElements = function() {
				let closingElements = document.createElement('hr');
				container.appendChild(closingElements);
			}
		} else if (level == 2) {
			// Render Item as Block
			//LogRender.log('Render Block ' + name);
			let _blockContainer;
			let getBlockContainer = function() {
				if (_blockContainer) {
					return _blockContainer;
				}
				// Create a new _blockContainer
				_blockContainer = document.createElement('div');
				_blockContainer.className = 'block';
				if (cssName != null) _blockContainer.classList.add(cssName);
				container.appendChild(_blockContainer);
				if (subItems != null) {
					let expandIcon = document.createElement('span');  //container to display '-' or '+'
					expandIcon.className = 'resize-icon';
					expandIcon.textContent = UNICODE_BLACK_RIGHT_POINTING_TRIANGLE;
					_blockContainer.appendChild(expandIcon);
					let isExpanded = !parsed.blocksCollapsedInitially;  //true if block is expanded
					if (!parsed.blocksCollapsedAlwaysInitial) {
						// Use persistent value if available
						let v = Data.readItemExpanded(myPath);
						LogBlockExpand.debug('Preset isExpanded for \'' + myPath + '\' to ' + v);
						if (v == 'false') {
							isExpanded = false;
						} else if (v == 'true') {
							isExpanded = true;
						}
					}
					let displayExpandState = function() {
						LogBlockExpand.debug('Display isExpanded for \'' + myPath + '\' as ' + isExpanded);
						if (isExpanded) {
							// Expand this block
							_blockContainer.classList.remove('collapsed');
							_blockContainer.classList.add('expanding');
							_blockContainer.onanimationend = function() {
								_blockContainer.onanimationend = null;
								_blockContainer.classList.add('expanded');
								_blockContainer.classList.remove('expanding');
							};
							// Reflect action of resize-icon
							expandIcon.title = 'Hide';
						} else {
							// Collapse this block
							_blockContainer.classList.remove('expanded');
							_blockContainer.classList.add('collapsing');
							_blockContainer.onanimationend = function() {
								_blockContainer.onanimationend = null;
								_blockContainer.classList.add('collapsed');
								_blockContainer.classList.remove('collapsing');
							};
							// Reflect action of resize-icon
							expandIcon.title = 'Show';
						}
					};
					expandIcon.onclick = function() {
						isExpanded = !isExpanded;
						LogBlockExpand.debug('Set isExpanded for \'' + name + '\' to ' + isExpanded);
						Data.writeItemExpanded(myPath, isExpanded);
						displayExpandState();
					};
					addClosingElements = function() {
						// Display the initial state
						//displayExpandState();  //display initial state
						if (isExpanded) {
							_blockContainer.classList.add('expanded');
							expandIcon.title = 'Hide';
						} else {
							_blockContainer.classList.add('collapsed');
							expandIcon.title = 'Show';
						}
					}
				}
				return _blockContainer;
			}
			let _itemContainer;
			let _subContainer;
			addItemContainer = function() {
				_itemContainer = document.createElement('span');
				_itemContainer.className = 'block-name level2';
				getBlockContainer().appendChild(_itemContainer);
				return _itemContainer;
			}
			addSubContainer = function() {
				_subContainer = document.createElement('div');
				_subContainer.className = 'items block-items';
				let sliderContainer = document.createElement('div');
				sliderContainer.className = 'slider-container';
				sliderContainer.appendChild(_subContainer);
				getBlockContainer().appendChild(sliderContainer);
				return _subContainer;
			}
		} else {
			// Render Item is (sub-)Item
			//LogRender.log('Render Item ' + name);
			let _groupContainer;
			let _itemContainer;
			let _subContainer;
			addItemContainer = function() {
				if (contItems != null) {
					// This is the 'group-leader'
					_groupContainer = document.createElement('div');  //make a div for the continuation group
					_groupContainer.className = 'group';
					container.appendChild(_groupContainer);
				} else {
					// This is not a 'group-leader'
					_groupContainer = container;  //use same container
				}
				_itemContainer = document.createElement('div');
				_itemContainer.className = 'item level' + level;
				if (cssName != null) _itemContainer.classList.add(cssName);
				_groupContainer.appendChild(_itemContainer);
				return _itemContainer;
			}
			addSubContainer = function(continuation = false) {
				if (continuation) {
					// This is a 'group-member'
					return _groupContainer;
				} else {
					// This is a sub-Item
					_subContainer = document.createElement('div');
					_subContainer.className = 'items';
					container.appendChild(_subContainer);
					return _subContainer;
				}
			}
		}
		// Create element itself
		let rendered = [];
		if (name == '---') {
			// Special separator item
			let item = document.createElement('hr');
			item.className = 'separator';
			if (cssName != null) item.classList.add(cssName);
			container.appendChild(item);
			rendered.push({ ctl: item, lineNum: link.lineNum });
		} else {
			let itemContainer = addItemContainer();
			rendered.push({ ctl: itemContainer, lineNum: link.lineNum });
			// The containers are structured as follows:
			// - groupContainer: Only if there are continued Items
			//     - itemContainer: Holds the entire (Sub)Item
			//         - checkbox: Only if it is a checkbox item
			//         - linkContainer: Only if there is a URL
			//             - icon: In itemContainer if there is no linkContainer
			//             - textContainer: Only present if there is a name
			//                              In itemContainer if there is no linkContainer
			//                 - text: name
			//     - continued items
			//     - subContainer: Only if there are subItems

			// Declare textContainer to hold the name/label
			let textContainer = null;
			let setTextClass = (className, add) => addClass(textContainer, className, add);
			let textContainer_maybe = itemContainer;  //null if we must create a separate one

			// Create checkbox
			let checkbox = outputCheckbox(checkType, checkValue, link.lineNum);
			if (checkbox.present) {
				textContainer_maybe = null;  //for styling purposes
				link.output.checkbox = checkbox;
			}

			// Create hyperlink
			let hyperlink = null;
			if (url != null) {
				hyperlink = document.createElement('a');
				hyperlink.href = url;
				hyperlink.className = 'link';
				if (target != null)
					hyperlink.target = target;
				if (tooltip != null)
					hyperlink.title = tooltip;
				textContainer_maybe = hyperlink;  //hyperlink can serve as textContainer
			}

			// Create icon_control
			let icon_control = renderIcon(parsed, null, icon, url);
			if (icon_control.present) {
				textContainer_maybe = null;  //for styling purposes
				link.output.icon = icon_control;
			}

			// Determine name/label to display
			if (name != null) {
				if (name == '_') {
					// Name indicates it should not be displayed.
					// Do this only if this doesn't lead to
					// unclickable links and the like.
					if (icon_control.present) {
						// There is an icon that is clickable too.
						name = null;
					} else if (url == null) {
						// This item is not clickable anyway.
						name = null
					} else {
						// We cannot hide it, give it a better name
						if (level == 1) name = 'Heading';
						else if (level == 2) name = 'Block';
						else name = 'Item';
					}
				}
			}

			// Add checkbox to the itemContainer
			if (checkbox.present && checkbox.place == 'F') {
				itemContainer.appendChild(checkbox.element);
				checkbox.associateContainer(itemContainer);
			}

			// Add hyperlink to itemContainer
			// Alias linkContainer to hyperlink if it exists, itemContainer otherwise
			let linkContainer;  //this container holds the link
			if (hyperlink != null) {
				itemContainer.appendChild(hyperlink);
				linkContainer = hyperlink;
			} else {
				linkContainer = itemContainer;
			}

			// Add icon_control to linkContainer
			if (icon_control.element != null) {
				linkContainer.appendChild(icon_control.element);
			}

			// Create a textContainer if necessary and add it to linkContainer
			if (name != null) {
				if (textContainer_maybe != null) {
					// This control can serve as textContainer
					textContainer = textContainer_maybe;
				} else {
					// Create a new control
					textContainer = document.createElement('span');
					linkContainer.appendChild(textContainer);
				}
				let containers = [ textContainer ];  //stack of nested containers
				let openElem = (className) => {
					let el = document.createElement('span');
					if (className != null) el.className = className;
					containers[0].appendChild(el);
					containers.unshift(el);
				};
				let closeElem = () => {
					containers.shift();
				};
				let addElem = (text, className) => {
					if (text == '') return;
					let nest = className != null;
					if (nest) openElem(className);
					containers[0].appendChild(document.createTextNode(text));
					if (nest) closeElem();
				};
				// Process *...* to make strong
				// Definitions:
				// - A Delimiter is a sequence of '*' characters with no
				//   extra '*' before or after.
				// - A StringGroup is a sequence 'Delimiter text Delimiter'.
				// Rules:
				// - There should be spaces or any of (<{[ in front of the
				//   StrongGroup and spaces or any of ]}>)!?.,;: behind, i.e.
				//   before the start Delimiter and after the
				//   end Delimiter.  This is slightly
				//   restrictive by design (avoid false
				//   positives).
				// - There should be no spaces directly after the start
				//   Delimiter or before the end Delimiter. This should be
				//   no problem, because you can't see a bold space.
				// - There should be no repetition of the Delimiter inside
				//   the StrongGroup. To avoid this, the Delimiter's length can
				//   be chosen differently.
				//
				// Regex to match StrongGroup, capture:
				// - 1: open delimiter
				// - 2: text
				// - 3: close delimiter
				let reSG = /(?<=^|[\s(<{\[])(\*+)(?!\*|\s)((?:(?!\1).)*?)(?<!\*|\s)(\1)(?=[\]}>)!?.,;:\s]|$)/;
				// Split on this regex. Expect 3 captures per match and n+1
				// parts for n separator matches. This means for n matches,
				// the array should have 3*n + n+1 = 4*n+1 elements.
				// Or n = (length-1)/4, which should be integer.
				let parts = name.split(reSG);
				if (parts.length > 1 && ((parts.length-1) % 4) == 0) {
					//LogRender.devlog('Found *...*: ' + parts.length + ' elements', parts);
					let i = 0;
					// Add first literal
					addElem(parts[i++]);
					while (i < parts.length-1) {
						openElem('strong');
						addElem(parts[i++], 'delim-open');  //opening delimiter
						addElem(parts[i++], 'delim-text');  //delimited text
						addElem(parts[i++], 'delim-close');  //closing delimiter
						closeElem();
						addElem(parts[i++]);  //inbetween text
					}
				} else {
					addElem(name);
				}
				if (checkbox.present) {
					// This is a checkbox item, give the name the correct class
					setTextClass('checkbox-label', true);
				} else {
					setTextClass('link-name', true);
				}
			}

			// Add checkbox to the itemContainer
			if (checkbox.present && checkbox.place == 'B') {
				itemContainer.appendChild(checkbox.element);
				checkbox.associateContainer(itemContainer);
			}

			// If there is continuation, output those items in this itemContainer too
			if (contItems != null) {
				let subrendered = outputItems(contItems, level, addSubContainer(true), myPath, cancel);
				if (subrendered) rendered.push(...subrendered);
			}
		}
		// Create sub-Items in container
		if (subItems != null) {
			if (addSubContainer) {
				let subContainer = addSubContainer();
				let subrendered = outputItems(subItems, level+1, subContainer, myPath, cancel);
				if (subrendered) rendered.push(...subrendered);
			}
		}
		// Add closing elements
		if (addClosingElements) {
			addClosingElements();
		}

		return rendered;
	}

	// Output a <div> element as next child of the container.
	function outputText(lines, container) {
		let html = lines.join('\n');
		let div = document.createElement('div');
		div.className = 'text-block';
		div.innerHTML = html;
		container.appendChild(div);
		return div;
	}

	// Output a <div> element as next child of the container.
	function outputDebug(lines, container) {
		let div = document.createElement('div');
		div.className = 'debug-box';
		div.textContent = lines.join('\n');
		container.appendChild(div);
		return div;
	}

	// }}}

	// Output Checkbox {{{

	// Create element for a checkbox and return that.
	// Arguments:
	// - type: Type of checkbox, null if no checkbox.
	// - value: Current value of checkbox.
	// - lineNum: Linenumber where this checkbox is in the links. This is used
	//   to update the value when the checkbox' value is changed.
	// Returns object with:
	// - present: True if a checkbox was generated.
	// - element: Represents the checkbox, may be null.
	// - associateContainer: Function to call to associate this checkbox with
	//   its container. The single argument should be a DOM element,
	//   representing the container.
	// - place: 'F' (front) or 'B' (back).
	function outputCheckbox(type, value, lineNum) {
		// If type==null, don't make a checkbox
		let retval = {
			present             : false,
			element             : null,
			associateContainer  : null,
			place               : null,
			// Transient data
			selFirstMe          : null,  //true if my current selection is first
			selFirstAllParents  : null,  //true if all parents have current selection first
			selFirstAllChildren : null,  //true if all children's current selection is first
			// parent/children of this checkbox, will be filled in later
			parent              : null,
			children            : [],
			iterateChildren     : iterateChildren,  //iterate the children, calling specified function
			updateSelFirst      : updateSelFirst,  //propagate selFirstXxx
		};
		if (type == null) return retval;

		// Find the checkbox definition for this type
		let def = parsed.resolveCheckboxDefs(type, lineNum);

		// Placeholder for the associated label
		let container = null;
		let changeClass = (classPrefix, name) => {
			addClass(container, '^' + classPrefix, '*');
			addClass(container, classPrefix + name, true);
		};
		let setClass = null;
		let initialSetContainer = null;  //will be set to init function
		retval.associateContainer = element => {
			container = element;
			if (initialSetContainer) initialSetContainer();
		};

		// Function to update the Links
		let updateCb = function(newCheck) {
			// Note: Checkbox already identified by parser. Now only locate it:
			// - Match lineNum-1 linebreaks
			// - Match the first [...] pair
			const rePrevLines = '(^(?:[^\\n]*\\n){' + (lineNum - 1) + '})';  //capture 1: lines
			const reBeforeCbx = '([^\\][]*?)';  //capture 2: No checkbox characters
			const reCbx = '\\[(?:\\s+|[^\\][\\s]+)?\\]';  //[...]
			const re = new RegExp(rePrevLines + reBeforeCbx + reCbx);
			let links = Data.readLocalLinks();
			let newLinks = links.replace(re, '$1$2' + newCheck);
			if (newLinks != links) {
				links = newLinks;
				Data.writeLocalLinks(links);
				Data.setDisplayedLinks(links);
				if (PendingUpload) {
					PendingUpload.add(() => {
						let links = Data.readLocalLinks();
						uploadLinks(links);
					});
				} else {
					uploadLinks(links);
				}
			} else {
				LogCheckbox.error('RegExp did not change Links: ', re);
			}
		}

		// Render the checkbox as specified by the definition
		let checkbox = null;
		if (def == null || (def.name == 'default' && def.options == 'empty')) {
			// Default checkbox: Use the standard <input> element
			checkbox = document.createElement('input');
			checkbox.type = 'checkbox';
			checkbox.className = 'todo-checkbox';
			setClass = () => {
				changeClass('cbx-opt-default-', checkbox.checked ? 'check' : 'uncheck');
			};
			checkbox.onchange = function() {
				// Update Links
				let newCheck;
				if (checkbox.checked) {
					// Change checkbox to checked
					LogCheckbox.log('Check checkbox on line ' + lineNum);
					newCheck = '[x]';
					retval.selFirstMe = false;
				} else {
					// Change checkbox to checked
					LogCheckbox.log('Uncheck checkbox on line ' + lineNum);
					newCheck = '[ ]';
					retval.selFirstMe = true;
				}
				updateCb(newCheck);
				// Update label
				setClass();
				// Update parents/children
				updateSelFirst(true);
			};
			checkbox.ondblclick = function() {
				// Stop propagation so that Settings won't be opened.
				event.stopPropagation();  //newer method
				return false;  //legacy method
			};
			let isChecked = value != null && value != '' && value != ' ';
			checkbox.checked = isChecked;
			retval.selFirstMe = !isChecked;
			initialSetContainer = setClass;
			// Set return value
			retval.present = true;
			retval.element = checkbox;
			retval.place = (def != null) ? def.place : 'F';
		} else {
			// The checkbox is defined by def
			let checkbox = document.createElement('span');
			checkbox.className = 'custom-checkbox';
			let opts = def.options;
			let isFirst, icon;
			if (opts == 'empty') {
				isFirst = true;
				icon = renderIcon(parsed, null, CheckboxEmpty);
			} else if (opts == 'refloop') {
				isFirst = true;
				icon = renderIcon(parsed, null, CheckboxRefLoop);
			} else {
				let sel = opts[value];
				if (sel == null) sel = opts[def.first];
				isFirst = sel.token == def.first;
				icon = renderIcon(parsed, null, sel.value);
				setClass = () => {
					changeClass('cbx-opt-', sel.id);
				};
				checkbox.onmousedown = function() {
					// Stop propagation so that this is not interpreted as a
					// doubleclick that would select text or open Settings.
					event.stopPropagation();  //newer method
					return false;  //legacy method
				};
				checkbox.onmouseup = function() {
					// Determine next value
					sel = def.options[sel.next];
					isFirst = sel.token == def.first;
					retval.selFirstMe = isFirst;
					// Update Links
					if (sel != null) {
						LogCheckbox.log('Change checkbox on line ' + lineNum + ' to ' + sel.token);
						let newCheck = '[' + sel.token + ']';
						updateCb(newCheck);
					}
					// Update icon
					let newIcon = renderIcon(parsed, null, sel.value);
					checkbox.replaceChild(newIcon.element, icon.element);
					icon = newIcon;
					// Update label
					setClass();
					// Update parents/children
					updateSelFirst(true);
					// Stop propagation so that this is not interpreted as a double click
					event.stopPropagation();  //newer method
					return false;  //legacy method
				};
				initialSetContainer = setClass;
			}
			if (icon.present) checkbox.appendChild(icon.element);
			// Set return value
			retval.selFirstMe = isFirst;
			retval.present = icon.present;
			retval.element = checkbox;
			retval.place = def.place;
		}

		// Callbacks if parent/child changed
		function iterateChildren(func, recurse) {
			let func2;
			if (recurse) {
				func2 = child => {
					func(child);
					child.iterateChildren(func, recurse);
				};
			} else {
				func2 = func;
			}
			for (let i = 0; i < retval.children.length; ++i) {
				func2(retval.children[i]);
			}
		}
		function updateSelFirst(down) {
			//LogCheckbox.devlog('Checkbox on line ' + lineNum + ': updateSelFirst(' + (down ? 'down' : 'up') + ')');
			// Parent may have set a new value
			retval.selFirstAllChildren = true;
			iterateChildren(child => {
				if (down) {
					// Propagate selFirstMe and selFirstAllParents down
					child.selFirstAllParents = retval.selFirstMe && retval.selFirstAllParents;
					// Recurse down
					child.updateSelFirst(true);
				}
				// Propagate selFirstAllChildren up
				if (!child.selFirstMe || !child.selFirstAllChildren) {
					retval.selFirstAllChildren = false;
				}
			});
			// Recurse up
			if (retval.parent != null) {
				retval.parent.updateSelFirst(false);
			}
			//LogCheckbox.log(retval);
			// Update Appearance
			let classes = {};
			let anyParentChecked = retval.selFirstAllParents === false;
			classes['any-parent-checked'] = anyParentChecked;
			let anyChildChecked = retval.selFirstAllChildren === false;
			classes['any-child-checked'] = anyChildChecked;
			let selfChecked = !retval.selFirstMe;
			classes['self-checked'] = selfChecked;
			// Apply classes
			let target = retval.element.parentElement;  //the itemContainer
			for (className in classes) {
				addClass(target, className, classes[className]);
			}
		}

		return retval;
	}

	// }}}
}

// Render Icon {{{

// Create element for an icon and return that.
// If alt_text is defined, use that.
// icon_url is what is specified in the icon=URL argument, see explanation at
// the top of this file.
// Returns object with:
// - present: True if a non-empty icon was generated.
// - element: Represents the icon, may be null.
//
// To retrieve the icon, first try the primary URL. If that fails and skip_alternatives==false,
// try these alternatives:
// - http://www.google.com/s2/favicons?domain=<target_url domain>
// - http://www.google.com/s2/favicons?domain=<icon_url domain>
function renderIcon(parsed, alt_text, icon_url, target_url, skip_alternatives = false) {
	let requestUndef = icon_url == 'undefined';

	// By default, construct icon_url from target_url
	if ((icon_url == null || icon_url == 'default') && target_url != null) {
		// Check if the target domain is in IconDefs
		let found = null;
		let m = target_url.match(/^\w+:\/\/([a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)+)/);
		if (m) {
			let domain = m[1];
			let replacement = parsed.resolveIconDefs(domain);
			if (replacement != domain) found = replacement;
		}
		// If not found, use the default URL
		if (found == null) {
			found = getDefaultIconUrl(target_url);
		}
		icon_url = found;
	}

	// See if icon_url is an IconDef and resolve it
	if (icon_url != null) {
		icon_url = parsed.resolveIconDefs(icon_url);
	}

	let icon_present = false;
	let icon_element = null;

	// Render icon_url
	let html_icon = null;
	let svg_icon = null;
	let img_icon = null;
	LogIcon.debug('Loading icon for target \'' + (target_url ? target_url : '<no-target-url>') + '\': ' + (icon_url != null ? '\'' + icon_url + '\'' : 'null'));

	let m;  //for regex matches
	if (icon_url == null) {
		// No icon
	} else if (icon_url == 'none') {
		// No icon
	} else if (icon_url == 'empty') {
		html_icon = '';
	} else if (m = icon_url.match(/^html:(.+)/i)) {
		html_icon = m[1].replace(/&(?:sp|spc|space);/ig, ' ');
	} else if (m = icon_url.match(/^char:(.+)/i)) {
		let text = m[1];
		// Replace 'U+XXX...'
		function hexChar(hex) {
			let i = Number('0x' + hex);
			if (i > 0xFFFF) {
				// JavaScript only supports UTF-16, so for codepoints
				// above 0x10000, surrogate pairs are used, see
				// https://en.wikipedia.org/wiki/UTF-16#U+0000_to_U+D7FF_and_U+E000_to_U+FFFF
				let w1 = 0xD800 + (((i - 0x10000) >> 10) & 0x3FF);  //higher 10 bits
				let w2 = 0xDC00 + (i & 0x3FF);  //lower 10 bits
				return String.fromCharCode(w1, w2);
			} else {
				return String.fromCharCode(i);
			}
		}
		text = text.replace(/^U\+([0-9a-f]+)$/i, s => hexChar(s.substring(2)));
		if (text.length <= 3) {
			// SVG will maintain aspect ratio, but will clip if too large
			svg_icon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text text-anchor="middle" x="50%" y="1em" font-size="90">' + text + '</text></svg>';
		} else {
			// Will scale the text to fit, but changes aspect ratio
			html_icon = text;
		}
	} else if (icon_url == 'krul') {
		svg_icon = KrulSvg;
	} else if (icon_url.match(/^https?:\/\/|\.|^alt\b/i)) {
		// It is any of:
		// - URL, starting with http:// or https://
		// - Domain or filename with a '.'
		// - alt
		img_icon = document.createElement('img');

		let alternatives = [], methods = [], urls = [];  //prepare options to use for the icon
		if (m = icon_url.match(/^alt(?::([^?]+))?(?:\?(.+))?/i)) {
			// icon_url contains an alt specification
			let method = m[1];
			let url = m[2];
			if (method == null || method == '' || method == 'any' || method == '*') {
				// Add all known methods
				methods.push('google');
			} else {
				// Add only the specified method
				methods.push(method);
			}
			if (url != null && url != '') {
				// Add the specified URL only
				urls.push(url);
			} else {
				// Add the icon_url (but that doesn't contain a URL) and target_url
				if (target_url != null && target_url != '') {
					urls.push(target_url);
				}
			}
		} else {
			// icon_url contains a URL of the icon
			alternatives.push(icon_url);
			if (!skip_alternatives) {
				// Try the alternatives in order of 'likely correct'.
				// Note that the google-favicons always returns an image, even a generic one, so it
				// will always prevent further alternatives to be attempted.
				methods.push('google');
				if (icon_url != null) {
					urls.push(icon_url);
				}
				if (target_url != null) {
					urls.push(target_url);
				}
			}
		}
		//LogIcon.devlog('All methods for ' + icon_url, methods);
		//LogIcon.devlog('All urls for ' + icon_url, urls);
		// Go through methods and urls and add alternatives
		for (let m = 0; m < methods.length; ++m) {
			let method = methods[m];
			for (let u = 0; u < urls.length; ++u) {
				if (method == 'google') {
					alternatives.push(getGoogleAltIconUrl(urls[u]));
				} else {
					LogIcon.error('Unknown alt icon method: ' + method);
				}
			}
		}
		//LogIcon.devlog('All alternatives for ' + icon_url, alternatives);
		// Remove duplicates
		let seen = {};
		let alt_list = alternatives;  //may have duplicates
		alternatives = [];  //get the unique ones
		for (let a = 0; a < alt_list.length; ++a) {
			if (!seen[alt_list[a]]) {
				seen[alt_list[a]] = true;
				alternatives.push(alt_list[a]);
			}
		}
		//LogIcon.devlog('All unique alternatives for ' + icon_url, alternatives);
		// Set the icon urls until we find one that works
		let try_next = function() {
			if (alternatives.length > 0) {
				// Try next alternative
				//LogIcon.devlog('alternatives.length=' + alternatives.length);
				let alt = alternatives.shift();
				if (img_icon.src != null && img_icon.src != '') {
					LogIcon.warn('Cannot load icon \'' + img_icon.src + '\', try \'' + alt + '\'');
				}
				img_icon.src = alt;
			} else {
				// Stop trying
				LogIcon.error('Cannot load icon: ' + img_icon.src);
				if (alt_text != null) {
					// prepare to show the alt text
					img_icon.src = '';
				} else {
					// hide entire image
					img_icon.style.visibility = 'hidden';
				}
				img_icon.onerror = null;  //stop handling errors
			}
		}
		img_icon.onerror = try_next;
		try_next();  //set first alternative

		if (alt_text != null) {
			img_icon.alt = alt_text;
		}
	} else {
		// Did not recognize, use 'undefined'
		if (requestUndef) {
			// This call was already requesting 'undefined'. Apparently
			// something went wrong. Now just use the default.
			return renderIcon(parsed, alt_text, IconUndefinedDefault, target_url, skip_alternatives);
		} else {
			// Find if there is a definition of it
			return renderIcon(parsed, alt_text, 'undefined', target_url, skip_alternatives);
		}
	}

	if (img_icon != null) {
		img_icon.className = 'icon img-icon';
		icon_element = img_icon;
		icon_present = true;
	} else if (html_icon != null) {
		let iconDiv = document.createElement('div');
		iconDiv.className = 'icon html-icon';
		let htmlDiv = document.createElement('div');
		htmlDiv.innerHTML = html_icon;  //also takes care of HTML rendering, including entities
		FillScaler.observe(htmlDiv);
		iconDiv.appendChild(htmlDiv);
		icon_element = iconDiv;
		icon_present = true;
	} else if (svg_icon != null) {
		let iconDiv = document.createElement('div');
		iconDiv.className = 'icon svg-icon';
		iconDiv.innerHTML = svg_icon;
		FillScaler.observe(iconDiv.children[0]);  //this is the <svg> element
		icon_element = iconDiv;
		icon_present = true;
	}

	// Return the URL where the default icon should be.
	function getDefaultIconUrl(site_url) {
		return site_url.replace(/(?:(?:(?<!\/)\/(?!\/)|\?|#).*)?$/, '/favicon.ico');  //replace first single '/', '?' or '#' and onwards
	}

	// Return the URL for an icon of the site_url's domain.
	// This method uses the Google database.
	function getGoogleAltIconUrl(site_url) {
		let domain = site_url
			.replace(/^[^\/]*\/\//, '')  //remove scheme
			.replace(/\/.*/, '');  //remove path
		return 'http://www.google.com/s2/favicons?domain=' + domain;
	}

	return {
		present : icon_present,
		element : icon_element,
	};
}

// }}}

// Define a ResizeObserver that is used to resize entries to 100% of their
// parent's size. This is used for icons that are defined with html:<x>.
var FillScaler = new ResizeObserver(function(entries) {
	for (let entry of entries) {
		let element = entry.target;
		LogRender.log('FillScaler: Scaling element \'' + element.innerHTML + '\'');
		//LogRender.devlog(entry);
		// Get entries current size (how big it wants to be)
		let w = element.scrollWidth, h = element.scrollHeight;
		LogRender.debug('FillScaler: Element Scroll size ' + w + ' x ' + h);
		// Get parent's current size
		let parent = element.parentElement;
		let pw = parent.offsetWidth;
		let ph = parent.offsetHeight;
		//LogRender.devlog('FillScaler: Parent size ' + pw + ' x ' + ph);
		// Calculate new scaling factor
		let scaleX = pw / w;
		let scaleY = ph / h;
		//LogRender.devlog('FillScaler: Scale with ' + scaleX + ' x ' + scaleY);
		// Check if the change is big enough
		let changeX = element._scaleX / scaleX;
		let changeY = element._scaleY / scaleY;
		//LogRender.devlog('FillScaler: Scale change ' + changeX + ' x ' + changeY);
		if (isNaN(changeX) || changeX < 0.98 || changeX > 1.02 || isNaN(changeY) || changeY < 0.98 || changeY > 1.02) {
			// More than 2% change
			LogRender.log('FillScaler: Set scale ' + scaleX + ' x ' + scaleY);
			element._scaleX = scaleX;
			element._scaleY = scaleY;
			entry.target.style.scale = scaleX + ' ' + scaleY;
		} else {
			LogRender.log('FillScaler: Scale change too small ' + changeX + ' x ' + changeY);
		}
	}
});

// Item Doubleclick handing {{{

let RenderedItems = null;  // array of { ctl, lineNum } objects

// This function is called by render() to set the RenderedItems and, if for
// the first time, also the event handler.
// This event is added on the topmost container in bubbling phase, so it is
// called last and may be stopped by any control below. This may change in
// future, but for now if feels usable.
function addQuickShowSettingsPanelEvent(container, renderedItems) {
	if (RenderedItems == null)
		container.addEventListener('dblclick', quickShowSettingsPanel);
	RenderedItems = renderedItems;
}

// Go through the RenderedItems and open the Settings on the line that is
// closest to the mouse pointer in the event.
function quickShowSettingsPanel(event) {
	let mouseX = event.clientX, mouseY = event.clientY;
	//LogRender.devlog(`Doubleclick at (${ev.clientX}, ${ev.clientY})`);
	let min = Number.MAX_VALUE;
	let closest = null;
	for (let i = 0; i < RenderedItems.length; ++i) {
		let item = RenderedItems[i];
		let rect = item.ctl.getBoundingClientRect();
		// Calcualte distance between mouseX/Y and rect
		let dx, dy;
		if (mouseX < rect.left) dx = rect.left - mouseX;
		else if (mouseX > rect.right) dx = mouseX - rect.right;
		else dx = 0;
		if (mouseY < rect.top) dy = rect.top - mouseY;
		else if (mouseY > rect.bottom) dy = mouseY - rect.bottom;
		else dy = 0;
		// The standard distance:
		//let d = Math.sqrt(dx**2 + dy**2);
		// In this case, however, I'm more interested in the
		// straight horizontal and vertical distance. If we
		// just do dx+dy, we make the diagonal effectively more
		// expensive.
		// Also I'd like to make vertical more expensive too,
		// because one tends to doublclick 'next to the item'.
		let d = dx + 3*dy;
		LogRender.debug(`Control ${i}: dx=${dx}, dy=${dy} -> d=${d}`);
		if (d < min) {
			LogRender.log(`Closer: ${d} < ${min}`);
			min = d;
			closest = item;
		}
	}
	//closest.ctl.style.border = '2px dotted red';
	showSettingsPanel(closest.lineNum);
}

// }}}

// }}}

// SearchBox related functions {{{

// The search functions will be accessed by name (lower case identifier with
// spaces replaced by '_').
// Every identifier has sub-keys for different functions.
// A search function has the search query as input and should return a URL to
// go to for the results.

var SearchFunction = {
	'duck_duck_go' : {
		'text'   : getTemplateUrl('https://duckduckgo.com?q=%urlinput'),
	},
	'google' : {
		'text'   : getTemplateUrl('https://www.google.com/search?q=%urlinput'),
	},
	'wikipedia' : {
		'text'   : getTemplateUrl('https://www.wikipedia.org/wiki/Special:Search?go=Go&search=%urlinput'),
	},
	'youtube' : {
		'text'   : getTemplateUrl('https://www.youtube.com/results?search_query=%urlinput'),
	},
	'wayback_machine' : {
		'text'   : getWaybackSearchUrl,
		'domain' : getWaybackDomainUrl,
	},
	'google_maps' : {
		'text'   : getTemplateUrl('https://maps.google.com/?q=%urlinput'),
	},
	'default' : {
		'text'   : getNoUrl,
		'domain' : getWithSchemaUrl,
	},
};

// Converts the identifier to a key that can be used in the SearchFunction
// structure.
// This function is available for use in the configuration.
function getSearchFunctionId(identifier) {
	return identifier.toLowerCase().replaceAll(' ', '_');

}

// This function adds the function to SearchFunction for this identifier.
// searchFunction should have the text as input and return a results URL.
// This function is available for use in the configuration.
function registerSearchFunction(identifier, searchFunction, what = 'text') {
	let id = getSearchFunctionId(identifier);
	if (!(id in SearchFunction)) {
		SearchFunction[id] = {};
	}
	SearchFunction[id][what] = searchFunction;
}

// This function adds the urlTemplate to SearchFunction for this identifier.
// See getTemplateUrl() for templateUrl.
// This function is available for use in the configuration.
function registerSearchTemplate(identifier, urlTemplate, what = 'text') {
	let searchFunction = getTemplateUrl(urlTemplate);
	registerSearchFunction(identifier, searchFunction, what);
}

// This function finds the registered searchFunction for this identifier.
// It then calls it with the searchText and returns the URL.
// Returns null if not found.
// This function is available for use in the configuration.
function getRegisteredSearchUrl(identifier, searchText, what = 'text') {
	let id = getSearchFunctionId(identifier);
	if (id in SearchFunction && what in SearchFunction[id]) {
		return SearchFunction[id][what](searchText);
	} else {
		return null;
	}
}

// Return a URL to handle the address (ie beautify it to go to it).
function getWithSchemaUrl(address) {
	let url = address;
	if (!url.match(/^[\w+-]+:/)) {
		url = 'http://' + url;  //add default scheme
	}
	return url;
}

// This is a dummy search function, that can be used as a default.
function getNoUrl(intput) {
	return null;
}

// This function returns a function that uses the template to construct a URL.
// The template is a URL with the following placeholders:
// - %input: Replaced with the supplied input value.
// - %urlinput: Replaced with the URL-encoded input value.
// This function is available for use in the configuration.
function getTemplateUrl(template) {
	return function(input) {
		let encoded_input = encodeURIComponent(input).replace(' ', '+');
		return template
			.replace('%input', input)
			.replace('%urlinput', encoded_input);
	};
}

// Returns a URL to perform a lookup for the domain with Wayback Machine.
function getWaybackDomainUrl(domain) {
	let ts = getWaybackTimestamp();
	return 'https://web.archive.org/web/' + ts + '/' + domain;
};

// Returns a URL to perform a search for input with Wayback Machine.
function getWaybackSearchUrl(input) {
	let ts = getWaybackTimestamp();
	let encoded_input = encodeURIComponent(input).replace(' ', '+');
	return 'https://web.archive.org/web/' + ts + '/' + encoded_input;
};

// Create a Wayback Machine timestamp that can be used in queries.
function getWaybackTimestamp(date = new Date()) {
	let pad = function(number, positions) {
		let neg = false;
		if (number < 0) {
			neg = true;
			positions--;  //space for '-'
			number = -number;
		}
		let s = '';
		for (let i = 2, limit = 10; i <= positions; ++i, limit *= 10) {
			if (number < limit) s += '0';
		}
		s += number;
		if (neg) s = '-' + s;
		return s;
	};
	// I assume the format is 'yyyymmddhhmmss*' with yyyy the year
	// to query and the rest '0'.
	let timestamp = pad(date.getFullYear(), 4) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		'*';
	return timestamp;
}

// Process search input.
// Redirects to search.
// May return if search input is not clear.
function processSearchInput(searchBox, getSearchUrl, getDomainSearchUrl = getWithSchemaUrl) {
	let input = searchBox.value;
	if (input.match(/^\s*$/)) {
		LogSearch.log('Empty search string');
		// Set the blink animated style
		searchBox.classList.add('blink');
		searchBox.onanimationend = function() {
			searchBox.onanimationend = null;
			searchBox.classList.remove('blink');
		};
	} else {
		let m = input.match(/^\s*(\S+\.\S+)\s*$/);
		let url = null;
		if (m && getDomainSearchUrl) {
			//LogSearch.log('Looks like URL');
			url = getDomainSearchUrl(m[1]);
			LogSearch.log('Go to URL \'' + url + '\'');
		} else {
			url = getSearchUrl(input);
			LogSearch.log('Search \'' + url + '\'');
		}
		if (url) {
			window.location.href = url;
		} else {
			LogSearch.log('No URL to go to');
		}
	}
}

// Create search button to container and set up the event callback.
// This also adds icons to the buttons. Do that here instead of with
// static HTML, because I saw that the browser tries to render static
// images before the JavaScript generated ones and I'd like to render
// the links as soon as possible.
// The displayed icon is specified by icon_url. If this is 'alt', the
// target domain is derived from getSearchUrl().
function addSearchButton(parsed, container, search_box, button_id, label_text, tooltip, icon_url, getSearchUrl, getDomainSearchUrl) {
	let btn = document.createElement('button');
	if (btn) {
		// Configure the button
		btn.id = 'BtnSearch' + button_id;
		btn.className = 'button';
		btn.onclick = function() {
			processSearchInput(search_box, getSearchUrl, getDomainSearchUrl);
			return false;  //skip default handling
		}
		btn.title = tooltip;

		// Add icon
		let target_domain = getSearchUrl('__favicon_check__');
		//LogSearch.log('target_domain=' + target_domain);
		//LogSearch.log('favicon=' + getDefaultIconUrl(target_domain));
		// When determining the icon, don't consider alternatives,
		// except when icon_url == 'alt...'
		let icon = renderIcon(parsed, tooltip, icon_url, target_domain, true);
		if (icon.element != null) btn.appendChild(icon.element);

		// Add link text
		if (label_text != null) {
			let label = document.createElement('span');
			label.className = 'label';
			let textNode = document.createTextNode(label_text);
			label.appendChild(textNode);
			btn.appendChild(label);
		}

		// Add the button to the container
		container.appendChild(btn);
	}
}

function addSearchButtons(parsed, searchBox, container) {
	for (let i = 0; i < parsed.searchButtonDefs.length; ++i) {
		// Get the fields from the definition
		let def = parsed.searchButtonDefs[i];
		let f = 0;

		let id = def[f++];
		if (!id) continue;  //id is mandatory, ignore this entry if absent
		let key = getSearchFunctionId(id);
		let label = def[f++];
		let tooltip = def[f++];
		let icon = def[f++];
		let urlTemplate = def[f++];

		// Register UrlTemplate (if specified)
		if (urlTemplate) {
			registerSearchTemplate(key, urlTemplate);
		}

		// Determine referenced Search URL Functions
		let getSearchUrl = null, getDomainSearchUrl = null;
		let searchFunction = SearchFunction[key];
		if (searchFunction) {
			getSearchUrl = SearchFunction[key]['text'];
			getDomainSearchUrl = SearchFunction[key]['domain'];
		}

		// Determine Label
		if (!label) {
			label = id;
		} else if (label == '_') {
			label = null;
		}

		// Determine Tooltip
		if (!tooltip) {
			tooltip = id;
		} else if (tooltip == '_') {
			tooltip = null;
		}

		// Determine Icon
		if (!icon) {
			if (getSearchUrl) {
				// Search URL function is defined. This is
				// needed to retrieve the 'default' icon.
				icon = 'default';
			} else {
				// There is no Search URL function, use a
				// standard magnifying glass icon.
				icon = 'char:' + UNICODE_LEFT_POINTING_MAGNIFYING_GLASS;
			}
		}

		// Determine final Search URL Function
		if (!getSearchUrl) {
			// No Search Function, use default (assume it exists)
			getSearchUrl = SearchFunction['default']['text'];
		}

		// Determine final Domain Search URL Function
		if (!getDomainSearchUrl) {
			// No Search Function, use default (assume it exists)
			getDomainSearchUrl = SearchFunction['default']['domain'];
		}

		// Log the fields
		LogSearch.log('addSearchButtons: Identifier=\'' + id + '\'');
		LogSearch.debug('addSearchButtons: Label=\'' + label + '\'');
		LogSearch.debug('addSearchButtons: Tooltip=\'' + tooltip + '\'');
		LogSearch.debug('addSearchButtons: Icon=\'' + icon + '\'');
		LogSearch.debug('addSearchButtons: UrlTemplate=\'' + urlTemplate + '\'');
		LogSearch.debug('addSearchButtons: getSearchUrl=\'' + getSearchUrl + '\'');
		LogSearch.debug('addSearchButtons: getDomainSearchUrl=\'' + getDomainSearchUrl + '\'');
		//LogSearch.debug(SearchFunction);

		// Create the button
		addSearchButton(parsed, container, searchBox, id, label, tooltip, icon, getSearchUrl, getDomainSearchUrl);
	}
}

// }}}

// Edit Settings {{{

// These variables will be set in initSettingsPanel()
// Function to open the Settings panel
// Optionally a line number can be supplied to scroll to.
let showSettingsPanel = null;
// Function to update the displayed Conflict state
let updateSettingsConflict = null;
// Function to make Settings TextArea readonly
let setSettingsReadOnly = null;

// Set up the events for the settings panel.
function initSettingsPanel() {
	LogSettings.important('Initialize Settings panel...');

	// Assign iconBarClosed, iconBarOpen and settingsPanel variables
	let iconBarClosed = document.getElementById('SettingsIconBarClosed');  //iconbar for closed status
	let iconBarOpen = document.getElementById('SettingsIconBarOpen');  //iconbar for open status
	let settingsPanel = null;
	let iconOpen, iconSave, iconClear, iconCancel, warningDirty;

	// Status
	let visible = false;
	let textRO = false;

	// Other global variables for Settings (will be assigned in createSettings())
	let settingsText;
	let loadOptionEntries = [], saveOptionEntries = [];
	let recreateOptionEntries;

	// Create the minimal hooks (expose functions) and defer rest at first showing
	showSettingsPanel = showSettings;
	updateSettingsConflict = updateConflict;
	setSettingsReadOnly = setReadOnly;
	// Create iconOpen
	iconOpen = document.createElement('span');
	setUnicodeText(iconOpen, UNICODE_GEARS, '[Settings]');
	iconOpen.title = 'Settings';
	iconOpen.className = 'settings-icon';
	iconOpen.onclick = () => showSettings();
	iconBarClosed.appendChild(iconOpen);

	// Create rest of the Settings panel. This is called at first showing.
	function createSettings() {
		// First get the panels from the DOM and ensure they're found
		settingsPanel = document.getElementById('SettingsForm');
		if (!settingsPanel) return false;
		let settingsArea = document.getElementById('SettingsArea');
		if (!settingsArea) return false;

		// Now create the basic buttons to at least be able to close
		// the panel. Keep the buttons basic to not end up in a
		// exception, breaking the buttons to close.

		// Create iconSave
		iconSave = document.createElement('span');
		iconSave.title = 'Save (Ctrl-S)';
		iconSave.className = 'settings-icon';
		iconSave.onclick = () => hideSettings(true);
		iconBarOpen.appendChild(iconSave);
		// Create iconClear
		iconClear = document.createElement('span');
		iconClear.title = 'Clear';
		iconClear.className = 'settings-icon';
		iconClear.onclick = () => hideSettings('clear');
		iconBarOpen.appendChild(iconClear);
		// Create iconCancel
		iconCancel = document.createElement('span');
		iconCancel.title = 'Cancel (Ctrl-Q)';
		iconCancel.className = 'settings-icon';
		iconCancel.onclick = () => hideSettings(false);
		iconBarOpen.appendChild(iconCancel);

		setUnicodeText(iconSave, UNICODE_WHITE_HARD_SHELL_FLOPPY_DISK, UNICODE_CHECK_MARK, '[OK]');
		setUnicodeText(iconClear, UNICODE_EMPTY_DOCUMENT, UNICODE_CLOCKWISE_OPEN_CIRCLE_ARROW, 'C');
		setUnicodeText(iconCancel, UNICODE_CANCELLATION, UNICODE_CROSS_MARK + UNICODE_VARIATION_SELECTOR_15, 'X');

		//// Create buttonBar
		//let buttonBar = document.createElement('div');
		//buttonBar.className = 'buttonbar';
		//settingsArea.appendChild(buttonBar);
		//
		//// Create btnSave
		//let btnSave = document.createElement('button');
		//btnSave.textContent = 'Save';
		//btnSave.className = 'button';
		//btnSave.onclick = () => { hideSettings(true); return false }
		//buttonBar.appendChild(btnSave);
		//// Create btnClear
		//let btnClear = document.createElement('button');
		//btnClear.textContent = 'Clear';
		//btnClear.className = 'button';
		//btnClear.onclick = () => { hideSettings('clear'); return false }
		//buttonBar.appendChild(btnClear);
		//// Create btnCancel
		//let btnCancel = document.createElement('button');
		//btnCancel.textContent = 'Cancel';
		//btnCancel.className = 'button';
		//btnCancel.onclick = () => { hideSettings(false); return false }
		//buttonBar.appendChild(btnCancel);


		// Configure settingsPanel
		settingsPanel.onkeydown = function(e) {
			if (isKey(e, 'c', 's')) {
				if (visible) hideSettings(true);
				return false;  //stop default button action
			}
			return true;
		};
		// Bind entire document
		window.addEventListener('keydown', function(e) {
			if (isKey(e, 'c', 'q')) {
				if (visible) {  //only if Settings visible
					hideSettings(false);
					e.preventDefault();
					return false;  //stop default button action
				}
			}
			return true;
		});

		// Create hidden warnings
		warningDirty = document.createElement('div');
		warningDirty.className = 'alert-box hidden';
		warningDirty.innerHTML = `
<span class="label">WARNING</span>: Previous online save was unsuccessful. Choose one of the following:<br>
&bull; <span class="accent">Save</span> will overwrite online changes with this configuration, discarding changes that have been made online.<br>
&bull; <span class="accent">Clear</span> will discard local changes and download the online version.<br>
&bull; <span class="accent">Cancel</span> will not make any changes.
`;
		settingsArea.appendChild(warningDirty);

		// Create settingsText
		settingsText = document.createElement('textarea');
		settingsText.wrap = 'off';
		settingsText.autocomplete = 'off';
		settingsText.autocorrect = false;
		settingsText.autocapitalize = 'off';
		settingsText.spellcheck = false;
		settingsText.placeholder = 'Settings';
		settingsText.className = 'textbox';
		settingsText.readOnly = textRO;
		settingsText.onkeydown = function(e) {
			if (isKey(e, '?s', 'Tab')) {
				return !tabInsert(this, !e.shiftKey);
			} else if (isKey(e, '', 'Enter')) {
				// Copy indentation from current line
				return !textInsert(this, (before, mid, after) => {
					let m = before.match(/(?:^|\r|\n)([ \t]*)[^\r\n]*$/);  //match: 'linebreak whitespace line end'
					return '\n' + m[1];  //insert linebreak plus matched whitespace
				});
			} else if (isKey(e, '', 'Home')) {
				// Go to first non-whitespace character or first column
				return !gotoHome(this);
			}
			return true;
		};
		settingsArea.appendChild(settingsText);

		// Create optionsPanel
		let optionsPanel = document.createElement('div');
		optionsPanel.className = 'options';
		settingsArea.appendChild(optionsPanel);
		createOptionEntries(optionsPanel);

		recreateOptionEntries = () => {
			// Clean current Panel
			optionsPanel.textContent = '';
			loadOptionEntries = [];
			saveOptionEntries = [];
			// Recreate Panel
			createOptionEntries(optionsPanel);
		};

		return true;
	}

	// Create Option Entries
	function createOptionEntries(optionsPanel) {
		function createOption(labelText, getData, saveData, private) {
			let label = document.createElement('div');
			label.className = 'label';
			label.appendChild(document.createTextNode(labelText));
			optionsPanel.appendChild(label);
			let container = document.createElement('div');
			container.className = 'input';
			let entry = document.createElement('input');
			entry.type = 'text';
			let hiddenData = null;  //not null if currently hidden
			if (private) {
				// May be private, hide value if not focus
				entry.onfocus = () => {
					entry.value = hiddenData;
					hiddenData = null;
				};
				entry.onblur = () => {
					hiddenData = entry.value;
					entry.value = '* * * * *';
				}
				hiddenData = '';  //set by showData()
			}
			entry.autocomplete = 'off';  //prevents 'Manage Passwords' popup
			container.appendChild(entry);
			optionsPanel.appendChild(container);
			let savedData;
			let option = {
				showData : () => {
					savedData = getData();
					if (hiddenData != null) {
						// Currently hidden
						hiddenData = savedData;
						entry.value = '* * * * *';
					} else {
						entry.value = savedData;
					}
				},
				saveData : () => {
					let newData = (hiddenData != null) ? hiddenData : entry.value;
					let changed = savedData != newData;
					saveData(savedData = newData);
					return changed;
				},
				entry    : entry,
			};
			return option;
		}
		let loadConfigName = UrlResolver.getLoadConfigName();
		let loadOverrideConfigName = UrlResolver.getLoadOverrideConfigName();
		if (loadOverrideConfigName && loadConfigName == loadOverrideConfigName) {
			// One entry for both LoadOverrideOptions and LoadOptions
			let option = createOption('Config \'' + loadOverrideConfigName + '\'',
				() => UrlResolver.getLoadOverrideOptions(),
				(value) => {
					Data.writeLoadOverrideOptions(value);
					//writeLoadOptions() would write to same ConfigName
				},
				UrlResolver.isDownloadUrlPrivate());
			loadOptionEntries.push(option);
		} else {
			if (loadOverrideConfigName) {
				// Entry for LoadOverrideOptions
				let option = createOption('Config \'' + loadOverrideConfigName + '\'',
					() => UrlResolver.getLoadOverrideOptions(),
					(value) => {
						Data.writeLoadOverrideOptions(value);
					},
					UrlResolver.isDownloadUrlPrivate());
				loadOptionEntries.push(option);
			}
			if (loadConfigName) {
				// Entry for LoadOptions
				let option = createOption('Config \'' + loadConfigName + '\'',
					() => UrlResolver.getLoadOptions(),
					(value) => {
						Data.writeLoadOptions(value);
					},
					UrlResolver.isDownloadUrlPrivate());
				loadOptionEntries.push(option);
			}
		}
		let saveConfigName = UrlResolver.getSaveConfigName();
		if (saveConfigName) {
			// Entry for SaveOptions
			let option = createOption('Online Save \'' + saveConfigName + '\'',
				() => {
					let disabled = UrlResolver.getUploadDisabled();
					if (disabled) {
						option.entry.disabled = true;
						option.entry.title = disabled;  //the text with reason
					} else {
						option.entry.disabled = false;
						option.entry.title = '';
					}
					return UrlResolver.getSaveOptions();
				},
				(value) => {
					if (!UrlResolver.getUploadDisabled()) {
						Data.writeSaveOptions(value);
					}
				},
				UrlResolver.isUploadUrlPrivate());
			saveOptionEntries.push(option);
		}
	}

	function updateConflict(conflicted) {
		if (conflicted == null) {
			// Determine the default value for ConflictState:
			// - Clean should be set (there was once a remote file)
			// - Local should be different (Dirty)
			// - SaveOptions set (so the User can actually fix it)
			conflicted = UrlResolver.getSaveOptions() && Data.linksDirty();
		}
		Data.setConflictState(conflicted);
		// Change visibility
		LogSettings.important('Set Links Conflicted=' + conflicted);
		addClass(iconOpen, 'alert', conflicted);
		addClass(iconSave, 'alert', conflicted);
		addClass(iconClear, 'alert', conflicted);
		addClass(warningDirty, 'hidden', !conflicted);
	}

	function setReadOnly(textReadOnly) {
		textRO = textReadOnly;
		if (settingsText) {
			settingsText.readOnly = textRO;
		}
	}

	// Note on onanimationend:
	// This class initiates multiple animations and thus multiple
	// onanimationend calls, one for each animation. Therefore, remove the
	// handler after fhe first time.

	// Show the Settings panel.
	function showSettings(gotoLine = null) {
		if (HOOK_Ready != null) HOOK_Ready.start();
		let scrollToLine = () => {
			if (gotoLine != null && settingsText) {
				// Find position of nth linebreak (/\r*\n\r*/)
				let n = gotoLine-1;  //line 1 should have 0 linebreaks before
				let t = settingsText.value;
				let spos = 0;
				let len = t.length;
				while (n > 0) {
					// Find linebreak
					while (spos < len && t[spos] != '\n') ++spos;
					// Find end of linebreak
					++spos;  //skip '\n'
					while (spos < len && t[spos] == '\r') ++spos;  //skip '\r'
					// spos is now at start of next line
					--n;
				}
				// Skip indentation whitespace
				let pos = spos;
				while (pos < len && (t[pos] == ' ' || t[pos] == '\t')) ++pos;
				// Search to end of this line
				let epos = pos;
				while (epos < len && t[epos] != '\r' && t[epos] != '\n') ++epos;
				// Select the line
				LogSettings.log(`Scroll to line ${gotoLine} (positions ${spos}-${epos}) on character position ${pos}`);
				// In a number of steps, shrink selection to insertion point
				let steps = 10, step = steps;
				let selStep = (step) => {
					//LogSettings.devlog('Set selection step=' + step);
					let f1 = step / steps;
					let f2 = 1 - f1;
					settingsText.selectionStart = spos * f1 + pos * f2;
					settingsText.selectionEnd = epos * f1 + pos * f2;
				};
				selStep(step);
				settingsText.focus();
				setTimeout(() => {
					// The scrollable area is scrollHeight pixels high
					// and the viewable area starts at scrollTop.
					// The visible area is offsetHeight.
					// If scrollTop>0, there was a need to scroll the
					// area to get the cursor line in view. The result
					// is that the selected line is at the bottom.
					// To get this in the middle, add half of
					// offsetHeight to scrollTop.
					// Do this after a timeout to give scrollTop time to
					// settle.
					if (settingsText.scrollTop > 0) {
						let shift = settingsText.offsetHeight / 2;
						LogSettings.devlog('Scroll window by ' + shift + ' pixels');
						settingsText.scrollTop += shift;
					}
				}, 50);
				let selTimer = () => {
					selStep(step--);
					if (step >= 0) setTimeout(selTimer, 500 / steps);
				}
				setTimeout(selTimer, 200);
			}
		};
		if (visible) {
			scrollToLine();
			if (HOOK_Ready != null) HOOK_Ready.stop();
			return;  //do nothing if already visible
		}
		// Create panel at first showing
		if (settingsPanel == null) {
			// Panel not yet initialized, create it
			if (!createSettings()) {
				// Creating panel failed, disable button and return
				iconBarClosed.classList.add('hidden');
				if (HOOK_Ready != null) HOOK_Ready.stop();
				return;
			}
		} else if (HOOK_ChangeSettings != null) {
			// Panel already created, but do recreate what is needed
			// in test conditions.
			recreateOptionEntries();
		}
		// Scroll to the top to where the Settings will be showing
		window.scrollTo({ top: 0, left: 100, behavior: 'smooth' });
		// Display items for conflicted Settings
		updateConflict();
		// Update the contents
		settingsText.value = Data.readLocalLinks();
		for (let i = 0; i < loadOptionEntries.length; ++i) {
			loadOptionEntries[i].showData();
		}
		for (let i = 0; i < saveOptionEntries.length; ++i) {
			saveOptionEntries[i].showData();
		}
		// Slide panel to visible
		settingsPanel.classList.add('expanding');
		settingsPanel.classList.add('show');
		settingsPanel.onanimationend = function() {
			settingsPanel.onanimationend = null;
			settingsPanel.classList.remove('expanding');
			scrollToLine();
			if (HOOK_ChangeSettings != null) {
				// Call the hook function to handle the settings
				HOOK_ChangeSettings.update(settingsText, loadOptionEntries, saveOptionEntries, hideSettings);
			}
		};
		// Slide iconBarClosed out and iconBarOpen in
		let going = iconBarClosed, coming = iconBarOpen;
		going.classList.add('slide-out');
		going.onanimationend = function() {
			going.onanimationend = null;
			going.classList.add('hidden');
			going.classList.remove('slide-out');
			coming.classList.remove('hidden');
			coming.classList.add('slide-in');
		};
		coming.onanimationend = function() {
			coming.onanimationend = null;
			coming.classList.remove('slide-in');
		};
		visible = true;
	};

	// Hide (Save or Cancel) Settings panel.
	function hideSettings(save) {
		//LogSettings.devlog('hideSettings(' + save + ')');
		if (!visible) return;  //do nothing if already hidden
		let hide = () => {
			// slide panel to hidden
			settingsPanel.classList.add('collapsing');
			settingsPanel.onanimationend = function() {
				settingsPanel.onanimationend = null;
				settingsPanel.classList.remove('show');
				settingsPanel.classList.remove('collapsing');
				if (HOOK_Ready != null) HOOK_Ready.stop();
			};
			// Slide iconBarOpen out and iconBarClosed in
			let going = iconBarOpen, coming = iconBarClosed;
			going.classList.add('slide-out');
			going.onanimationend = function() {
				going.onanimationend = null;
				going.classList.add('hidden');
				going.classList.remove('slide-out');
				coming.classList.remove('hidden');
				coming.classList.add('slide-in');
			};
			coming.onanimationend = function() {
				coming.onanimationend = null;
				coming.classList.remove('slide-in');
			};
			visible = false;
		};
		if (save) {
			// Update Links and close panel
			let saveLinks = Data.readLocalLinks();
			// Update Options (NB: This might change keys in Data)
			let loadOptionsChanged = false;
			for (let i = 0; i < loadOptionEntries.length; ++i) {
				if (loadOptionEntries[i].saveData()) loadOptionsChanged = true;
			}
			let saveOptionsChanged = false;
			for (let i = 0; i < saveOptionEntries.length; ++i) {
				if (saveOptionEntries[i].saveData()) saveOptionsChanged = true;
			}
			if (loadOptionsChanged || saveOptionsChanged) addStatus('Options Changed');
			// If LoadOptions have changed, save the LocalLinks under the new key
			if (loadOptionsChanged) Data.writeLocalLinks(saveLinks);
			// Update Links
			if (save == 'clear' || settingsText.value == '') {
				LogSettings.log('Clear settings');
				downloadUpdateLinks('', saveOptionsChanged, null, null)  //download and render updated Links
				.then(hide)
				.catch(error => {
					// There was an error
					// Always log for debugging
					LogSettings.error(error);
					// Put newly read value in settingsText to correct.
					// Restore old value in Links in case of cancel.
					settingsText.value = Data.readLocalLinks();
					Data.writeLocalLinks(saveLinks);
					if (error instanceof UserInputError) {
						// It is a UserInputError, show a dialog,
						// because the user can fix it.
						window.alert('Error when reloading settings: ' +
							error.message +
							'\n\nPlease correct or cancel.');
					} else {
						// It is another error, discard it, because
						// it has already been logged.
					}
				});
			} else {
				LogSettings.log('Save settings');
				try {
					let editLinks = settingsText.value;
					parseLinks(editLinks);  //throws error if invalid
					// If no exception, editLinks are correct
					if (loadOptionsChanged) {
						downloadUpdateLinks(editLinks, saveOptionsChanged, null, null);  //download and render updated Links
					} else {
						updateLinks(editLinks, null, saveOptionsChanged, null);
					}
					// Close the panel
					hide();
				} catch (error) {
					// Always log for debugging
					LogSettings.error(error);
					if (error instanceof UserInputError) {
						// It is a UserInputError, show a dialog,
						// because the user can fix it.
						window.alert('Error when saving settings: ' +
							error.message +
							'\n\nPlease correct or cancel.');
					} else {
						// It is another error, discard it, because
						// it has already been logged.
					}
					// Leave the value in settingsText to correct.
					// Restore old value in Links in case of cancel.
					Data.writeLocalLinks(saveLinks);
				}
			}
		} else {
			// Cancel
			hide();
		}
	};
}

// Assume the ctl is an input control.
// Return the sanitized insertion point or selection range.
function getSelection(ctl) {
	// The selection position indicates the selection, but also the insertion point
	let start = ctl.selectionStart;  //char pos AT which the selection starts
	let end = ctl.selectionEnd;  //char pos AFTER the selection end
	let dir = ctl.selectionDirection;  //forward, backward or none
	// Sanitize, so it is within the string:
	// - start is in [0, len]
	// - end is in [start, len]
	let len = ctl.value.len;
	if (start == null || start < 0) start = 0;
	if (start > len) start = len;
	if (end == null || end < start) end = start;
	if (end > len) end = len;
	// Current position is at the start or end
	let caret = (dir == 'backward') ? start : end;

	return [start, end, dir, caret];
}

// Assume the ctl is an input control.
// Determine the strings before and after the insertion point.
// Then call the inserter with these values. The inserter should return the insertion string.
// Update ctl and place the new insertion point after the insertion.
// Return true if handled.
function textInsert(ctl, inserter) {
	let pos = getSelection(ctl);
	let start = pos[0], end = pos[1];
	// Do the insertion, replace the selection if any
	let val = ctl.value;
	let before = val.substring(0, start), mid = val.substring(start, end), after = val.substring(end);
	let mid2 = inserter(before, mid, after);
	ctl.value = before + mid2 + after;
	// Put the insertion point after the insertion
	let newPos = start + mid2.length;
	ctl.selectionStart = ctl.selectionEnd = newPos;
	return true;
}

// Assume the ctl is an input control.
// 'Insert' a TAB. This may be a few different things:
// - If there is a selection, add/remove indentation.
// - If there is no selection, add N spaces.
// Return true if handled.
function tabInsert(ctl, add) {
	const N = 4;
	const space = ' ';
	let sel = getSelection(ctl);
	let val = ctl.value;
	let start = sel[0], end = sel[1], caret = sel[3];
	if (start != end) {
		// There is a slection -> add/remove indentation
		// Get the indexes of the starts of the lines in the selection
		let locs = [];
		let i = start;
		while (i > 0) {
			let ch = val.charAt(i-1);  //char before
			if (ch == '\r' || ch == '\n') break;
			--i;
		}
		let spaceBeforeStart = start - i;  //chars in line before selection
		locs.push(i);  //start of line at or before start
		i = start+1;
		while (i <= end) {
			let ch = val.charAt(i-1);  //char before
			if (ch == '\r' || ch == '\n') locs.push(i);
			++i;
		}
		let spaceBeforeEnd = end - locs[locs.length-1];  //chars in line after selection
		// Split the value at these indexes
		let parts = [];
		parts.push(val.substring(0, locs[0]));
		for (let i = 1; i < locs.length; ++i) {
			parts.push(val.substring(locs[i-1], locs[i]));
		}
		parts.push(val.substring(locs[locs.length-1]));
		// Change the parts
		if (add) {
			// At every location, insert indentation
			for (let i = 1; i < parts.length; ++i) {
				// Add n (max N) spaces
				let n = N;
				let ch = parts[i].charAt(0);
				if (ch == '\r' || ch == '\n' || ch == '') n = 0;
				//LogSettings.devlog('Part ' + i + ': Add ' + n + ' spaces');
				if (n > 0) {
					parts[i] = space.repeat(n) + parts[i];
					// Adjust the selection
					if (i == 1) start += n;  //the first is before start
					end += n;
				}
			}
		} else {
			// At every location, remove indentation
			for (let i = 1; i < parts.length; ++i) {
				// Find the number of spaces to remove with max N
				let n = 0;
				while (n < N) {
					let ch = parts[i].charAt(n);
					if (ch != space) break;
					++n;
				}
				// Remove n spaces
				//LogSettings.devlog('Part ' + i + ': Remove ' + n + ' spaces');
				if (n > 0) {
					parts[i] = parts[i].substring(n);
					if (i == 1) {
						start -= Math.min(n, spaceBeforeStart);
					}
					if (i == parts.length-1) {
						end -= Math.min(n, spaceBeforeEnd);
					} else {
						end -= n;
					}
				}
			}
		}
		// Put back the parts
		ctl.value = parts.join('');
		// Set the new selection
		ctl.selectionStart = start;
		ctl.selectionEnd = end;
		ctl.selectionDirection = sel[2];
	} else {
		// There is no selection -> add/remove N spaces at current position
		let before = val.substring(0, caret), after = val.substring(caret);
		let newBefore;
		if (add) {
			// Insert N spaces
			newBefore = before + space.repeat(N);
		} else {
			// Remove max N spaces
			let re = new RegExp(space + '{1,' + N + '}$');
			//LogSettings.devlog('Applying regex: ' + re);
			newBefore = before.replace(re, '');
		}
		ctl.value = newBefore + after;
		// Put the insertion point after the change
		ctl.selectionStart = ctl.selectionEnd = newBefore.length;
	}
	return true;
}

// Move insertion point to first non-whitespace or first column.
// The algorithm is as follows:
// 1. Find start of the selection (caret).
// 2. Find start of line (A) and first non-whitespace character (B) on that line.
// 3. Depending on the location of the carent wrt A and B, select the goto
//    position, according to this:
//      Positions : A    B
//      Go to     : BAABBABBBBBB...
//    "Go to B if to the right of B or closer to B or at A (for toggle). Go to
//    A if closer to A or at B (toggle)."
// 4. If a range is selected, deselect.
// Return true if handled.
function gotoHome(ctl) {
	let pos = getSelection(ctl);
	let caret = pos[3];
	let val = ctl.value;
	// Search to the left for start of line and start of text
	let posLine = 0, posText;
	for (let i = caret-1; i >= 0; --i) {  //start immediately before the caret
		let ch = val.charAt(i);
		if (ch == '\r' || ch == '\n') {
			// Found position of start of line
			posLine = i + 1;
			break;
		} else if (ch != ' ' && ch != '\t') {
			// Found non-whitespace
			posText = i;
		}
	}
	let newpos;
	if (posText !== undefined) {
		// Both start of line and start of text are to the left of the current position
		newpos = posText;
		//LogSettings.devlog(`Home pressed: posLine=${posLine} <= posText=${posText} < caret=${caret} -> newpos=${newpos}`);
	} else {
		// No first non-whitespace found, search to the right
		for (let i = caret; i < val.length; ++i) {
			let ch = val.charAt(i);
			if (ch == '\r' || ch == '\n') {
				// Found position of start of next line
				break;
			} else if (ch != ' ' && ch != '\t') {
				// Found non-whitespace
				posText = i;
				break;
			}
		}
		if (posText !== undefined) {
			// Caret is inside leading whitespace
			if (caret == posText) {
				newpos = posLine;  //at posText, toggle to posLine
			} else if (caret == posLine) {
				newpos = posText;  //at posLine, toggle to posText
			} else if (caret - posLine < posText - caret) {
				newpos = posLine;  //closer to posLine, go to posLine
			} else {
				newpos = posText;  //closer to posText, go to posText
			}
			//LogSettings.devlog(`Home pressed: posLine=${posLine} <= caret=${caret} <= posText=${posText} -> newpos=${newpos}`);
		} else {
			// Line consists of only whitespace, only consider start of line
			newpos = posLine;
			//LogSettings.devlog(`Home pressed: posLine=${posLine} <= caret=${caret} -> newpos=${newpos}`);
		}
	}
	// Change posisiton
	ctl.selectionStart = ctl.selectionEnd = newpos;
	return true;
}

// }}}

// StatusLine {{{

// These variables will be set in initStatus()
// Add a SatusLine statement. Insert separator if status=='/'
let addStatus = (status) => {};
// Clear current StatusLine.
let clearStatus = () => {};

// Initialize StatusLine functions
function initStatus() {
	let statusLine = document.getElementById('StatusLine');
	if (!statusLine) return;

	let currentLine = '';
	let lastStatus = null;
	let lastTs = null;
	let count = 0;

	function render() {
		return (count > 1) ? currentLine + '(' + count + 'x)' : currentLine;
	}

	function freeze() {
		currentLine = render();
		count = 0;
	}

	function addSeparator() {
		freeze();
		currentLine += ' \u{2022}';
		lastStatus = null;
	}

	addStatus = (status) => {
		if (status != '/') {
			// Add a separator if last status has been too long ago
			let nowTs = Date.now();
			if (lastTs > 0 && nowTs - lastTs > 5000) addSeparator();
			lastTs = nowTs;
			// Increase count or add status
			if (status == lastStatus) {
				count++;
			} else {
				freeze();
				currentLine += ' [' + status + ']';
				lastStatus = status;
				count = 1;
			}
		} else {
			addSeparator();
		}
		// Draw line
		statusLine.textContent = render();
	};

	clearStatus = () => {
		currentLine = '';
		lastStatus = null;
		lastTs = null;
		count = 0;
		statusLine.textContent = render();
	};

	statusLine.onclick = () => {
		statusLine.classList.toggle('visible');
	};
}

// }}}

// Handling prefer-color-scheme and PageTheme {{{

// Global variables that are used to monitor prefers-color-scheme
var PrefersColorSchemeListener = null;

// Function to set the theme of the body to the specified string.
// NB: The string theme can contain multiple CSS-class names.
function setPageTheme(theme) {
	// Determine value or default
	if (theme == null) theme = 'dark-theme';
	// Overwrite the current values
	LogInit.log('Set PageTheme to \'' + theme + '\'');
	document.body.className = theme;
}

// Initialize monitoring of light/dark theme and adjust PageTheme accordingly.
function initMonitorPreferColorScheme(enable) {
	// Remove existing listener
	if (PrefersColorSchemeListener) {
		LogInit.log('call PrefersColorSchemeListener.finit()');
		PrefersColorSchemeListener.finit();
		PrefersColorSchemeListener = null;
	}

	// Enable listener
	if (enable) {
		// Create a new listener
		// Note: If the function(){} syntax is used, 'this' refers to
		// the object. If ()=>{} syntax is used, 'this' refers to the
		// global window object, which is not what we need here.
		PrefersColorSchemeListener = {
			dark : window.matchMedia('(prefers-color-scheme: dark)'),
			light : window.matchMedia('(prefers-color-scheme: light)'),
			init : function() {
				LogInit.log('Install prefers-color-scheme listener');
				this.dark.addEventListener('change', this.handler);
				this.light.addEventListener('change', this.handler);
			},
			finit : function() {
				LogInit.log('Remove prefers-color-scheme listener');
				this.dark.removeEventListener('change', this.handler);
				this.light.removeEventListener('change', this.handler);
			},
			handler : function() {
				// Note: This handler may be called as event of
				// a matchMedia, in which case 'this' refers
				// to *that* object.
				if (!PrefersColorSchemeListener) return;
				if (PrefersColorSchemeListener.dark.matches) {
					LogInit.log('User prefers dark mode.');
					setPageTheme('dark-theme');
				} else if (PrefersColorSchemeListener.light.matches) {
					LogInit.log('User prefers light mode.');
					setPageTheme('light-theme');
				} else {
					LogInit.log('No specific preference detected, use default.');
					setPageTheme(null);
				}
			},
		};
		//LogInit.log('call PrefersColorSchemeListener.init()');
		PrefersColorSchemeListener.init();

		// Set the current theme
		//LogInit.log('call PrefersColorSchemeListener.handler()');
		PrefersColorSchemeListener.handler();
	}
}

// }}}

// Initialization {{{

// The input is direct content or an array with blocks that contain lines and
// a starting line number. If blocks==null, nothing is done.
// The blocks are used to create a single content string. applyFunc is caled
// with that string. This function returns whatever applyFunc() returned.
// If applyFunc() throws an error, the stacktrace is searched and if it
// contains an eval(), that line number is converted and added to the error
// string. This (optionally modified) error is re-thrown.
function applyBlocks(blocks, applyFunc) {
	if (blocks == null) return;

	let contents, lineNums;
	if ('length' in blocks) {
		// This is an array, assume of Block objects.
		// Concatenate and translate line numbers.
		if (blocks.length <= 0) return;
		contents = [];
		lineNums = [ 0 ];  //eval lineNum -> input lineNum
		let inputLineNum;
		for (let i = 0; i < blocks.length; ++i) {
			let block = blocks[i];
			inputLineNum = block.lineNum + 1;  //content starts 1 line after block
			for (let j = 0; j < block.lines.length; ++j) {
				contents.push(block.lines[j]);
				lineNums.push(inputLineNum + j);
			}
		}
		contents = contents.join('\n');
	} else {
		contents = blocks;  //single string
		lineNums = null;  // not available
	}
	try {
		// Try to apply the contents
		return applyFunc(contents);
	} catch (error) {
		if ('stack' in error && lineNums != null) {
			// There's a stack and line numbers to try to
			// report on the original input line number.
			let stack = error.stack.toString();
			let m = stack.match(/\beval:(\d+)/);  //Firefox syntax
			if (!m) m = stack.match(/<?\banonymous>?:(\d+)/);  //Edge syntax
			if (m) {
				// We got the line number inside an eval
				// translate it to the input line numbers
				let lineNum = m[1];
				if (lineNum >= 1 && lineNum < lineNums.length) {
					// It in the expected range
					lineNum = lineNums[lineNum];
					error.message += ' on line ' + lineNum;
				}
			}
		}
		throw error;  //re-throw
	}
}

// Function to set the styles defined by the configuration.
// Should not throw exception, because errors are silently ignored.
function setStyleBlocks(styles) {
	applyBlocks(styles, function(str) {
		let el = document.getElementById('dynamic-styles');
		if (!el) {
			// Does not yet exist, create it
			el = document.createElement('style');
			el.id = 'dynamic-styles';
			document.head.appendChild(el);
		}
		el.innerHTML = str;
	});
}

// Function to add the script defined by the configuration.
// Throws exception if something is wrong.
function addScriptBlocks(script) {
	applyBlocks(script, function(str) {
		// Do an indirect eval().
		// According to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval ,
		// indirect eval() is safer.
		//LogInit.log('Eval script: ', contents, lineNums);
		eval?.(str);
	});
	// Note: Script is added and I don't know of a way to remove script
	// (especially if they are used for events). This could be remedied
	// by performing a reload (window.location = window.location or so)
	// if the supplied script is different from the previously supplied
	// script.
	// I'm not doing automatic reload, because:
	// - With many scripts, reloading is not needed.
	// - Reloading may have side-effect, especially with events handlers.
	// - It wouldn't be sufficient, because a !text block may also contain
	//   script.
	// - The work-around of a manual page reload is not a big issue.
}

// Function to set the title to the specified string.
function setPageTitle(title) {
	// Determine value or default
	if (title == null) title = 'Favorites';
	// Set the title
	LogInit.log('Set PageTitle to \'' + title + '\'');
	document.title = title;
	let titleCtl = document.getElementById('Title');
	if (titleCtl)
		titleCtl.innerText = title;
}

// Function to set the font-size to the specified string.
function setFontSize(size) {
	// Determine value or default
	if (size == null) size = '100%';
	// Set the --font-size variable that is used in the CSS classes
	LogInit.log('Set FontSize to \'' + size + '\'');
	document.documentElement.style.setProperty('--font-size', size);
}

// From the Links configuration, parse its content and display it.
// This function may throw a UserInputError exceptions when something is wrong
// with the contents of the Links variable.
function processLinks(links, cancel = null) {
	if (!cancel) cancel = () => false;

	// Parse Links
	let parsed = parseLinks(links);  //throws exception if invalid

	// Set readonly if:
	// - !no-edit is in the config.
	let readonly = parsed.noEdit;
	// - LoadOverrideOptons without SaveOptions are used. In this case,
	//   edits cannot be saved and a refresh would overwrite them with the
	//   LoadOverride. This would be confusing. Therefore, make it so the
	//   config can not be changed to start with.
	readonly ||= UrlResolver.getLoadOverrideOptions() && !UrlResolver.getSaveOptions();
	setSettingsReadOnly(readonly);

	if (cancel()) return;

	LogInit.important('Render styles, scripts, title, etc');

	// First handle scripts and styles (to catch errors quickly)
	try {
		setStyleBlocks(parsed.styleBlocks);
		addScriptBlocks(parsed.scriptBlocks);
	} catch (error) {
		let newError = new UserInputError(error.message);
		newError.cause = error;
		throw newError;
	}

	if (cancel()) return;

	// Set page title, theme and font size
	setPageTitle(parsed.pageTitle);
	if (parsed.pageTheme == null || parsed.pageTheme.toLowerCase() == 'auto') {
		initMonitorPreferColorScheme(true);
	} else {
		initMonitorPreferColorScheme(false);
		setPageTheme(parsed.pageTheme);
	}
	setFontSize(parsed.fontSize);

	// Set AutoUploadDelay if specified
	if (parsed.autoUploadDelay != null) {
		if (PendingUpload) {
			if (parsed.autoUploadDelay > 0) {
				LogInit.log('Change AutoUploadDelay to ' + parsed.autoUploadDelay);
				PendingUpload.setTimeout(parsed.autoUploadDelay);
			} else {
				LogInit.log('Disable AutoUploadDelay');
				PendingUpload.dispose();
				PendingUpload = null;
			}
		} else {
			if (parsed.autoUploadDelay > 0) {
				LogInit.log('Set AutoUploadDelay to ' + parsed.autoUploadDelay);
				PendingUpload = CreatePending('PendingUpload', parsed.autoUploadDelay, true);
			}
		}
	}

	// Render links
	LogInit.important('Render Links...');
	let container = document.getElementById('LinksBox');
	render(parsed, container, cancel);

	if (cancel()) return;

	// Fill SearchForm
	LogInit.important('Render SearchButtons...');
	let searchForm = document.getElementById('SearchForm');
	// Use a static input field, so that the browser retains its contents
	// after going back to this page.
	if (parsed.searchButtonDefs != null && parsed.searchButtonDefs.length > 0) {
		// There are SearchButtens, fill SearchForm
		LogInit.log('There are ' + parsed.searchButtonDefs.length + ' SearchButtonDefs');
		// Focus SearchBox
		let searchBox = document.getElementById('SearchBox');
		if (searchBox) {
			LogInit.log('Hide & focus SearchForm');
			searchForm.classList.remove('hidden');
			searchBox.focus();
			searchBox.select();
		}
		// Initialize the search buttons
		let buttonBox = document.getElementById('SearchButtons');
		buttonBox.textContent = '';
		addSearchButtons(parsed, searchBox, buttonBox);
	} else {
		// No SearchButtons defined, hide SearchForm
		LogInit.log('There are no SearchButtonDefs');
		if (searchForm) {
			LogInit.log('Hide SearchForm');
			searchForm.classList.add('hidden');
		}
	}
}

// Integrate newly downloaded and/or edited configuration into local- and
// clean in Data. Also uploads if necessary.
// Arguments:
// - editLinks: Update for LocalLinks, null if no change, empty string ('') to
//   clear.
// - downloadLinks: Newly downloaded links, null if none.
// - forceUpload: True if the caller already determined that the configuration
//   should be uploaded.
// - preRenderCancel: Object to cancel ongoing pre-render, null if not set.
// Render will be done synchronously, upload asynchronously, but this function
// does not return anything.
function updateLinks(editLinks, downloadLinks, forceUpload, preRenderCancel) {
	// We now have 4 sources:
	// - Local Links: This is the current configuration.  This is the
	//   configuration that was last displayed.
	// - Clean Links: This is the last downloaded configuration.  This acts
	//   as a common ancestor for Local and Download.
	// - Download Links: This is the configuration that has just been
	//   downloaded.
	// - Edit Links: Locally updated Links.
	//
	// The tables below use the following characters:
	// - -: null
	// - e: Empty string ('')
	// - A, B, C: A non-null value
	// - ?: Any value or a 'don't care'
	//
	// First, integrate Edit and Local according to the following table:
	//       |       || Update |
	//  Edit | Local ||  Local | StatusLine | Remarks
	// ------|-------||--------|------------|-----------------
	//    -  |   ?   ||    no  |            | No update
	//    e  |   ?   ||   yes  |            | Clear
	//    A  |   -   ||   yes  |            | Update
	//    A  |   A   ||    no  |            |
	//    B  |   A   ||   yes  |            | Update
	//
	// Then integrate the remaining sources according to the following table:
	//        |          |            || Update |        |   Update   |
	//  Local | Download | CleanLinks ||  Local | Upload | CleanLinks | StatusLine   | Remarks
	// -------|----------|------------||--------|--------|------------|--------------|-------------
	// (downloadLinks == null)
	//   -/e  |     -    |      -     ||    no  |    no  |      no    | [Default]    | Use DefaultLinks
	//    A   |     -    |      -     ||    no  |   yes  |     yes    | [New]        | New Local
	//    -   |     -    |      A     ||   yes  |    no  |      no    | [Clean]      | Use Clean
	//    A   |     -    |      A     ||    no  |    no  |      no    |              |
	//    B   |     -    |      A     ||    no  |   yes  |     yes    |              |
	// (links == null)
	//    -   |     A    |      A     ||   yes  |    no  |      no    | [No Local]   |
	//    -   |     B    |      A     ||   yes  |    no  |     yes    | [No Local]   |
	//    -   |     A    |      -     ||   yes  |    no  |     yes    | [No Local]   | New Download
	// (links_empty)
	//    e   |     A    |      A     ||   yes  |    no  |      no    | [Clear]      |
	//    e   |     B    |      A     ||   yes  |    no  |     yes    | [Clear]      |
	//    e   |     A    |      -     ||   yes  |    no  |     yes    | [No Local]   | New Download
	// (local_download_same)
	//    A   |     A    |      A     ||    no  |    no  |      no    | [Same]       |
	//    B   |     B    |      A     ||    no  |    no  |     yes    | [Same]       |
	//    A   |     A    |      -     ||    no  |    no  |     yes    | [Same]       |
	// (else)
	//    A   |     B    |      A     ||   yes  |    no  |     yes    | [Render]     |
	// (local_new)
	//    B   |     A    |      A     ||    no  |   yes  |      no    | [Save Dirty] |
	//    B   |     C    |      A     ||    no  |    no  |      no    | [Conflict]   | Do not render Downloaded
	//    A   |     B    |      -     ||    no  |    no  |      no    | [Conflict]   | Do not update Clean
	let links = Data.readLocalLinks();  //will be updated to final content
	let updateLocal = false, upload = forceUpload, updateClean = false, conflict = false, render = false;

	// Determine how to integrate Edit into Local
	if (editLinks == null) {
		// Case -?: Nothing to update
	} else {
		let e = editLinks.trim();
		if (e == '') {
			// Case e?: Clear Local
			LogLinksUpdate.important('Clear links');
			updateLocal = true;
			links = '';
		} else if (links == null || e != links.trim()) {
			// Case A-, BA: Update Local
			LogLinksUpdate.important('Update links with edits');
			updateLocal = true;
			links = editLinks;
		} else {
			// Case AA: Nothing to update
		}
	}
	let links_empty = links != null && links.trim() == '';

	// Derive if Local and Download have changed wrt to Clean
	// xxx_changed is true when it is changed wrt to Clean and Clean is set.
	// xxx_new is true when it is changed wrt to Clean which may be null.
	let local_changed = false, download_changed = false;  //when Clean!=null
	let local_new = false, download_new = false;  //when Clean==null
	let cleanLinks = Data.readCleanLinks();
	if (cleanLinks != null) {
		let clean_tr = cleanLinks.trim();
		download_changed = downloadLinks != null && downloadLinks.trim() != clean_tr;
		local_changed = links != null && links.trim() != clean_tr;
		download_new = download_changed;
		local_new = local_changed;
	} else {
		download_new = downloadLinks != null;
		local_new = links != null;
	}
	// Derive if Local and Download are the same
	let local_download_same = false;
	if (links == null && downloadLinks == null) {
		local_download_same = true;
	} else if (links != null && downloadLinks != null) {
		local_download_same = links.trim() == downloadLinks.trim();
	}

	// Determine how to integrate Download into Local and Clean
	if (downloadLinks == null) {
		// Case ---, e--, --A, A-A, B-A, A--: Not downloaded
		if (cleanLinks == null) {
			// Case ---, e--, A--
			if (links == null || links == '') {
				// Case ---, e--: Use DefaultLinks
				LogLinksUpdate.important('No download, no clean, no local, use default');
				links = DefaultLinks;
				addStatus('Default');
			} else {
				// Case A--: New links
				LogLinksUpdate.important('No download, no clean, new local');
				addStatus('New');
				upload = true;
			}
		} else if (links == null) {
			// Case --A: Use Clean
			links = cleanLinks;
			local_changed = local_new = false;
			addStatus('Clean');
			updateLocal = true;
			upload = true;
		} else if (!local_changed) {
			// Case A-A: Nothing to update
		} else {
			// Case B-A: Update Clean
			LogLinksUpdate.important('No download, but update clean with local');
			upload = true;
		}
	} else if (links == null) {
		// Case -AA, -BA, -A-: There are no local Links
		LogLinksUpdate.important('Downloaded links, no local Links');
		addStatus('No Local');
		updateLocal = true;
		links = downloadLinks;
		if (download_new) {
			// Case -BA, -A-: Update CleanLinks
			updateClean = true;
		}
	} else if (links_empty) {
		// Case eAA, eBA, eA-: Clear local links
		LogLinksUpdate.important('Downloaded links, clear or ignore Links');
		if (cleanLinks == null) {
			addStatus('No Local');
		} else {
			addStatus('Clear');
			Data.writeLocalLinks(null);  //triggers cache update
		}
		updateLocal = true;
		links = downloadLinks;
		if (download_new) {
			// Case eBA, eA-: Update CleanLinks
			updateClean = true;
		}
	} else if (local_download_same) {
		// Case AAA, BBA, AA-: local Links same as download Links
		// Note that local Links and download Links null or empty have already been handled
		if (UrlResolver.getLoadOverrideOptions()) {
			// Downloaded from links-override=
			LogLinksUpdate.important('Downloaded links same as local, no need to update');
		} else {
			// Downloaded from links=
			LogLinksUpdate.important('Downloaded links same as local, keep pre-rendered Links');
			addStatus('Same');
		}
		if (download_new) {
			// Case BBA, AA-: Update CleanLinks
			updateClean = true;
		}
	} else {
		// Case ABA, BAA, BCA, AB-: local Links different from download Links
		if (local_new) {
			// Case BAA, BCA, AB-
			if (UrlResolver.getLoadOverrideOptions()) {
				// Downloaded from links-override=
				if (download_new) {
					// Case BCA, AB-: All three are different
					LogLinksUpdate.important('Local Links and downloaded override Links have both changed, use override');
					updateClean = true;
				} else {
					// Case BAA: local Links different from others
					LogLinksUpdate.important('Local Links newer than downloaded override Links, use override')
				}
				addStatus('Discard Local changes');
				updateLocal = true;
				links = downloadLinks;
			} else {
				// Downloaded from links=
				if (download_new) {
					// Case BCA, AB-: All three are different
					LogLinksUpdate.important('Local Links and downloaded Links have both changed, display local');
					if (forceUpload) {
						LogLinksUpdate.important('Force Update');
						update = true;
					} else {
						LogLinksUpdate.important('Local Links and downloaded Links have both changed, display local');
						addStatus('Conflict');
						conflict = true;
					}
				} else {
					// Case BAA: local Links different from others
					LogLinksUpdate.important('Local Links newer than downloaded, use local Links');
					addStatus('Save Dirty');
					upload = true;
				}
			}
		} else {
			// Case ABA: download Links different from others
			LogLinksUpdate.important('Downloaded Links newer than local, use downloaded Links');
			updateLocal = true;
			links = downloadLinks;
			updateClean = true;
			// Check later against DisplayedLinks whether to render
		}
	}

	// Determine what to display
	if (links != null) {
		let alreadyDisplayed;
		let displayedLinks = Data.getDisplayedLinks();
		if (displayedLinks == null) {
			// Currently nothing displayed
			alreadyDisplayed = false;
		} else {
			if (links.trim() != displayedLinks.trim()) {
				// The new Links are different from the currently displayed
				alreadyDisplayed = false;
			} else {
				LogLinksUpdate.log('New Links same as already displayed, do not re-render');
				alreadyDisplayed = true;
			}
		}
		if (!alreadyDisplayed) {
			// The new Links are different from the currently displayed
			parseLinks(links);  //throws exception if invalid
			LogLinksUpdate.log('New Links are valid');
			render = true;
		}
	}

	// Update status
	if (render) {
		// Stop pre-render
		if (preRenderCancel) preRenderCancel.setReturn(true);
	}
	if (conflict) {
		updateSettingsConflict(true);
	}
	if (updateLocal) {
		LogLinksUpdate.log('Update LocalLinks');
		Data.writeLocalLinks(links);
	}
	if (updateClean) {
		LogLinksUpdate.log('Update CleanLinks');
		Data.writeCleanLinks(links);
		updateSettingsConflict(false);
	}
	if (render) {
		addStatus('Render');
		processLinks(links);
		Data.setDisplayedLinks(links);
	}
	if (upload) {
		if (UrlResolver.getSaveOptions()) {
			uploadLinks(links);  //will set CleanLinks after successful upload
		} else {
			LogLinksUpdate.log('No SaveOptions, cannot upload');
			updateSettingsConflict(false);  //no SaveOptions, no display conflict
		}
	}
}

// Download new configuration, integrate it with the current Data and update
// display if necessary.
// Arguments:
// - editLinks: Update for LocalLinks, null if no change, '' to clear.
// - forceUpload: True if the caller already determined that the configuration
//   should be uploaded.
// - preRenderCancel: Object to cancel ongoing pre-render, null if not set.
// - fallbackRender: Function to call to render the fallback contents.
// Returns Promise that resolves when ready or false if no download.
function downloadUpdateLinks(editLinks, forceUpload, preRenderCancel, fallbackRender) {
	if (HOOK_Ready != null) HOOK_Ready.start();
	if (editLinks === '') Data.writeLocalLinks(null);
	let loadPromise = downloadLinks();
	if (loadPromise != null) {
		let result = new PendingPromise();
		loadPromise
		.then(download => {
			// Links have been downloaded successfully
			if (download == null && UrlResolver.getLoadOverrideOptions()) {
				fallbackRender('File does not exist');
			} else {
				updateLinks(editLinks, download, forceUpload, preRenderCancel);
			}
			result.resolve(true);
			if (HOOK_Ready != null) HOOK_Ready.stop();
		})
		.catch(error => {
			if (error === false) {
				if (fallbackRender) {
					fallbackRender('Download failed');
					result.resolve(true);
				} else {
					LogLinksUpdate.log('Could not download');
					result.reject('Could not download');
				}
			} else if (error instanceof UserInputError) {
				// It is a UserInputError, trigger reject, because
				// the user can fix it.
				LogLinksUpdate.log('Download failed with UserInputError');
				result.reject(error);
			} else {
				// It is another error, log it for debugging, but
				// do a resolve, so that no dialog is triggered.
				LogLinksUpdate.error('Download failed with error', error);
				result.resolve(false);
			}
			if (HOOK_Ready != null) HOOK_Ready.stop();
		});
		return result;
	} else {
		// No download, go straight to fallback
		addStatus('No Download');
		if (fallbackRender) {
			fallbackRender('No download');
		} else if (editLinks === '') {
			LogLinksUpdate.log('Clear, but nothing to download, use default');
			let links = UrlResolver.getFallbackLinks();
			if (links == null) links = DefaultLinks;
			processLinks(links);  //throws exception if invalid
			Data.writeLocalLinks(links);
			Data.setDisplayedLinks(links);
		} else {
			LogLinksUpdate.log('Nothing to download, no fallback');
		}
		if (HOOK_Ready != null) HOOK_Ready.stop();
		return Promise.resolve(false);
	}
}

// Create object that can be called as a function. The return value of the
// function can be set with the setReturn() method.
// This object can be used as 'cancel' argument for processLinks().
function CreateCancel() {
	let cancel = false;  //default value
	let retval = () => cancel;  //returns a function that returns cancel
	retval['setReturn'] = (value) => cancel = value;  //extra method
	return retval;
}

// Load the Links and render them.
// This function returns a Promise to communicate when it's done or if there
// are exceptions.
function initLinks() {
	// NOTE: The intention is to start 2 Promises, one doing the rendition
	// of the preliminaryLinks and a second doing the download. As soon as
	// the download has finished and the result is different, the
	// preliminary render is cancelled and a new rendition is started.
	//
	// Unfortunately, this is not how JavaScript Promises work. It seems
	// like Promises are like co-operative multi-tasking and each Promise
	// has to yield control in order for other Promises to progress.
	// Since the processLinks() doesn't need to wait, it does not yield by
	// itself. It could be made to in the cancel() call, but I have not
	// found a way to yield control manually.
	// Surprisingly, also the downloading does not yield control.
	// This means that the first Promise will finish before the second and
	// preliminary rendition and downloading is not done in parallel.
	// I tried the following:
	// - Use fetch() for download, but that does not yield either
	// - Place preliminary render in a setTimeout() with value 1ms to
	//   forcibly yield. This works in the sense that the download is
	//   started, but as soon as the render gets control again, it doesn't
	//   let go anymore.

	// Start rendering preliminaryLinks (if defined)
	let preliminaryLinks = UrlResolver.getPreliminaryLinks();
	let preliminaryLinksCancel = null;
	//LogInit.devlog('preliminaryLinks = ', preliminaryLinks);
	if (preliminaryLinks != null) {
		if (HOOK_Ready != null) HOOK_Ready.start();
		Data.setDisplayedLinks(preliminaryLinks);
		preliminaryLinksCancel = CreateCancel();
		let preliminaryLinksRenderPromise = new Promise((resolveFunc, rejectFunc) => {
			// Use a short timeout to give the download a chance to start
			// so that the response will be received asap after the
			// preliminary render is done (since processLinks() does not
			// yield control).
			setTimeout(() => {
				LogInit.important('Start processing preliminaryLinks');
				addStatus('Pre-render');
				processLinks(preliminaryLinks, preliminaryLinksCancel);
				if (preliminaryLinksCancel()) {
					LogInit.important('preliminaryLinks have been cancelled');
				} else {
					LogInit.important('preliminaryLinks finished successfully');
				}
				if (HOOK_Ready != null) HOOK_Ready.stop();
				resolveFunc();
			}, 50);
		});
	}

	// Helper function to render fallbackLinks, logging the reason.
	function handleFallbackLinks(reason) {
		let fallbackLinks = UrlResolver.getFallbackLinks();
		if (fallbackLinks != null) {
			let displayedLinks = Data.getDisplayedLinks();
			if (displayedLinks == null || fallbackLinks.trim() != displayedLinks.trim()) {
				LogInit.important(reason + ', use fallback Links');
				addStatus('Render fallback');
				processLinks(fallbackLinks);  //throws exception if invalid
				Data.writeLocalLinks(fallbackLinks);
				Data.setDisplayedLinks(fallbackLinks);
			} else {
				LogInit.important(reason + ' and fallback same as displayed, keep displayed Links');
			}
		} else {
			LogInit.important(reason + ', keep preliminary Links');
		}
	}

	// Start download (if defined)
	return downloadUpdateLinks(null, false, preliminaryLinksCancel, handleFallbackLinks);
}

// Initialize the JavaScript on the page
function init() {
	if (HOOK_Init != null) HOOK_Init();
	initStatus();
	initSettingsPanel();
	if (HOOK_Run != null) {
		HOOK_Run();
	} else {
		initLinks()
		.catch(error => {
			// There is an error, report and open Settings
			// Always log for debugging
			LogInit.error(error);
			if (error instanceof UserInputError) {
				// It is a UserInputError, show a dialog,
				// and open Settings, because the user can fix it.
				window.alert('Error when loading settings: ' +
					error.message +
					'\n\nPlease correct or cancel.');
				showSettingsPanel();
			} else {
				// It is another error, discard it, because
				// it has already been logged.
			}
		});
	}
}
window.onload = init;

// }}}
</script>

</head>

<body class="dark-theme">

<h1 id="Title">Favorites</h1>

<span id="SettingsIconBar" class="settings-iconbar">
<div id="SettingsIconBarClosed"></div>
<div id="SettingsIconBarOpen" class="hidden"></div>
</span>

<form id="SettingsForm" class="settings-form">
  <div class="panel">
    <div id="SettingsArea" class="client"></div>
  </div>
  <hr>
</form>

<form id="SearchForm" class="search-form hidden">
  Search:
  <input id="SearchBox" name="q" type="text" inputmode="search" autocorrect="off" autocapitalize="off" autocomplete="off" size="40" class="textbox"/>
  <span id="SearchButtons"></span>
</form>

<div id="LinksBox"></div>

<div id="StatusLine" class="status-line">STATUS</div>

</body>

</html>

<!-- vim: set fdm=marker: -->

