<!DOCTYPE html>
<html>

<!--
For description of this file, see README.md
For syntax description of Links, see help.html
-->

<head>

<!-- This page may contain UTF-8 encoded text, especially in the Links definition. -->
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>Favorites</title>

<style>
/* CSS styles {{{ */

/****************************************************************************
 * Global definitions
 ****************************************************************************/

/* Color palette - dark theme */
.dark-theme {
	--foreground: #DDDDDD;
	--background: #2E323B;
	--accent-color: #50A0EE;
	--block-foreground: #000000;
	--block-background: #C9CDD0;
	--block-border: #EEEEEE;
	--selection-foreground: #000000;
	--selection-background: #DDDDFF;
	--code-foreground: #FFFFFF;
	--code-background: #292D36;
	--link-color: #6666FF;
	--disabled-color: #888888;
	--error-foreground: #FF6600;
	--error-background: #FFD8C0;
	--error-border: var(--error-foreground);
}

/* Color palette - light theme */
.light-theme {
	--foreground: #444444;
	--background: #E8F0F8;
	--accent-color: #4444EE;
	--block-foreground: #222222;
	--block-background: #D9DDE0;
	--block-border: #666666;
	--selection-foreground: #FFFFFF;
	--selection-background: #000099;
	--code-foreground: #000000;
	--code-background: #E3EBF3;
	--link-color: #2222AA;
	--disabled-color: #888888;
	--error-foreground: #FF8844;
	--error-background: #FFEEDD;
	--error-border: #FFBB88;
}

:root {
	/* Define variables that will be used on visible elements */
	--font-family: 'Segoe UI', 'Lucida Grande', Helvetica, sans-serif;
	--font-size: 100%
	/* Set default font and size */
	font-family: var(--font-family);
	font-size: 12pt;  /* absolute, so --font-size can be relative too */
	scrollbar-width: thin;
}


/****************************************************************************
 * Resizing for mobile devices
 ****************************************************************************/

/*
https://www.w3schools.com/css/css_rwd_mediaqueries.asp advices the following sizes:
- max-width=600px: Extra small devices (phones)
- min-width=600px: Small devices (portrait tablets and large phones)
- min-width=768px: Medium devices (landscape tablets)
- min-width=992px: Large devices (laptops/desktops)
- min-width=1200px: Extra large devices (large laptops and desktops)

https://www.w3schools.com/cssref/css_units.php makes the following recommendations:
- Use relative lengths (em, %, rem, vw, vh) for screen display.
- Use absolute lengths (cm, px, pt) for print display.
- Pixels (px) are only literal pixels for low-dpi devices. For high-dpi
  devices, 1px is multiple physical pixels.
  The ratio of physical to logical pixels can be retrieved in JavaScript with
  window.devicePixelRatio;
- Here it defines: 1in = 2.54cm = 25.4mm = 72pt = 6pc = 96px

https://stackoverflow.com/questions/8785643/what-exactly-is-device-pixel-ratio describes the direct use of device-pixel-ratio in CSS:
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	only screen and (min--moz-device-pixel-ratio: 1.5),
	only screen and (-o-device-pixel-ratio: 3/2),
	only screen and (min-device-pixel-ratio: 1.5) {
	... high-resolution screens ...
}

Also, disable automatic text-sizing, because that determines the font-size
for each block independently.
*/
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	only screen and (min--moz-device-pixel-ratio: 1.5),
	only screen and (-o-device-pixel-ratio: 3/2),
	only screen and (min-device-pixel-ratio: 1.5) {
	/* high-resolution screens */
	:root {
		/* Make text bigger, because otherwise it gets too small on
		   phones. (I'm not sure why, because 12pt should be the same
		   absolute size on every screen. */
		font-size: 18pt;
	}
	html {
		text-size-adjust: none;
		-moz-text-size-adjust: none;
		-webkit-text-size-adjust: none;
	}
	input[type=checkbox] {
		/* For mobile, make checkboxes bigger with more padding for fat fingers. */
		transform: scale(2);
		margin: 0.7em;
		position: relative; left: -0.5em;
	}
	/* For some reason, the right-hand side of the items is hidden (if overflow=clip it
	   *is* shown, but then the animation does not work correctly. Also using another
	   unit besides fr makes the animation not work correctly.
	   Since this only happens on mobile (I tested Firefox as well as Chrome on Android),
	   I can force a bit of extra padding on the block-items level.
	   I also tested if the font-adjustment had any influence. It didn't. */
	.block-items {
		padding-right: 1em;
	}
}

body, input, textarea, button {
	font-family: var(--font-family);
	font-size: var(--font-size);
}

body {
	color: var(--accent-color); background: var(--background);
}
::selection {
	color: var(--selection-foreground); background: var(--selection-background);
}

.normal {
	color: var(--foreground);
}
.alert {
	color: var(--error-foreground);
}
.accent {
	color: var(--accent-color);
}
.hidden {
	display: none;
}
.alert-box {
	color: var(--foreground);
	margin: 1em 3em 0.5em;
	padding: 0.5em 1em;
	border-left: 0.2em solid var(--error-foreground);
}
.alert-box .label {
	color: var(--error-foreground);
}


/****************************************************************************
 * Shared styles for displaying text-blocks
 * These syles are shared between all pages
 ****************************************************************************/

.text-block {
	color: var(--foreground); background: var(--background);
}
.text-block h1, .text-block h2, .text-block h3, .text-block dt {
	color: var(--accent-color);
}
.text-block code, .text-block pre {
	color: var(--code-foreground); background: var(--code-background);
}
.text-block code {
	padding: 0.1em 0.4em;
}
.text-block pre {
	padding: 0.6em 1em;
	margin: 0.5em 4em;
	overflow: scroll;
}
.text-block dt {
	display: inline;
}
.text-block a {
	color: var(--link-color);
	text-decoration: none;
}
.text-block a:hover {
	text-decoration: underline;
}
.text-block .important {
	color: var(--error-foreground);
}


/****************************************************************************
 * Section styles
 ****************************************************************************/

.section {
	display: block;
}


/****************************************************************************
 * Block styles
 ****************************************************************************/

.block {
	display: inline-block;
	vertical-align: top;
	border: .15em solid var(--block-border);
	border-radius: 0.5em;
	padding: 1em;
	margin: 0.5em;
	color: var(--block-foreground); background: var(--block-background);
}
.items {
	margin-left: 2em;
}
.block-items {  /* First indentatiion level in a Block (kind-of like the title of a Block) */
	margin-left: 0.5em;
}


/****************************************************************************
 * Item and SubItem styles
 ****************************************************************************/

.item {
	display: block;
	padding: 0.1em;
}

.strong {
	& .delim-open, & .delim-close {
		font-size: 80%;
		letter-spacing: -0.1em;
		visibility: hidden;
	}
	& .delim-text {
		font-weight: bold;
	}
}
.strong:hover {
	& .delim-open, & .delim-close {
		visibility: visible;
	}
}

/* Item Groups for continuation */

.group .item {
	display: inline;
	margin-left: 0.4em;
}
.group .item:first-child {
	margin-left: unset;
}

/* Item Checkboxes */

.todo-checkbox {
	margin-right: 0.2em;
}
.todo-checkbox:checked {
}
.checkbox-label {
}
.checkbox-label.checked {
	color: var(--disabled-color);
	text-decoration: line-through;
}

.custom-checkbox {
	display: inline-block;
	cursor: default;
	/* Add padding to the left, so that icon is not cut off when transformed bigger */
	padding-left: 0.2em;
	padding-right: 0.2em;
	transition: transform 0.05s ease-out;  /* used when hover -> not-hover */
}
.custom-checkbox:hover {
	transform: scale(1.2);
	transition: transform 0.2s ease-out;  /* used when not-hover -> hover */
}
.custom-checkbox .text-icon {
	transform: scale(1.7);
}
.custom-checkbox img.text-icon {
	transform: scale(1.4);
}
.checkbox-label.not-first-option {
}

.any-parent-checked {
}
.any-child-checked {
}
.self-checked {
}
.any-child-checked:not(.self-checked) {
}

/* Item Icons */

.item-icon {
	width: 1.0em; height: 1.0em;
	margin-right: 0.2em;
	vertical-align: -10%;
}
.link .item-icon {
	vertical-align: -15%;
}
.items > .item {  /* selects all non-grouped elements */
}
.link {  /* selects all links */
}
.items > .item .link {  /* selects all non-grouped links */
	vertical-align: 15%;
}
.items > .group > .item .link {  /* selects all grouped links */
}
.text-icon {
	display: inline-block;
	padding: 0em;
	text-decoration: none;
}
.text-icon div {
	position: relative;
	margin: 0em; padding: 0em;
	transform-origin: 0 0;
}

/* Item Separator */

.item .separator {
	margin: 0em -1em 0em -1em;
}


/****************************************************************************
 * Search Form
 ****************************************************************************/

.search-form .textbox {
	font-size: 110%;
}
.search-form .button {
	margin: 0.3em;
}
.search-form .button .item-icon {
	width: 1.5em; height: 1.5em;
	vertical-align: -25%;
}
.search-form .button .label {
	margin: 0em 0.3em;
}


/****************************************************************************
 * Settings Form
 ****************************************************************************/

.settings-iconbar {
	position: absolute;
	top: 10px; right: 10px;
	text-align: right;
}
.settings-icon {
	font-size: 200%;
	cursor: pointer;
	padding: 0px 0.1em;
}
/* Zoom on hover */
.settings-icon {
	display: inline-block;
	height: 1.5em;
	/* Default transform-origin is the center of the bounding box. With
	   this height, this center matches the caracter center. */
	transition: transform 0.3s ease-out;
}
.settings-icon:hover {
	transform: scale(1.3);
}
.settings-icon:active {
	transform: scale(1);
	/* After activation, do the transition quickly, so that it better
	   combines with the following buttonbar animation. */
	transition: transform 0.1s ease-out;
}

.settings-form {
	overflow: hidden;
	display: grid;
	grid-template-rows: auto max-content;
}
.settings-form .panel {
	height: 49em;
	overflow: auto;
}
.settings-form .client {
	width: 95%;
}
.settings-form .textbox {
	width: 100%;
	height: 46em;
	resize: both;
	overflow: scroll;
	color: var(--foreground); background: var(--background);
	font-family: monospace;
}
.settings-form .buttonbar {
	text-align: right;
}
.settings-form .button {
	margin: 0.3em;
}

.settings-form .options {
	display: grid;
	gap: 1em;
	grid-template-columns: max-content auto;
	padding: 1em 1em 1em 0.2em;
}
.input input {
	width: 100%;
}


/****************************************************************************
 * Status line
 ****************************************************************************/

.status-line {
	font-size: 80%;
	color: var(--background);
	background: var(--background);
}
.status-line.visible {
	color: var(--foreground);
}
.status-line:hover {
	background: color-mix(in hsl, var(--background), #777 20%);
}


/****************************************************************************
 * blink animation
 ****************************************************************************/

.blink {
	border: .15em solid transparent;
	animation: 500ms 4 blinker;
}
@keyframes blinker {
	30% {
		color: var(--error-foreground);
		background-color: var(--error-background);
		border-color: var(--error-border);
	}
}


/****************************************************************************
 * settings-form and settings-iconbar animation
 ****************************************************************************/

.settings-form {
	display: none;
	height: 50em;
}
.settings-form.show {
	display: block;
}
.settings-form.expanding {
	animation: 700ms ease settings-form-grow;
}
.settings-form.collapsing {
	animation: 700ms ease reverse settings-form-grow;
}
@keyframes settings-form-grow {
	0% {
		height: 0em;
	}
	100% {
		height: 50em;
	}
}
.settings-form.expanding .client {
	animation: 700ms ease settings-form-scale;
}
.settings-form.collapsing .client {
	animation: 700ms ease reverse settings-form-scale;
}
@keyframes settings-form-scale {
	0% {
		transform: scaleY(0);
		transform-origin: top;
	}
	100% {
		transform: scaleY(1);
		transform-origin: top;
	}
}

.settings-iconbar .slide-in {
	animation: 200ms ease-in settings-iconbar-slider;
}
.settings-iconbar .slide-out {
	animation: 200ms ease-out reverse settings-iconbar-slider;
}
@keyframes settings-iconbar-slider {
	0% {
		transform: scale(0, 0.4);
		transform-origin: right;
	}
	100% {
		transform: scale(1, 1);
		transform-origin: right;
	}
}


/****************************************************************************
 * slider-container and resize-button animation
 ****************************************************************************/

/* Note: On Firefox, if all collapsing/expanding animations do not take the
   same amount of time, it becomes jerky. Therefore, use the same amount of
   time and arrange different animation speeds with the @keyframes. */

.slider-container {
	/* As described in https://keithjgrant.com/posts/2023/04/transitioning-to-height-auto/,
	   animating height to height:auto is not always possible, e.g. on Firefox. A solution
	   is to animate grid-template-rows and add an extra intermediate <div>. */
	display: grid;
	grid-template-rows: 1fr;
	grid-template-columns: 1fr;
}
.slider-container > * {  /* the slider-container items */
	overflow: hidden;
	white-space: nowrap;
	/* For the grow animation, the grid-item must have overflow:hidden,
	   otherwise the container's size is not shrunk.
	   In this setup, the size of the container and its single item is
	   always the same. For Firefox on Linux, there is a quirk where the
	   width of the container is about 1em smaller than the container and
	   because of the overflow:hidden, this part is removed.
	   It works to add 1em padding to the item and compensate this with
	   -1em margin, so that the total width is the same.
	   This behavior can be made visible by adding 1px borders to
	   .slider-container and its items. */
	padding-right: 1em;
	margin-right: -1em;
}
.collapsing .slider-container {
	animation:
		400ms ease-out reverse block-expanding-x,
		400ms ease-out reverse block-expanding-y;
}
.expanding .slider-container {
	animation:
		400ms ease-out block-expanding-x,
		400ms ease-out block-expanding-y;
}
.collapsed .slider-container {
	grid-template-rows: 0fr;
	grid-template-columns: 0fr;
}
@keyframes block-expanding-x {
	0% {
		grid-template-columns: 0fr;
	}
	60%, 100% {
		grid-template-columns: 1fr;
	}
}
@keyframes block-expanding-y {
	0%, 20% {
		transform: scaleY(0);
		transform-origin: top;
		grid-template-rows: 0fr;
	}
	100% {
		transform: scaleY(1);
		transform-origin: top;
		grid-template-rows: 1fr;
	}
}

/* resize-button animation */

.resize-icon {
	float: right;
	position: relative;
	top: -0.9em; right: -0.6em;
	cursor: pointer;
	color: var(--disabled-color);
	transform: rotate(90deg);
}
.collapsing .resize-icon {
	animation: 400ms ease animate-resize-icon;
}
.expanding .resize-icon {
	animation: 400ms ease reverse animate-resize-icon;
}
.collapsed .resize-icon {
	color: var(--block-foreground);
	transform: rotate(0deg);
}
@keyframes animate-resize-icon {
	0%, 30% {
		color: var(--disabled-color);
		transform: rotate(90deg);
	}
	70%, 100% {
		color: var(--block-foreground);
		transform: rotate(0deg);
	}
}

/* }}} */
</style>

<script>
// Some constants {{{

// Unicode Plane: Basic Multilingual Plane (U+0000 - U+FFFF)
// Unicode Block: Arrows
const UNICODE_LEFTWARDS_ARROW_WITH_HOOK = '\u{21A9}';  //a 'swoosh' arrow
const UNICODE_RIGHTWARDS_ARROW_WITH_HOOK = '\u{21AA}';  //a 'swoosh' arrow
const UNICODE_ANTICLOCKWISE_TOP_SEMICIRCLE_ARROW = '\u{21B6}';  //a 180 degree arc
const UNICODE_CLOCKWISE_TOP_SEMICIRCLE_ARROW = '\u{21B7}';  //a 180 degree arc
const UNICODE_ANTICLOCKWISE_OPEN_CIRCLE_ARROW = '\u{21BA}';  //a 270 degree arc
const UNICODE_CLOCKWISE_OPEN_CIRCLE_ARROW = '\u{21BB}';  //a 270 degree arc
// Unicode Block: Geometric Shapes
const UNICODE_WHITE_SQUARE_CONTAINING_BLACK_SMALL_SQUARE = '\u{25A3}';  //checkbox with square
const UNICODE_BLACK_DOWN_POINTING_TRIANGLE = '\u{25BC}';
const UNICODE_BLACK_RIGHT_POINTING_TRIANGLE = '\u{25B6}';
// Unicode Block: Miscellaneous Symbols
const UNICODE_BALLOT_BOX = '\u{2610}';  //empty checkbox
const UNICODE_BALLOT_BOX_WITH_CHECK = '\u{2611}';  //checked checkbox
const UNICODE_BALLOT_BOX_WITH_CROSS = '\u{2612}';  //crossed checkbox
const UNICODE_GEARS = '\u{2699}';  //gears wheel
// Unicode Block: Dingbats
const UNICODE_CHECK_MARK = '\u{2713}';
const UNICODE_HEAVY_CHECK_MARK = '\u{2714}';
const UNICODE_CROSS_MARK = '\u{274C}';  //cross
// Unicode Block: Variation Selectors
const UNICODE_VARIATION_SELECTOR_15 = '\u{FE0E}';  //suffix to use text-character, rather than (colored) image
// Unicode Block: Specials
const UNICODE_REPLACEMENT_CHARACTER = '\u{FFFD}';  //character used for non-mappable characters
const UNICODE_NOT_A_CHARACTER_1 = '\u{FFFE}';  //character without representation
const UNICODE_NOT_A_CHARACTER_2 = '\u{FFFF}';  //character without representation

// Unicode Plane: Supplementary Multilingual Plane (U+10000 - U+1FFFF)
// Unicode Block: Miscellaneous Symbols and Pictographs
const UNICODE_LEFT_POINTING_MAGNIFYING_GLASS = '\u{1F50D}';
const UNICODE_RIGHT_POINTING_MAGNIFYING_GLASS = '\u{1F50E}';
const UNICODE_FLOPPY_DISK = '\u{1F4BE}';  //colored floppy disk
const UNICODE_BLACK_HARD_SHELL_FLOPPY_DISK = '\u{1F5AA}';  //black&white 3½" floppy disk
const UNICODE_WHITE_HARD_SHELL_FLOPPY_DISK = '\u{1F5AB}';  //black&white 3½" floppy disk
const UNICODE_SOFT_SHELL_FLOPPY_DISK = '\u{1F5AC}';  //black&white 5¼" floppy disk
const UNICODE_EMPTY_DOCUMENT = '\u{1F5CB}';
const UNICODE_CANCELLATION = '\u{1F5D9}';  //cross
const UNICODE_LIGHT_CHECK_MARK = '\u{1F5F8}';

// DefaultLinks is a textual part with a copy of example-links.txt at the end.
const DefaultLinks = `// For the syntax description, see help.html.

!title Example Favorites

!text
<a name="description"></a>
<h2>Description</h2>

<p>
<a href="favorites.html">favorites.html</a> is a single page that can be
configured to show <u>links</u> and <u>todo lists</u>, organized in
<u>sections</u>, <u>blocks</u> and <u>items</u>. This configuration can be
downloaded via a URL and/or edited in the browser's LocalStorage (see below).
<br>
This page can be set as home page in the browser's settings and as the Tab
start page via an add-on like <a
href="https://addons.mozilla.org/en-US/firefox/addon/new-tab-override/">New Tab
Override</a>.
</p>
!endtext

Section

!text
<p>
The configuration consists primarily of a list of <a
href="help.html#link-syntax">Link Definitions</a>.  The Links form an
hierarchical structure, indicated by the line's indentation:
<ul>
<li><dt>Section</dt>: The first indentation level is the Section. Sections are
    separated by horizontal lines.
<li><dt>Block</dt>: The second indentation level are the blocks within a
    Section. Each Block is a visual area that can be collapsed and expanded.
<li><dt>Item</dt>: The third indentation level are the Items that populate
    the Blocks.
<li><dt>SubItem</dt>: The fourth and higher indentation levels are SubItems
    that are displayed under their respective parent Items
</ul>
</p>
!endtext

    Block
        Item
            SubItem
                SubSubItem
                SubSubItem
                    ...
            SubItem
        Item
            SubItem

!text
<p>
Each link can be a hyperlink, have an icon and/or a checkbox.
</p>
!endtext

!text
<a name="usage"></a>
<h2>Usage</h2>

<p>
The standard usage is to open the page favorites.html (or possibly set it as
your home page). Upon first opening, it shows a default example page.  This
page can be edited by going to the Settings (gears (&#x2699;) icon) and just
edit and save the textual configuration. Optionally, this configuration can be
maintained in a separate text file and copy-pasted into the Settings.
<br>
Since GitHub provides for a way to serve HTML pages directly, this can be used
to open and use favorites.html directly from <a
href="https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html">GitHub</a>.
Save the target of this link to your home page and you're set.
</p>

<p>
See <a href="help.html#usage">Help</a> for more information on how to use a
separate URL to retrieve the configuration.
</p>

<p>
In addition to Links, the configuration also supports comments, different
web-search functions and other directives, see <a
href="help.html#line-syntax">Line Syntax</a> for further details.
</p>
!endtext

Examples

!text
<p>
These are some examples of the available features.
</p>
!endtext

    Search
        DuckDuckGo https://duckduckgo.com
        Google Maps https://maps.google.com
        Wikipedia https://www.wikipedia.org
        YouTube https://www.youtube.com
    Source
        GitHub favorite-links https://github.com/anne-gert/favorite-links
            Use favorites.html https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html
            Example Links override https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html&links-override=example-links.txt
            Help https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/help.html
        Firefox
            Home page settings icon=firefox target=manual about:preferences#home
            Plugins
                New Tab Override https://addons.mozilla.org/en-US/firefox/addon/new-tab-override/
    To Do
        Shopping
            [ ] Books
            [x] Presents
        At work
            [x] icon=firefox Install Firefox https://www.mozilla.org/firefox/download
            [ ] icon=github Start using *favorite-links* as **todo-list**
            []  icon=empty Write review
                & Goto Blog icon=none url=https://blog.example.com
        Poll
            [ ]:3 I like shapes
                [ ]:3 Square
                [ ]:3 Circle
                [ ]:3 Triangle
            [ ]:yesno Yes or No
    Socials
        Facebook https://www.facebook.com
            Instagram https://www.instagram.com/
            WhatsApp Web https://web.whatsapp.com/
        ---
        LinkedIn https://www.linkedin.com/

// Icon definitions
!icondef maps.google.com        alt
!icondef html-preview.github.io github
!icondef firefox                https://www.mozilla.org/media/img/favicons/firefox/browser/favicon.ico
!icondef github                 https://github.com

// Checkbox definitions
!checkbox 3 uncheck check mcheck
!checkbox yesno _=U+2753 yes=U+1F44D no=U+1F44E

// Search button definitions
//      Identifier   | Label  | Tooltip | Icon | URL-Template
!search Duck Duck Go | Search |
!search Wikipedia
!search YouTube
!search Google Maps  | Maps
`;

// }}}

// Utility Functions {{{

// Add extra logging function.
// To make important steps stand out more.
console.important = (message) => {
	console.log('%c' + message, 'color:cyan;font-weight:bold');
}

// Add extra logging function.
// To make distinction between log links and less important debug messages.
console.debug = (message) => {
	console.log('%c' + message, 'color:#666666;font-weight:bold');
}

// Add extra logging function. For temporary use only.
// To make logging during development easier to find.
console.devlog = (message) => {
	console.log('%c' + message, 'color:black;background-color:#008888');
}

// Constructor function to construct a Promise in a pending state with
// additional functions resolve(value) and reject(error) to settle it.
function PendingPromise()
{
	let resolve, reject;
	let result = new Promise((resolveFunc, rejectFunc) => {  //Promise in pending state
		// Expose callbacks to be called later
		resolve = resolveFunc;
		reject = rejectFunc;
	});
	result['resolve'] = resolve;
	result['reject'] = reject;
	return result;
}

// Unicode Support {{{

// Function to detect if a unicode character is supported by the specified font.
// - character: Character to test.
// - font: Font to test. Defaults to font as specified for the body.
// - recursion is for internal use.
// Return true if supported, false if not.
function characterIsSupported(character, font = null, recursion = false) {
	// This function is copied from https://stackoverflow.com/questions/1911000/detecting-individual-unicode-character-support-with-javascript

	// This function creates a referenceCanvas with the character U+FFFF,
	// which does not have a representation.
	// It then creates the testCanvas with the character to test.
	// The final test is to see if both canvases are the same (by testing
	// the contents of the BASE64 data: URL). If they are the same, the
	// test character cannot be represented either.

	if (font === null) font = getComputedStyle(document.body).fontFamily;

	const Debug = false;
	const Transparent = false;

	// Create the canvases
	let testCanvas = document.createElement('canvas');
	let referenceCanvas = document.createElement('canvas');
	testCanvas.width = referenceCanvas.width = testCanvas.height = referenceCanvas.height = 100;
	if (Debug) {
		testCanvas.style.backgroundColor = referenceCanvas.style.backgroundColor = 'magenta';
		testCanvas.style.margin = referenceCanvas.style.margin = '10px';
	}

	// Render the characters
	let testContext = testCanvas.getContext('2d');
	let referenceContext = referenceCanvas.getContext('2d');
	testContext.font = referenceContext.font = '100px ' + font;
	testContext.fillStyle = referenceContext.fillStyle = 'black';
	testContext.fillText(character, 0, 100);
	referenceContext.fillText(UNICODE_NOT_A_CHARACTER_2, 0, 100);

	// Firefox renders unsupported characters by placing their character
	// code inside the rectangle making each unsupported character look
	// different.  As a workaround, in Firefox, we hide the inside of the
	// character by placing a black rectangle on top of it.
	// The rectangle we use to hide the inside has an offset of 10px so it
	// can still see part of the character, reducing the risk of false
	// positives.  We check for Firefox and browers that behave similarly
	// by checking if U+FFFE is supported, since U+FFFE is, just like
	// U+FFFF, guaranteed not to be supported.
	if (!recursion && characterIsSupported(UNICODE_NOT_A_CHARACTER_1, font, true)) {
		let fillStyle = Transparent ? 'rgba(0, 0, 0, 0.6)' : 'black';
		testContext.fillStyle = referenceContext.fillStyle = fillStyle;
		testContext.fillRect(5, 5, 90, 90);
		referenceContext.fillRect(5, 5, 90, 90);
	}

	// Check if the canvases are identical
	let displayedSame = testCanvas.toDataURL() == referenceCanvas.toDataURL();

	// Output images at the end of the body for debugging
	if (Debug) {
		var div = document.createElement('div');
		document.body.appendChild(div);
		div.appendChild(document.createTextNode('Character U+' +
			character.charCodeAt(0).toString(16).toUpperCase() +
			', recursion=' + recursion));
		div.appendChild(referenceCanvas);
		div.appendChild(testCanvas);
		div.appendChild(document.createTextNode(displayedSame ? ' => Not supported' : ' => Unique'));
	}

	// Character is not supported if it looks the same as the reference
	return !displayedSame;
}

// Helper function.
// If character is supported by the control, set the property with the
// specified name. Use the control's fontFamily if available.
function setIfSupported(control, character, property = 'textContent') {
	let style = getComputedStyle(control);
	let font = style ? style.fontFamily : null;
	if (!font) font = null;
	let supported = characterIsSupported(character, font);
	if (supported) {
		control[property] = character;
	}
	return supported;
}

// If the control's font supports any of the (unicode) characters, set it in
// the textContent, otherwise use altText.
// This function may test multiple characters and uses the first one that is
// supported. Often Supplementary Multilingual Plane codepoints (U+10000 and
// above) are less supported than lower ones (Basic Multilangual Plan).
// Therefore, try to end with a lower codepoint.
function setUnicodeText(control, unicodeCharacter, /* more unicodeCharacters, */ altText) {
	//console.log('setUnicodeText', arguments);
	for (let i = 1; i < arguments.length - 1; ++i) {
		let ch = arguments[i];
		if (setIfSupported(control, ch)) {
			console.log('setUnicodeText: character #' + i + ' supported: \'' + ch + '\'');
			return;
		}
	}
	// If we get here, none matched. Now set the altText.
	altText = arguments[arguments.length - 1];  //the last argument
	control['textContent'] = altText;
}

// }}}

// General function to add/remove a CSS class for a specified widget.
// If the widget is not defined, do nothing.
// If add==true, add the class, else remove it.
function addClass(widget, className, add) {
	if (widget != null) {
		if (add)
			widget.classList.add(className);
		else
			widget.classList.remove(className);
	}
}

class UserInputError extends Error {
	constructor(message, lineNumber) {
		// Update message
		let fileName = 'configuration';
		if (lineNumber != null) {
			message += ' on line ' + lineNumber;
		}

		// Construct object
		super(message, fileName, lineNumber);
		this.name = 'UserInputError';
	}
}

// }}}

// Links Data {{{

// Global object to hold Links and other data.
const Data = CreateData();

// Function to create the object to hold and maintain the Links data.
// This object uses LocalStorage if available.
// If getResolver is set, call that to get UrlResolvere object. Else,
// UrlResolver is used.
function CreateData(getResolver = () => UrlResolver) {
	const LSKey_Prefix = 'favlist_';

	let storage;
	if (localStorage) {
		storage = localStorage;
	} else {
		// Dummy implementation of LocalStorage
		let data = {};
		storage = {
			getItem : key => data[key],
			setItem : (key, value) => data[key] = value,
			removeItem : key => delete data[key],
		};
	}

	// Read value from Storage.
	// Return value or undefined in case of error or if it does not exist.
	function readStorage(key) {
		console.debug('Read storage key \'' + key + '\'');
		let v = storage.getItem(key);
		return (v != null) ? v : undefined;
	}

	// Store value in Storage.
	// If value is null, empty or whitespace, delete key from Storage.
	function writeStorage(key, value) {
		if (value == null || value.toString().match(/^\s*$/)) {
			console.debug('Remove storage key \'' + key + '\'');
			storage.removeItem(key);
		} else {
			console.debug('Write storage key \'' + key + '\'');
			storage.setItem(key, value);
		}
	}

	// Functions to construct Storage keys
	function getLinksLSKey() {
		return LSKey_Prefix + 'links_' + getResolver().getConfigLoadKey();
	}
	function getCleanLinksLSKey() {
		return LSKey_Prefix + 'clean-links_' + UrlResolver.getConfigLoadKey();
	}
	function getItemExpandedLSKey(itemPath) {
		return LSKey_Prefix + 'expanded_' + getResolver().getConfigLoadKey() + '_' + itemPath;
	}
	function getOptionsLSKey(loadOrSave, configName) {
		if (configName != null) {
			return LSKey_Prefix + loadOrSave + '_' + configName;
		} else {
			return LSKey_Prefix + loadOrSave + '_default';
		}
	}

	// Read/Write Links from Storage.
	// Returns null if not available.
	function readLocalLinks() {
		let key = getLinksLSKey();
		console.log('localLinks: Read from ' + key);
		let links = readStorage(key);
		if (links === undefined) links = null;
		return links;
	}
	function writeLocalLinks(links) {
		let key = getLinksLSKey();
		writeStorage(key, links);
	}

	// Read/Write CleanLinks from Storage. CleanLinks are basically the
	// last downloaded version. This is used as the common ancestor for
	// determining if LocalLinks or newly DownloadedLinks have changed.
	// Returns null if not available.
	function readCleanLinks() {
		let key = getCleanLinksLSKey();
		let links = readStorage(key);
		if (links === undefined) links = null;
		return links;
	}
	function writeCleanLinks(links) {
		let key = getCleanLinksLSKey();
		writeStorage(key, links);
	}

	// Return true if LocalLinks is different from CleanLinks.
	function linksDirty() {
		let localLinks = readLocalLinks();
		localLinks = (localLinks != null) ? localLinks.trim() : '';
		let cleanLinks = readCleanLinks();
		cleanLinks = (cleanLinks != null) ? cleanLinks.trim() : '';
		return localLinks != cleanLinks;
	}

	// Read/write expanded/collapsed status of this itemPath.
	function readItemExpanded(itemPath) {
		let key = getItemExpandedLSKey(itemPath);
		return readStorage(key);
	}
	function writeItemExpanded(itemPath, value) {
		let key = getItemExpandedLSKey(itemPath);
		writeStorage(key, value);
	}

	// Read/Write LoadOverrideOptions from Storage.
	// Return empty string if not set or empty.
	function readLoadOverrideOptions() {
		let configName = getResolver().getLoadOverrideConfigName();
		let key = getOptionsLSKey('load', configName);
		let s = readStorage(key);
		if (s === undefined || s.toString().match(/^\s*$/)) s = '';
		return s;
	}
	function writeLoadOverrideOptions(value) {
		let configName = getResolver().getLoadOverrideConfigName();
		let key = getOptionsLSKey('load', configName);
		writeStorage(key, value);
	}

	// Read/Write LoadOptions from Storage.
	// Return empty string if not set or empty.
	function readLoadOptions() {
		let configName = getResolver().getLoadConfigName();
		let key = getOptionsLSKey('load', configName);
		let s = readStorage(key);
		if (s === undefined || s.toString().match(/^\s*$/)) s = '';
		return s;
	}
	function writeLoadOptions(value) {
		let configName = getResolver().getLoadConfigName();
		let key = getOptionsLSKey('load', configName);
		writeStorage(key, value);
	}

	// Read/Write SaveOptions from Storage.
	// Return empty string if not set or empty.
	function readSaveOptions() {
		let configName = getResolver().getSaveConfigName();
		let key = getOptionsLSKey('save', configName);
		let s = readStorage(key);
		if (s === undefined || s.toString().match(/^\s*$/)) s = '';
		return s;
	}
	function writeSaveOptions(value) {
		let configName = getResolver().getSaveConfigName();
		let key = getOptionsLSKey('save', configName);
		writeStorage(key, value);
	}

	return {
		// Functions to read/write Links
		readLocalLinks : readLocalLinks,
		writeLocalLinks : writeLocalLinks,
		readCleanLinks : readCleanLinks,
		writeCleanLinks : writeCleanLinks,
		linksDirty : linksDirty,

		// Functions to read/write expanded/collapsed state of Items
		readItemExpanded : readItemExpanded,
		writeItemExpanded : writeItemExpanded,

		// Function so read/write Load/Override/Save Options
		readLoadOverrideOptions : readLoadOverrideOptions,
		writeLoadOverrideOptions : writeLoadOverrideOptions,
		readLoadOptions : readLoadOptions,
		writeLoadOptions : writeLoadOptions,
		readSaveOptions : readSaveOptions,
		writeSaveOptions : writeSaveOptions,
	};
}

// }}}

// Resolving Links (UrlResolver) {{{

// Global object to hold the Load- and SaveOptions for the Links.
const UrlResolver = CreateUrlResolver();

// This function retrieves the parameters, parses them and determines which
// URLs to use for loading and saving.
// If queryString is set, that is used, otherwise the current location is used.
// If getData is set, call that to get the persistent storage object. Else,
// Data is used.
// It returns a UrlResolver object with LoadOptions, SaveOptions and URLs.
function CreateUrlResolver(queryString = location.search, getData = () => Data) {
	console.important('Resolving Links source...');

	// Parse links=, links-override= and save= and set internal variables
	// loadOptions, loadOverrideOptions and saveOptions.
	// Return an object to access these.

	// The normal order of sources is:
	// 1) links-override=
	// 2) LocalStorage
	// 3) links=
	//
	// If saveOptions is set, the order of LocalStorage and links= is
	// swapped, resulting in a modified table:
	// 1) links-override=
	// 2) links=
	// 3) LocalStorage

	let params = new URLSearchParams(queryString);
	let loadOverrideArg = params.get('links-override');
	let loadArg = params.get('links');
	let saveArg = params.get('save');
	//console.log(params);
	const reConfigName = /^([^\s\/\\.]+)$/;  //config-name is non-emtpy and contains no space, '/', '\' or '.'

	// Resolve the config names
	let loadOverrideConfigName = null;
	if (loadOverrideArg) {
		let m = loadOverrideArg.match(reConfigName);
		if (m) {
			// This is a config name
			loadOverrideConfigName = m[1];
			console.debug('Found loadOverrideConfigName=' + loadOverrideConfigName);
			// Use the same config name for save unless already set
			if (saveArg == null) saveArg = loadOverrideConfigName;
		}
	}
	let loadConfigName = null;
	if (loadArg) {
		let m = loadArg.match(reConfigName);
		if (m) {
			// This is a config name
			loadConfigName = m[1];
			console.debug('Found loadConfigName=' + loadConfigName);
			// Use the same config name for save unless already set
			if (saveArg == null) saveArg = loadConfigName;
		}
	}
	let saveConfigName = null;
	if (saveArg) {
		let m = saveArg.match(reConfigName);
		if (m) {
			// This is a config name
			saveConfigName = m[1];
			console.debug('Found saveConfigName=' + saveConfigName);
		}
	}

	let _usedLoadConfigName = undefined;
	let _loadName = undefined;

	// Methods to get the correct LocalStorage keys
	function getConfigLoadKey() {
		if (_usedLoadConfigName === undefined || _loadName === undefined) calcDownloadUrl();
		let key = [];
		if (_usedLoadConfigName != null) key.push(_usedLoadConfigName);
		if (_loadName != null) key.push(_loadName);
		return key.join('_');
	}

	// Get the options
	let _loadOverrideOptions = undefined;
	function getLoadOverrideOptions() {
		if (_loadOverrideOptions === undefined) {
			if (loadOverrideConfigName != null) {
				// Read from config
				_loadOverrideOptions = getData().readLoadOverrideOptions();
			} else if (loadOverrideArg != null) {
				_loadOverrideOptions = loadOverrideArg;
			} else {
				_loadOverrideOptions = '';
			}
		}
		return _loadOverrideOptions;
	}
	function setLoadOverrideOptions(value) {
		if (_loadOverrideOptions !== value) {
			console.log('Change _loadOverrideOptions to \'' + value + '\'');
			_loadOverrideOptions = value;
			resetDownloadUrl();
		}
	}

	let _loadOptions = undefined;
	function getLoadOptions() {
		if (_loadOptions === undefined) {
			if (loadConfigName != null) {
				// Read from config
				_loadOptions = getData().readLoadOptions();
			} else if (loadArg != null) {
				_loadOptions = loadArg;
			} else {
				_loadOptions = '';
			}
		}
		return _loadOptions;
	}
	function setLoadOptions(value) {
		if (_loadOptions !== value) {
			console.log('Change _loadOptions to \'' + value + '\'');
			_loadOptions = value;
			resetDownloadUrl();
		}
	}

	let _saveOptions = undefined;
	function getSaveOptions() {
		if (_saveOptions === undefined) {
			if (saveConfigName != null) {
				// Read from config
				_saveOptions = getData().readSaveOptions();
				if (_saveOptions) addStatus('Saveable');
			} else if (saveArg != null) {
				_saveOptions = saveArg;
				addStatus('Saveable');
			} else {
				_saveOptions = '';
			}
		}
		return _saveOptions;
	}
	function setSaveOptions(value) {
		if (_saveOptions !== value) {
			console.log('Change _saveOptions to \'' + value + '\'');
			_saveOptions = value;
			resetDownloadUrl();
			resetUploadUrl();
		}
	}

	// Variables and access methods for the download URL
	let _preliminaryLinks = undefined;
	function getPreliminaryLinks() {
		if (_preliminaryLinks === undefined) calcDownloadUrl();
		return _preliminaryLinks;
	}
	let _loadUrl = undefined;
	function getDownloadUrl() {
		if (_loadUrl === undefined) calcDownloadUrl();
		return _loadUrl;
	}
	let _fallbackLinks = undefined;
	function getFallbackLinks() {
		if (_fallbackLinks === undefined) calcDownloadUrl();
		return _fallbackLinks;
	}
	function getLoadName() {
		if (_loadName === undefined) calcDownloadUrl();
		return _loadName;
	}
	let _downloadHeaders = undefined;
	function getDownloadHeaders() {
		if (_downloadHeaders === undefined) calcDownloadUrl();
		return _downloadHeaders;
	}

	// Reset the download URL variables, so that it gets recalculated when needed
	function resetDownloadUrl() {
		_preliminaryLinks = _loadUrl = _fallbackLinks = _loadName = _downloadHeaders = _usedLoadConfigName = undefined;
		resetUploadUrl();
	}

	// Calculate the download URL values
	function calcDownloadUrl() {
		// Note: The LinksLSKey depends on the _usedLoadConfigName and
		// on the _loadName, so these have to be calculated before
		// we can call getConfigLoadKey().

		// Derive _preliminaryLinks: Generally LocalStorage if available,
		// because it might be equal to the downloaded Links in which case
		// rendering doesn't need to be restarted.
		let preliminaryIsLocal = true;  //flag to use localLinks as preliminary

		// Derive _fallbackLinks: The final links text, unless download was successful
		_fallbackLinks = null;
		let fallbackLinksMsg = 'same as preliminaryLinks';

		// Derive _loadUrl and _usedConfigName: The first of Load or
		// LoadOverride that is set.
		// Also adjust preliminary and fallback flags.
		let loadOverrideOptions = getLoadOverrideOptions();
		let loadOptions = getLoadOptions();
		let saveOptions = getSaveOptions();
		let localBeforeDownload = false;  //flag to not use local before download
		let loadUrlMsg;
		if (loadOverrideOptions) {
			// Source selection: override - default  (do not consider LoadOptions or LocalStorage)
			console.log('loadOverrideOptions set');
			preliminaryIsLocal = false;
			// Note: The override might be te same as localLinks, in which case
			// preliminary-render would have helped.
			_loadUrl = loadOverrideOptions;
			loadUrlMsg = 'loadOverrideOptions';
			_usedLoadConfigName = loadOverrideConfigName;
			_fallbackLinks = DefaultLinks;
			fallbackLinksMsg = 'default';
			addStatus('Override');
		} else if (loadOptions) {
			if (saveOptions) {
				// Source selection: download - local - default  (LoadOptions before LocalStorage, because saveOptions is set)
				console.log('Both loadOptions and saveOptions set');
			} else {
				// Source selection: local - download - default
				console.log('loadOptions without saveOptions set');
				localBeforeDownload = true;
			}
			_loadUrl = loadOptions;
			loadUrlMsg = 'loadOptions';
			_usedLoadConfigName = loadConfigName;
		} else {
			// Source selection: local - default
			console.log('Both loadOverrideOptions and loadOptions not set');
			_loadUrl = null;
			loadUrlMsg = 'none';
			_usedLoadConfigName = null;
			addStatus('Local');
		}
		console.assert(_usedLoadConfigName !== undefined);
		console.log('_usedLoadConfigName=' + _usedLoadConfigName);
		console.log('_loadUrl=' + _loadUrl);

		// Derive loadToken and loadName
		_loadName = null;
		_downloadHeaders = [];
		if (_loadUrl != null) {
			let parts = _loadUrl.split('\\');
			//console.log(parts);
			_loadUrl = parts.shift();
			// The other parts are additional headers in either value or
			// name:value format
			let implicitNames = [ 'x-name', 'x-token' ];
			for (let i = 0; i < parts.length; ++i) {
				let name_value = parts[i].match(/^([^:]+)?:(.+)$/);
				if (name_value) {
					// This is a name:value header
					_downloadHeaders.push(name_value.slice(1,3));
				} else {
					// A header with an implicit name
					if (implicitNames.length > 0) {
						let name = implicitNames.shift();
						_downloadHeaders.push([ name, parts[i] ]);
						if (name == 'x-name') _loadName = parts[i];
					} else {
						console.error('Too many implicit headers in ' + _loadUrl);
						// Just discard this header
					}
				}
			}
		}
		if (_loadName == null && _loadUrl != null) {
			// No name found, now take the name from the URL
			_loadName = _loadUrl.replace(/[?#].*$/, '').replace(/^[^\/]*\//, '');
		}
		console.assert(_loadName !== undefined);
		console.log('_loadName=' + _loadName);
		//console.log('HTTP headers=' + _downloadHeaders);

		// Get Links from LocalStorage (needs _usedConfigName and _loadName)
		// Derive _preliminaryLinks and _fallbackLinks.
		let localLinks = getData().readLocalLinks();
		let preliminaryLinksMsg;
		if (localLinks != null) {
			// localLinks present
			if (preliminaryIsLocal) {
				_preliminaryLinks = localLinks;
				preliminaryLinksMsg = 'LocalStorage (' + localLinks.length + ' characters)';
			} else {
				_preliminaryLinks = null;
				preliminaryLinksMsg = 'none (ignore LocalStorage)';
			}
			if (localBeforeDownload) {
				// The first option is LocalStorage and that is set.
				// No need to download
				_loadUrl = null;
				loadUrlMsg = 'none (use LocalStorage instead)';
				addStatus('Local');
			} else {
				addStatus('Links');
			}
		} else {
			// localLinks not present
			_preliminaryLinks = null;
			preliminaryLinksMsg = 'none (LocalStorage is empty)';
			_fallbackLinks = DefaultLinks;
			fallbackLinksMsg = 'default (LocalStorage is empty)';
		}

		console.log('* preliminaryLinks: Use ' + preliminaryLinksMsg);
		console.log('* loadUrl: Use ' + loadUrlMsg);
		console.log('* fallbackLinks: Use ' + fallbackLinksMsg);

		// If _loadUrl set, check special cases
		if (_loadUrl != null) {
			let matchTargetUrl = _loadUrl.match(/^\s*((https?:\/\/)?(.*?))\s*$/i);  //always matches
			//console.log(matchTargetUrl);
			// Captured:
			// 1: url
			// 2: protocol
			// 3: domain + path + rest
			_loadUrl = matchTargetUrl[1];  //trim whitespace
			if (!matchTargetUrl[2]) {
				// URL is relative, check if we need to adjust it
				let matchBaseUrl = window.location.href.match(/^([^\/]*?:\/\/)([^\/]*\bhtml-?preview\.github\.[^\/]*)([^?#]*)/i);
				//console.log(matchBaseUrl);
				// Captured:
				// 1: protocol
				// 2: host ('html-preview.github.io')
				// 3: path without query string or fragment
				if (matchBaseUrl) {
					// The current URL is html-preview.github.io (or similar)
					// This should have a url= parameter that contains the real location
					let referredUrl = params.get('url');
					//console.log(referredUrl);
					let matchReferredUrl = referredUrl.match(/^([^\/]*:\/\/)([^\/]*\bgithub\.[^\/]*)([^?#]*)/i);
					//console.log(matchReferredUrl);
					// Captured:
					// 1: protocol
					// 2: host ('github.com')
					// 3: path without query string or fragment
					if (matchReferredUrl) {
						// The referred URL is on github.com

						// We are now in a situation where this page is hosted
						// on GitHub and links tries to point to a file on
						// there as well.
						// If you have a normal link to github.com, you get the
						// file inside the environment. If you use
						// raw.githubusercontent.com, you get the content of the
						// file, but with Content-Type=text/plain. When
						// html-preview.github.io is used, it uses
						// raw-githubcontent.com and serves it with
						// Content-Type=text/html.
						console.log('Fix _loadUrl relative URL for GitHub');
						// To make this relative link work, it should be grafted
						// onto githubusercontent.
						let matchReferredPath = matchReferredUrl[3].match(/(.*?)([^\/]*)$/);
						//console.log(matchReferredPath);
						// Captured:
						// 1: directory
						// 2: filename (everything after last '/')
						_loadUrl = matchReferredUrl[1] + 'raw.githubusercontent.com' + matchReferredPath[1] + matchTargetUrl[3];
					}
				}
			}
		}
	}

	// Variables and access methods for the upload URL
	let _uploadUrl = undefined;
	function getUploadUrl() {
		if (_uploadUrl === undefined) calcUploadUrl();
		return _uploadUrl;
	}
	let _uploadMethod = undefined;
	function getUploadMethod() {
		if (_uploadMethod === undefined) calcUploadUrl();
		return _uploadMethod;
	}
	let _uploadHeaders = undefined;
	function getUploadHeaders() {
		if (_uploadHeaders === undefined) calcUploadUrl();
		return _uploadHeaders;
	}

	// Reset the upload URL variables, so that it gets recalculated when needed
	function resetUploadUrl() {
		_uploadUrl = _uploadMethod = _uploadHeaders = undefined;
	}
	function noUploadUrl() {
		_uploadUrl = '';
		_uploadMethod = '';
		_uploadHeaders = [];
	}

	// Calculate the upload URL values
	function calcUploadUrl() {
		let saveOptions = getSaveOptions();
		if (saveOptions.match(/^\s*$/)) {
			console.log('SaveOptions empty, no UploadUrl');
			noUploadUrl();
			return;
		}
		let uploadDisabled = getSaveOptionsDisabled();
		if (uploadDisabled) {
			console.log('SaveOptions disabled, no UploadUrl');
			noUploadUrl();
			return;
		}
		let downloadUrl = getDownloadUrl();

		// Split into parts
		let parts = saveOptions.split('\\');

		// The first part should specify the method and the URL
		let saveUrl, special = false;
		let method_url = parts.shift().match(/^(?:(put|post):)?(.*)$/i);
		if (method_url) {
			if (method_url[1]) {
				// This is the standard syntax method:url
				_uploadMethod = method_url[1].toUpperCase();
				console.debug('Explicit method for upload: ' + _uploadMethod);
			} else {
				// This is the special save syntax
				_uploadMethod = 'POST';
				console.debug('Method for special upload: ' + _uploadMethod);
				special = true;
			}
			if (method_url[2]) {
				// A URL has been specified
				saveUrl = method_url[2];
				console.debug('Specified upload URL: ' + saveUrl);
			} else if (downloadUrl) {
				// No URL has been specified, use the URL for reading
				saveUrl = null;
				console.debug('Upload URL is download URL: ' + downloadUrl);
			} else {
				// No URL to use
				console.error('Cannot find read nor write URL');
				noUploadUrl();
				return;
			}
		} else {
			console.error('Incorrect method/url in \'' + saveOptions + '\'');
			noUploadUrl();
			return;
		}

		// Derive absolute URL to save
		if (downloadUrl) {
			// downloadUrl may be relative to this script and saveUrl may be relative to downloadUrl
			let loadUrlAbs = new URL(downloadUrl, window.location).href;
			if (saveUrl === null) {
				_uploadUrl = loadUrlAbs;
			} else {
				_uploadUrl = new URL(saveUrl, loadUrlAbs).href;
			}
		} else {
			// No downloadUrl known, assume base of saveUrl is this script
			_uploadUrl = new URL(saveUrl, window.location).href;
		}

		// The other parts are additional headers
		_uploadHeaders = [];
		if (special) {
			// For the special syntax, the next part is the token
			if (parts.length > 0) {
				_uploadHeaders.push([ 'x-token', parts.shift() ]);
			}
			// Create the x-name header
			let loadName = getLoadName();
			if (loadName) {
				_uploadHeaders.push([ 'x-name', loadName ]);
			} else {
				console.error('Special save cannot find loadName for x-name');
				noUploadUrl();
				return;
			}
		}
		// The other parts are additional headers in name:value format
		for (let i = 0; i < parts.length; ++i) {
			let name_value = parts[i].match(/([^:]+):(.+)/);
			if (name_value) {
				_uploadHeaders.push(name_value.slice(1,3));
			} else {
				console.warn('Expected header: ' + parts[i]);
			}
		}

		//console.log('Request headers: ', _uploadHeaders);
	}

	// Handling of SaveOptionsDisabled
	let _saveOptionsDisabled = null;  //set to string with the reason why saving is disabled
	function getSaveOptionsDisabled() {
		return _saveOptionsDisabled;
	}
	function setSaveOptionsDisabled(value) {
		if (_saveOptionsDisabled !== value) {
			console.log('Change _saveOptionsDisabled to \'' + value + '\'');
			_saveOptionsDisabled = value;
			resetUploadUrl();
		}
	}

	// Return the object with the appropriate functions
	return {
		// Fields to manage LoadOptions
		getLoadConfigName : () => loadConfigName,
		getLoadOptions : getLoadOptions,
		setLoadOptions : setLoadOptions,

		// Fields to manage LoadOptions override
		getLoadOverrideConfigName : () => loadOverrideConfigName,
		getLoadOverrideOptions : getLoadOverrideOptions,
		setLoadOverrideOptions : setLoadOverrideOptions,

		// Fields to manage SaveOptions
		getSaveConfigName : () => saveConfigName,
		getSaveOptions : getSaveOptions,
		setSaveOptions : setSaveOptions,

		// Fields for downloading Links
		getDownloadUrl : getDownloadUrl,
		getDownloadHeaders : getDownloadHeaders,
		getLoadName : getLoadName,

		// Fields for uploading Links
		getUploadUrl : getUploadUrl,
		getUploadMethod : getUploadMethod,
		getUploadHeaders : getUploadHeaders,
		getUploadDisabled : getSaveOptionsDisabled,
		setUploadDisabled : setSaveOptionsDisabled,

		// Fields for preliminary Links
		getPreliminaryLinks : getPreliminaryLinks,

		// Fields for fallback Links
		getFallbackLinks : getFallbackLinks,

		// Fields for accessing other LocalStorage keys
		getConfigLoadKey : getConfigLoadKey,
	};
}

// }}}

// Loading/Saving Links {{{

// This function uses the UrlResolver object to find the correct URL to download.
// It starts the download and returns a Promise.
// The Promise resolves normally if the download finished successfully. Otherwise
// the Promise is rejected.
// The global Links variable is not used or updated.
function downloadLinks() {
	let url = UrlResolver.getDownloadUrl();
	if (url == null) return null;
	let headers = UrlResolver.getDownloadHeaders();

	UrlResolver.setUploadDisabled(null);
	console.important('Downloading URL \'' + url + '\'');
	let dowloadPromise;
	if (window.fetch) {
		//console.devlog('Using fetch() to download');
		let hdrs = new Headers();
		for (let i = 0; i < headers.length; ++i) {
			hdrs.append(headers[i][0], headers[i][1]);
		}
		dowloadPromise = new PendingPromise();
		let status;
		fetch(url, { headers : hdrs })
		.then(response => {
			//console.devlog('downloadLinks: Request sent');
			status = response.status;
			return response.text();
		})
		.then(text => {
			//console.devlog('downloadLinks: Response received');
			if (status == 200) {
				// Success
				console.log('downloadLinks: Download successful');
				addStatus('Load OK');
				dowloadPromise.resolve(text);
			} else {
				// Failed
				console.error('downloadLinks: Download failed');
				addStatus('Load ' + status);
				// If the download failed, disable
				// saveOptions to not accidentally
				// overwrite the file.
				UrlResolver.setUploadDisabled('Saving disabled because downloading \'' + url + '\' failed');
				dowloadPromise.reject(false);
			}

		})
		.catch(error => dowloadPromise.reject(error));
	} else {
		//console.devlog('Using XMLHttpRequest to download');
		dowloadPromise = new Promise((resolveFunc, rejectFunc) => {
			let xhr = new XMLHttpRequest();
			xhr.open('GET', url);
			for (let i = 0; i < headers.length; ++i) {
				xhr.setRequestHeader(headers[i][0], headers[i][1]);
			}
			xhr.onreadystatechange = function() {
				if (this.readyState == 4) {
					// Request has been handled
					if (this.status == 200) {
						// Success
						console.log('downloadLinks: Download successful');
						addStatus('Load OK');
						resolveFunc(xhr.responseText);
					} else {
						// Failed
						console.error('downloadLinks: Download failed');
						addStatus('Load ' + this.status);
						// If the download failed, disable
						// saveOptions to not accidentally
						// overwrite the file.
						UrlResolver.setUploadDisabled('Saving disabled because downloading \'' + url + '\' failed');
						rejectFunc(false);
					}
				}
			};
			xhr.send();  //send the request
		});
	}

	return dowloadPromise;
}

// Save links online by the method specified.
// If the value is null, empty or whitespace, save an empty string.
// CleanLinks and LinksDirty are also updated if save successful.
// Returns Promise of the upload or false if not saving.
function uploadLinks(value) {
	let url = UrlResolver.getUploadUrl();
	if (!url) {
		console.warn('No UploadUrl, skip saving');
		return false;
	}
	let method = UrlResolver.getUploadMethod();
	if (!method) {
		console.warn('No UploadMethod, skip saving');
		return false;
	}
	let headers = UrlResolver.getUploadHeaders();

	// If value is null or whitespace, send an empty string
	if (value == null || value.match(/^\s*$/)) {
		value = '';
	}

	console.important('Uploading to URL ' + url + ': ' + method + ' ' + value.length + ' characters');

	// Create the Promise for uploading
	let uploadPromise = new Promise((resolveFunc, rejectFunc) => {
		let xhr = new XMLHttpRequest();
		xhr.open(method, url);
		for (let i = 0; i < headers.length; ++i) {
			xhr.setRequestHeader(headers[i][0], headers[i][1]);
		}
		xhr.onreadystatechange = function() {
			if (this.readyState == 4) {
				// Request has been handled
				if (this.status == 200) {
					// Success
					console.log('Uploaded links successfully');
					addStatus('Save OK');
					console.log('Update CleanLinks');
					Data.writeCleanLinks(value);  //assume upload & download are same content
					updateSettingsDirty(false);
					resolveFunc(this.status);
				} else {
					// Failed
					console.log('Failed to upload Links, good luck next time (' + this.status + ')');
					addStatus('Save ' + this.status);
					updateSettingsDirty();
					resolveFunc(this.status);  //do not see this as a fail
				}
			}
		};
		xhr.send(value);  //send the request
	});

	return uploadPromise;
}

// List of pending upload callbacks.
var PendingUpload = CreatePending('PendingUpload', 3, true);

// Create object to handle pending actions.
// - name [string]: Name of the object for debugging
// - timeout [seconds]: Time after which the action should be executed.
// - onlyLast [bool]: If true, only the last action is maintaind.
// The action is done after timeout. If the window.onunload is called before
// the timeout, the action is also executed.
function CreatePending(name, timeout, onlyLast) {
	let actions = [];
	let timer = null;
	let onunload = false;

	function clearTimer() {
		if (timer) {
			window.clearTimeout(timer);
			timer = null;
		}
	}

	function clearActions() {
		actions.length = 0;
	}

	function doActions() {
		console.log(name + ': Execute actions');
		for (let i = 0; i < actions.length; ++i) actions[i]();
		clearActions();
	}

	// Add new action
	function add(callback) {
		// (Re)set timer
		if (timer) window.clearTimeout(timer);
		timer = window.setTimeout(doActions, timeout*1000);
		// Update actions
		if (onlyLast) {
			console.log(name + ': Set pending action (in ' + timeout + 's)');
			actions.length = 0;
		} else {
			console.log(name + ': Add pending action (in ' + timeout + 's)');
		}
		actions.push(callback);
		// Set unload event
		if (!onunload) {
			window.addEventListener('beforeunload', onBeforeUnload);
			onunload = true;
		}
	}

	function onBeforeUnload(event) {
		// I don't think onbeforeunload is allowed to perform blocking
		// actions like uploading. Also, it doesn't seem to be allowed
		// to await Promises.
		// I leave this code for now in case a solution is found.
		// Maybe https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker
		doActions();
		dispose();
	}

	// Function to release resources
	function dispose() {
		clearTimer();
		clearActions();
		if (onunload) {
			window.removeEventListener('beforeunload', onBeforeUnload);
			onunload = false;
		}
	}

	return {
		add        : add,
		getTimeout : () => timeout,
		setTimeout : value => timeout = value,
		dispose    : dispose,
	};
}

// }}}

// Parsing Links {{{

// Parse the string in links and returns object with the following fields:
// - pageTitle: Specified title
// - pageTheme: Specified color theme
// - fontSize: Specified font-size (may be relative, but that doesn't work very well)
// - blocksCollapsedInitially: If blocks are initially collapsed by default
// - blocksCollapsedAlwaysInitial: If initial is always used or if local value is used
// - searchButtonDefs: Specified search button declarations
// - rootLinks: Array of Link objects that have no parents (i.e. are roots)
// - iconDefs: Specified icondef declarations
// - checkboxDefs: Specified checkbox declarations
// - styleBlocks: Array of !style...!endstyle blocks
// - scriptBlocks: Array of !script...!endscript blocks
function parseLinks(links) {
	console.important('Parsing Links...');

	// Parse the input lines and construct a list of objects
	let allLinks = [];  //specified Link objects
	let parsed = {
		pageTitle                    : null,
		pageTheme                    : null,
		fontSize                     : null,
		blocksCollapsedInitially     : false,
		blocksCollapsedAlwaysInitial : false,
		autoUploadDelay              : null,
		searchButtonDefs             : [],
		rootLinks                    : [],
		iconDefs                     : {},
		checkboxDefs                 : {},
		styleBlocks                  : [],
		scriptBlocks                 : [],

		// Member functions

		// Take icon_url and perform the icondef replacements.
		// Returns the resolved value or the original value if no icondefs matched.
		resolveIconDefs(icon_url) {
			let retval = icon_url;
			let seen = {};  //to break cycles
			seen[icon_url] = 1;
			let override = this.iconDefs[icon_url];
			while (override !== undefined && !seen[override]) {
				console.log('Replace icon=' + icon_url + ' by IconDefs ' + override);
				retval = override;
				seen[override] = 1;
				override = this.iconDefs[override];
			}
			//console.log('Returning ' + retval);
			return retval;
		},
	};
	let tempCheckboxDefs = [];  //temporary checkboxDefs, because they need post-processing
	let textBlock = null;  //used for literal !text ... !endtext blocks
	let styleBlock = null;  //used for literal !style ... !endstyle blocks
	let scriptBlock = null;  //used for literal !script ... !endscript blocks
	let openIndentLevels = [];  //indentation level (number of spaces) for each open level
	let maxLevel = null;  //keep track of the maximum level
	let lines = links.split(/\r?\n\r?/);  //lines with Link specifications
	for (let i = 0; i < lines.length; ++i) {
		let line = lines[i];
		//console.log('Line=\'' + line + '\'');
		let m;  //for regex matches

		// If we're in a !text block, add this line to the block
		if (textBlock != null) {
			// Check if it is the end of a literal block
			m = line.match(/^\s*!endtext\s*$/i);
			if (m) {
				// It is the end, save the object and reset textBlock.
				allLinks.push(textBlock);  //all items go here
				textBlock = null;  //reset
				continue;
			}
			// Otherwise add this line too
			textBlock.lines.push(line);
			continue;
		}

		// If we're in a !style block, add this line to the block
		if (styleBlock != null) {
			// Check if it is the end of a literal block
			m = line.match(/^\s*!endstyle\s*$/i);
			if (m) {
				// It is the end, save the object and reset styleBlock.
				console.log('Add !style block (' + styleBlock.lines.length + ' lines)');
				parsed.styleBlocks.push(styleBlock);
				styleBlock = null;  //reset
				continue;
			}
			// Otherwise add this line too
			styleBlock.lines.push(line);
			continue;
		}

		// If we're in a !script block, add this line to the block
		if (scriptBlock != null) {
			// Check if it is the end of a literal block
			m = line.match(/^\s*!endscript\s*$/i);
			if (m) {
				// It is the end, save the object and reset scriptBlock.
				console.log('Add !script block (' + scriptBlock.lines.length + ' lines)');
				parsed.scriptBlocks.push(scriptBlock);
				scriptBlock = null;  //reset
				continue;
			}
			// Otherwise add this line too
			scriptBlock.lines.push(line);
			continue;
		}

		// Remove vim folding markers at the end of lines
		line = line.replace(/\s*(?:{{{|}}})\s*$/, '');

		// Skip empty lines
		if (line.match(/^\s*(?:\/\/|#|;|$)/))
			continue;

		// Check if it is a title definition
		m = line.match(/^\s*!title\s+(.+?)\s*$/i);
		if (m) {
			// This is an title
			parsed.pageTitle = m[1];  //save string
			continue;
		}

		// Check if it is a theme definition
		m = line.match(/^\s*!theme\s+(.+?)\s*$/i);
		if (m) {
			// This is a theme
			parsed.pageTheme = m[1];  //save string
			continue;
		}

		// Check if it is a font-size definition
		m = line.match(/^\s*!size\s+(.+?)\s*$/i);
		if (m) {
			// This is a size
			parsed.fontSize = m[1];  //save string
			continue;
		}

		// Check if it is a blocks-closed definition
		m = line.match(/^\s*!collapsed\s+(always|never|yes|no)\s*$/i);
		if (m) {
			// This is a blocks-closed definition
			let v = m[1].toLowerCase();
			parsed.blocksCollapsedInitially = (v == 'always' || v == 'yes');
			parsed.blocksCollapsedAlwaysInitial = (v == 'always' || v == 'never');
			continue;
		}

		// Check if it is a upload-delay definition
		m = line.match(/^\s*!auto-upload-delay\s+(.+?)\s*$/i);
		if (m) {
			// This is a delay time
			parsed.autoUploadDelay = 1*m[1];  //save value
			continue;
		}

		// Check if it is an icon definition
		m = line.match(/^\s*!icondef\s+(\S+)(?:\s+|\s*=\s*)(\S+)\s*$/i);
		if (m) {
			// This is an icondef
			parsed.iconDefs[m[1]] = m[2];  //save mapping
			continue;
		}

		// Check if it is a checkbox definition
		m = line.match(/^\s*!checkbox\s+(\S+)\s+(.+?)\s*$/i);
		if (m) {
			// This is a checkbox definition
			tempCheckboxDefs.push([ m[1], m[2] ]);
			continue;
		}

		// Check if it is a search button definition
		m = line.match(/^\s*!search\s+(.+?)\s*$/i);
		if (m) {
			// This is a search button definition
			let def = m[1].split(/\s*\|\s*/);  //split fields on '|', allowing whitespace
			parsed.searchButtonDefs.push(def);  //save button def
			continue;
		}

		// Check if it is the start of a literal !text block
		m = line.match(/^\s*!text\s*$/i);
		if (m) {
			// Mark the start of the block
			textBlock = {  //special type of Link object
				lineNum  : i+1,  //start of this block
				type     : 'text',
				level    : null,  //adjusted later
				lines    : [],
				toString : function() { return '{ !text, #Lines=' + this.lines.length + ' }' },
			};
			continue;
		}

		// Check if it is the start of a literal !style block
		m = line.match(/^\s*!style\s*$/i);
		if (m) {
			// Mark the start of the block
			styleBlock = {
				lineNum  : i+1,  //start of this block
				lines    : [],
				toString : function() { return '{ !style, #Lines=' + this.lines.length + ' }' },
			};
			continue;
		}

		// Check if it is the start of a literal !script block
		m = line.match(/^\s*!script\s*$/i);
		if (m) {
			// Mark the start of the block
			scriptBlock = {
				lineNum  : i+1,  //start of this block
				lines    : [],
				toString : function() { return '{ !script, #Lines=' + this.lines.length + ' }' },
			};
			continue;
		}

		// Take out indentation
		let indent = 0;
		m = line.match(/^(\s+)(.*)$/);
		if (m) {
			indent = m[1].replaceAll('\t', '        ').length;
			line = m[2];  //the rest
		}
		// Take out continucation: & ...
		let cont = false;
		m = line.match(/^&\s*(.*)$/);
		if (m) {
			cont = true;
			line = m[1];  //the rest
		}
		// Take out Icon: /icon=non-whitespace/
		let icon = null;
		m = line.match(/^(.*)(?:\s|^)icon=(\S*)(.*)$/i);
		if (m) {
			icon = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out Check: start with '[]', '[value]' or '[value]:checkbox-type'.
		let checkType = null, checkValue = null;
		m = line.match(/^(\s*)(?:[-*]\s*)?(?:\[(\S+|\s+)\]|(\[\]))(?::(\S+))?(.*)$/);
		// The above regex matches the following:
		// - Capture 1: Initial whitespace (indentation)
		// - Capture 2: The checkbox value (either non-space string or only-space string)
		// - Capture 3: The empty []
		// - Capture 4: The checkbox type
		// - Capture 5: The rest of the line
		if (m) {
			if (m[2]) checkValue = m[2];  //value is set
			if (m[3]) checkValue = null;  //value is empty
			checkType = (m[4] != null) ? m[4] : 'default'; 
			line = m[1] + m[5];  //the rest
		}
		// Take out Target: /target=non-whitespace/
		let target = null;
		m = line.match(/^(.*)(?:\s|^)target=(\S*)(.*)$/i);
		if (m) {
			target = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out URL: /url=non-whitespace/ or last /schema:non-whitespace/
		let url = null;
		m = line.match(/^(.*)(?:\s|^)url=(\S*)(.*)$/i);
		if (!m)
			m = line.match(/^(.*)(?:\s|^)([-+a-zA-Z]{2,}:\S+)(.*)$/);
		if (m) {
			url = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out Name: what remains without leading&trailing whitespae
		let name = line.trim();

		// Handle special items
		if (name.match(/^---+$/)) {  //name with 3 or more '-'
			// This is a separator
			name = '---';  //standardize to 3 '-'
		}

		// Determine level of this object
		let level;
		if (cont) {
			// This link is a continuation, ignore the indentation
			level = null;
		} else {
			// Find level with indentation strictly less
			for (level = openIndentLevels.length - 1; level >= 0 && openIndentLevels[level] >= indent; --level) {}
			// We found the parent's level (-1 if no parent), add 1 for this level
			++level;
			if (maxLevel == null || level > maxLevel) maxLevel = level;
			// Remove all open levels after that
			openIndentLevels.length = level;
			// Add this link as open parent
			openIndentLevels.push(indent);
		}

		// Create the Link object
		let link = {
			lineNum    : i+1,
			type       : 'link',
			level      : level,
			name       : name,
			url        : url,
			icon       : icon,
			checkType  : checkType,
			checkValue : checkValue,
			target     : target,
			cont       : [],
			subs       : [],
			toString   : function() { return '{ Name=\'' + this.name + '\', URL=' + this.url + ', Icon=' + this.icon + ', check=' + check + ', #SubItems=' + this.subs.length + ' }' },
		};
		//console.log('Indentation=' + indent + ', Link=' + link);

		// Add this Link
		if (cont) {
			// This link is a continuation, add it to the previous link
			var previous = allLinks[allLinks.length - 1];
			previous.cont.push(link);
		} else {
			allLinks.push(link);
		}
	}

	// Search from position to the front in allLinks and find the first
	// link item that has a level set.
	// Returns item or null if not found.
	let findLinkBefore = function(position) {
		for (let i = position - 1; i >= 0; --i) {
			let item = allLinks[i];
			if (item.level != null) return item;
		}
		return null;
	}

	// Search from position to the end in allLinks and find the first
	// link item that has a level set.
	// Returns item or null if not found.
	let findLinkAfter = function(position) {
		for (let i = position + 1; i < allLinks.length; ++i) {
			let item = allLinks[i];
			if (item.level != null) return item;
		}
		return null;
	}

	// If maxLevel==0, all items are at root level. It was probably
	// intended to have all items in a block. To fix this, add a
	// dummy Section (level 0) and Block (level 1).
	// Similarly with maxLevel==0. Now all items are separate blocks.
	// Fix this by adding a dummy Section (level 0).
	if (maxLevel < 2) {
		// These are the special cases
		let firstLink = findLinkAfter(-1);
		if (firstLink == null) {
			// There are no links at all.
			// In this case, there is nothing to adjust
		} else {
			// Add 1 or 2 levels in the front of allLinks
			// In either case, we need to add a Section
			let section = {
				lineNum    : 0,
				type       : 'link',
				level      : 0,
				name       : '_',  //this makes this section not render
				url        : null,
				icon       : null,
				checkType  : null,
				checkValue : null,
				target     : null,
				cont       : [],
				subs       : [],
				toString   : function() { return '{ Dummy Section }' },
			};
			if (maxLevel == 0) {
				// Only in this case, we need to add a Block level too
				let block = {
					lineNum    : 0,
					type       : 'link',
					level      : 1,
					name       : firstLink.name,  //give it the same name as the first link
					url        : null,
					icon       : null,
					checkType  : null,
					checkValue : null,
					target     : null,
					cont       : [],
					subs       : [],
					toString   : function() { return '{ Dummy Block }' },
				};
				console.log('Add dummy Block');
				allLinks.unshift(block);
			}
			console.log('Add dummy Section');
			allLinks.unshift(section);
			// Increase level of all existing items
			//  maxLevel | num items added | start original items | increase
			// ----------|-----------------|----------------------|----------
			//         0 |               2 |                    2 |        2
			//         1 |               1 |                    1 |        1
			//        >2 |               0 |                  n/a |      n/a
			let x = 2 - maxLevel;
			for (let i = x; i < allLinks.length; ++i) {
				let level = allLinks[i].level;
				if (level != null) {
					allLinks[i].level = level + x;
				}
			}
		}
	}
	//console.log(allLinks);

	// Go through allLinks and adjust the level if needed
	for (let i = 0; i < allLinks.length; ++i) {
		let item = allLinks[i];
		if (item.type == 'text') {
			// This is a text block
			// Make its level the lowest of the item before and the item after
			let before = findLinkBefore(i);
			let after = findLinkAfter(i);
			if (before != null) {
				if (after != null) {
					// There is a line before and a line after
					if (before.level < after.level) {
						// Indent in -> regard this item as 1 below before
						item.level = before.level + 1;
					} else if (before.level == after.level) {
						// Same indent -> regard this item as that level too
						item.level = before.level;
					} else {
						// Indent out -> regard this item as 1 deeper than after
						item.level = after.level + 1;
					}
				} else {
					// There is a line before, but no line after
					// This is at the end of the page -> root level
					item.level = 0;
				}
			} else {
				// There is a line after, but no line before
				// This is at the start of the page -> root level
				item.level = 0;
			}
		} else if (item.type == 'link' && item.name == '---') {
			// This is a separator.
			// A separator is only useful at block level or lower
			if (item.level <= 1) {
				item.level = null;
			}
		}
	}

	// Go through allLinks and create a parent-child structure
	let openParents = [];  //currently open parents: 0 is root, 1 its child, etc
	for (let i = 0; i < allLinks.length; ++i) {
		let item = allLinks[i];
		if (item.level == null) {
			// This has no level and should not be put in the parent-child structure
		} else {
			if (item.level > 0) {
				// This is a regular item, find a parent
				let parent = openParents[item.level - 1];
				parent.subs.push(item);
			} else {
				// This item does not have a parent, it's a root
				parsed.rootLinks.push(item);
			}

			// If this item can be a parent too, replace from this level and below
			if ('subs' in item) {
				openParents.length = item.level;
				openParents.push(item);
			}
		}
	}

	// Go through CheckboxDefs and resolve the icons
	for (let i = 0; i < tempCheckboxDefs.length; ++i) {
		let name = tempCheckboxDefs[i][0];
		// Parse the arguments
		let args = tempCheckboxDefs[i][1].split(/\s+/);  //split on whitespace
		let firstOptionName = null, prevOptionName = null;
		let options = {};
		for (let i = 0; i < args.length; ++i) {
			let arg = args[i];
			//console.devlog('!checkbox arg: ' + arg);
			let name = null, val = null;
			let m = arg.match(/^([^=]+)=(.+)$/);
			if (m) {
				// It is an name=value option
				if (m[1][0] == '!') {
					// It is an argument
					continue;  //not yet implemented
				} else {
					// This is a checkbox option
					name = m[1];
					val = m[2];
				}
			} else {
				// It is a single value option
				val = arg;
			}
			if (name == '_') name = ' ';
			// Check icondef
			let icondef = parsed.resolveIconDefs(val);
			if (icondef == val) icondef = null;
			// Check special values
			let lval = val.toLowerCase();
			if (lval == '_' || lval == 'empty') {
				if (name == null) name = ' ';
				val = 'empty';  //a valid icon
			} else if (lval == 'uncheck') {
				if (name == null) name = ' ';
				val = UNICODE_BALLOT_BOX;
			} else if (lval == 'check') {
				val = UNICODE_BALLOT_BOX_WITH_CHECK;
			} else if (lval == 'cross') {
				val = UNICODE_BALLOT_BOX_WITH_CROSS;
			} else if (lval == 'mcheck') {
				val = UNICODE_WHITE_SQUARE_CONTAINING_BLACK_SMALL_SQUARE;
			}
			// Set name if name not yet set
			if (name == null) name = val;
			// If icondef, use that value instead, but retain name
			if (icondef != null) val = icondef;
			// Represent single char, surrogate pair or 'U+xxxxx' as char:x
			if (val.length == 1 ||
				(val.length == 2 && val.codePointAt(0) >= 0x10000) ||
				val.match(/^U\+[0-9a-f]{1,6}$/i)) {
				val = 'char:' + val;
			}
			// Add option to options structure
			if (name != null) {
				let option = {
					name  : name,
					value : val,
					next  : firstOptionName,  //last points to first
				}
				if (firstOptionName == null) {
					firstOptionName = name;  //first in list
				} else {
					options[prevOptionName].next = name;  //prev points to me
				}
				options[name] = option;  //add to list
				prevOptionName = name;  //advance prev
			}
		}
		if (firstOptionName != null) {
			let def = {
				name    : name,
				options : options,
				first   : firstOptionName,
			};
			//console.devlog('!checkbox found');
			//console.log(def);
			parsed.checkboxDefs[name] = def;
		} else {
			console.warn('Ignore !checkbox \'' + m[1] + '\' with no options');
		}
	}

	// Check if all blocks have been closed
	if (textBlock) {
		throw new UserInputError('Missing !endtext for !text', textBlock.lineNum);
	}
	if (styleBlock) {
		throw new UserInputError('Missing !endstyle for !style', styleBlock.lineNum);
	}
	if (scriptBlock) {
		throw new UserInputError('Missing !endscript for !script', scriptBlock.lineNum);
	}

	// Log all links
	//for (let i = 0; i < allLinks.length; ++i) console.log('Link=' + allLinks[i]);
	// Log all roots
	//for (let i = 0; i < parsed.rootLinks.length; ++i) console.log('RootLink=' + parsed.rootLinks[i]);

	return parsed;
}

// }}}

// Rendering Links {{{

function render(parsed, container, cancel) {
	// Render the RootLinks in the container.
	container.textContent = '';
	outputItems(parsed.rootLinks, 1, container, '', cancel);

	// Collect all checkboxes in a hierarchy
	let toplevel = [];
	function discover(links, parent) {
		for (let i = 0; i < links.length; ++i) {
			let link = links[i];
			let here = parent;
			if (link.output && link.output.checkbox && link.output.checkbox.present) {
				// This item has a checkbox
				let cb = link.output.checkbox;
				if (parent == null) {
					toplevel.push(cb);
				} else {
					parent.children.push(cb);
				}
				cb.parent = parent;
				here = cb;  //descend a level
			}
			if (link.cont) discover(link.cont, parent);  //add these to same parent
			if (link.subs) discover(link.subs, here);  //add these below here
		}
	}
	discover(parsed.rootLinks, null);
	// For all the toplevels, calculate the hierarchical status
	for (let i = 0; i < toplevel.length; ++i) {
		toplevel[i].updateSelFirst(true);
	}

	// Render array of Links to the container at specified level.
	function outputItems(links, level, container, parentPath, cancel) {
		for (let i = 0; i < links.length; ++i) {
			let link = links[i];
			if (link.type == 'link') {
				outputItem(link, level, container, parentPath, cancel);
			} else if (link.type == 'text') {
				outputText(link.lines, container);
			}
			if (cancel()) return;
		}
	}

	// Output Link {{{

	// Render Link object, including its children to the container at specified level.
	// Level 1 is called Section and is rendered with a heading.
	// Level 2 is called Block and is rendered as a rectangular block.
	// Level 3 is called Item and is rendered as a line in a Block.
	// Level 4 and higher are called sub-Items and are rendered as indented Items.
	function outputItem(link, level, container, parentPath, cancel) {
		//console.log('outputItem ' + link.toString());
		// Copy input data
		let name = link.name;
		let url = link.url;
		let icon = link.icon;
		let checkType = link.checkType;
		let checkValue = link.checkValue;
		let target = link.target;
		let tooltip = null;
		let contItems = link.cont;
		if (contItems != null && contItems.length == 0) contItems = null;
		let subItems = link.subs;
		if (subItems != null && subItems.length == 0) subItems = null;
		if (name == '') name = null;
		if (url == '') url = null;
		if (icon == '') icon = null;
		if (target == '') target = null;
		let myPath = parentPath + '->' + name;
		link['output'] = {
			icon     : null,
			checkbox : null,
		};
		// Fill in defaults for missing elements
		if (name == null) {
			if (url != null) {
				name = url;  //name defaults to url
			} else {
				name = '_';  //indicates the name may be hidden
			}
		}
		// Change URL if target=manual
		if (target == 'manual') {
			let msg = 'Due to security reasons, this URL cannot be opened automatically.\nCopied URL \'' + url + '\' to clipboard.\n\nManually paste this to the address bar.';
			msg = msg.replaceAll('\'', '\\\'').replaceAll('\n', '\\n');
			tooltip = url;  //preserve original URL
			url = 'javascript:navigator.clipboard.writeText(\'' + url + '\');alert(\'' + encodeURI(msg) + '\');void(0)';
			target = null;
		}
		// Render the item
		// State variables for this item; will be used in closures
		let addItemContainer;  //function to add a container to put the Item into
		let addSubContainer;  //function to add a container to put the subItems into
		let addClosingElements = null;  //function to add closing elements to the container
		// Create element container
		if (level == 1) {
			// Render Item as Section
			//console.log('Render Section ' + name);
			let _itemContainer;
			let _subContainer;
			addItemContainer = function() {
				_itemContainer = document.createElement('h2');
				_itemContainer.className = 'section-name level1';
				container.appendChild(_itemContainer);
				return _itemContainer;
			}
			addSubContainer = function() {
				_subContainer = document.createElement('div');
				_subContainer.className = 'section';
				container.appendChild(_subContainer);
				return _subContainer;
			};
			addClosingElements = function() {
				let closingElements = document.createElement('hr');
				container.appendChild(closingElements);
			}
		} else if (level == 2) {
			// Render Item as Block
			//console.log('Render Block ' + name);
			let _blockContainer;
			let getBlockContainer = function() {
				if (_blockContainer) {
					return _blockContainer;
				}
				// Create a new _blockContainer
				_blockContainer = document.createElement('div');
				_blockContainer.className = 'block';
				container.appendChild(_blockContainer);
				if (subItems != null) {
					let expandIcon = document.createElement('span');  //container to display '-' or '+'
					expandIcon.className = 'resize-icon';
					expandIcon.textContent = UNICODE_BLACK_RIGHT_POINTING_TRIANGLE;
					_blockContainer.appendChild(expandIcon);
					let isExpanded = !parsed.blocksCollapsedInitially;  //true if block is expanded
					if (!parsed.blocksCollapsedAlwaysInitial) {
						// Use persistent value if available
						let v = Data.readItemExpanded(myPath);
						console.debug('Preset isExpanded for \'' + myPath + '\' to ' + v);
						if (v == 'false') {
							isExpanded = false;
						} else if (v == 'true') {
							isExpanded = true;
						}
					}
					let displayExpandState = function() {
						console.debug('Display isExpanded for \'' + myPath + '\' as ' + isExpanded);
						if (isExpanded) {
							// Expand this block
							_blockContainer.classList.add('expanding');
							_blockContainer.onanimationend = function() {
								_blockContainer.classList.remove('collapsed');
								_blockContainer.classList.remove('expanding');
							};
							// Reflect action of resize-icon
							expandIcon.title = 'Hide';
						} else {
							// Collapse this block
							_blockContainer.classList.add('collapsing');
							_blockContainer.onanimationend = function() {
								_blockContainer.classList.add('collapsed');
								_blockContainer.classList.remove('collapsing');
							};
							// Reflect action of resize-icon
							expandIcon.title = 'Show';
						}
					};
					expandIcon.onclick = function() {
						isExpanded = !isExpanded;
						console.debug('Set isExpanded for \'' + name + '\' to ' + isExpanded);
						Data.writeItemExpanded(myPath, isExpanded);
						displayExpandState();
					};
					addClosingElements = function() {
						// Display the initial state
						//displayExpandState();  //display initial state
						if (isExpanded) {
							expandIcon.title = 'Hide';
						} else {
							_blockContainer.classList.add('collapsed');
							expandIcon.title = 'Show';
						}
					}
				}
				return _blockContainer;
			}
			let _itemContainer;
			let _subContainer;
			addItemContainer = function() {
				_itemContainer = document.createElement('span');
				_itemContainer.className = 'block-name level2';
				getBlockContainer().appendChild(_itemContainer);
				return _itemContainer;
			}
			addSubContainer = function() {
				_subContainer = document.createElement('div');
				_subContainer.className = 'items block-items';
				let sliderContainer = document.createElement('div');
				sliderContainer.className = 'slider-container';
				sliderContainer.appendChild(_subContainer);
				getBlockContainer().appendChild(sliderContainer);
				return _subContainer;
			}
		} else {
			// Render Item is (sub-)Item
			//console.log('Render Item ' + name);
			let _itemContainer;
			let _subContainer;
			addItemContainer = function() {
				let groupContainer;
				if (contItems != null) {
					groupContainer = document.createElement('div');  //make a div for the continuation group
					groupContainer.className = 'group';
					container.appendChild(groupContainer);
				} else {
					groupContainer = container;  //there is no group, use same container
				}
				_itemContainer = document.createElement('div');
				_itemContainer.className = 'item level' +  level;
				groupContainer.appendChild(_itemContainer);
				return _itemContainer;
			}
			addSubContainer = function() {
				_subContainer = document.createElement('div');
				_subContainer.className = 'items';
				container.appendChild(_subContainer);
				return _subContainer;
			}
		}
		// Create element itself
		if (name == '---') {
			// Special separator item
			let item = document.createElement('hr');
			item.className = 'separator';
			container.appendChild(item);
		} else {
			let itemContainer = addItemContainer();
			// The containers are structured as follows:
			// - groupContainer: Only if there are continued Items
			//     - itemContainer: Holds the entire (Sub)Item
			//         - checkbox: Only if it is a checkbox item
			//         - linkContainer: Only if there is a URL
			//             - icon: In itemContainer if there is no linkContainer
			//             - textContainer: Only present if there is a name
			//                              In itemContainer if there is no linkContainer
			//                 - text: name
			//         - continued items
			//     - subContainer: Only if there are subItems

			// Declare textContainer to hold the name/label
			let textContainer = null;
			let setTextClass = (className, add) => addClass(textContainer, className, add);
			let textContainer_maybe = itemContainer;  //null if we must create a separate one

			// Create checkbox
			let checkbox = outputCheckbox(checkType, checkValue, link.lineNum);
			if (checkbox.present) {
				textContainer_maybe = null;  //for styling purposes
				link.output.checkbox = checkbox;
			}

			// Create hyperlink
			let hyperlink = null;
			if (url != null) {
				hyperlink = document.createElement('a');
				hyperlink.href = url;
				hyperlink.className = 'link';
				if (target != null)
					hyperlink.target = target;
				if (tooltip != null)
					hyperlink.title = tooltip;
				textContainer_maybe = hyperlink;  //hyperlink can serve as textContainer
			}

			// Create icon_control
			let icon_control = renderIcon(parsed, null, icon, url);
			if (icon_control.present) {
				textContainer_maybe = null;  //for styling purposes
				link.output.icon = icon_control;
			}

			// Determine name/label to display
			if (name != null) {
				if (name == '_') {
					// Name indicates it should not be displayed.
					// Do this only if this doesn't lead to
					// unclickable links and the like.
					if (icon_control.present) {
						// There is an icon that is clickable too.
						name = null;
					} else if (url == null) {
						// This item is not clickable anyway.
						name = null
					} else {
						// We cannot hide it, give it a better name
						if (level == 1) name = 'Heading';
						else if (level == 2) name = 'Block';
						else name = 'Item';
					}
				}
			}

			// Add checkbox to the itemContainer
			if (checkbox.present) {
				itemContainer.appendChild(checkbox.element);
			}

			// Add hyperlink to itemContainer
			// Alias linkContainer to hyperlink if it exists, itemContainer otherwise
			let linkContainer;  //this container holds the link
			if (hyperlink != null) {
				itemContainer.appendChild(hyperlink);
				linkContainer = hyperlink;
			} else {
				linkContainer = itemContainer;
			}

			// Add icon_control to linkContainer
			if (icon_control.element != null) {
				linkContainer.appendChild(icon_control.element);
			}

			// Create a textContainer if necessary and add it to linkContainer
			if (name != null) {
				if (textContainer_maybe != null) {
					// This control can serve as textContainer
					textContainer = textContainer_maybe;
				} else {
					// Create a new control
					textContainer = document.createElement('span');
					linkContainer.appendChild(textContainer);
				}
				let containers = [ textContainer ];  //stack of nested containers
				let openElem = (className) => {
					let el = document.createElement('span');
					if (className != null) el.className = className;
					containers[0].appendChild(el);
					containers.unshift(el);
				};
				let closeElem = () => {
					containers.shift();
				};
				let addElem = (text, className) => {
					if (text == '') return;
					let nest = className != null;
					if (nest) openElem(className);
					containers[0].appendChild(document.createTextNode(text));
					if (nest) closeElem();
				};
				// Process *...* to make strong
				// Definitions:
				// - A Delimiter is a sequence of '*' characters with no
				//   extra '*' before or after.
				// - A StringGroup is a sequence 'Delimiter text Delimiter'.
				// Rules:
				// - There should be spaces around the StrongGroup, i.e. before
				//   the start Delimiter and after the end Delimiter.
				//   This is slightly restrictive by design (avoid false
				//   positives).
				// - There should be no spaces directly after the start
				//   Delimiter or before the end Delimiter. This should be
				//   no problem, because you can't see a bold space.
				// - There should be no repetition of the Delimiter inside
				//   the StrongGroup. To avoid this, the Delimiter's length can
				//   be chosen differently.
				//
				// Regex to match StrongGroup, capture:
				// - 1: open delimiter
				// - 2: text
				// - 3: close delimiter
				let reSG = /(?<=^|\s)(\*+)(?!\*|\s)((?:(?!\1).)*?)(?<!\*|\s)(\1)(?=\s|$)/;
				// Split on this regex. Expect 3 captures per match and n+1
				// parts for n separator matches. This means for n matches,
				// the array should have 3*n + n+1 = 4*n+1 elements.
				// Or n = (length-1)/4, which should be integer.
				let parts = name.split(reSG);
				if (parts.length > 1 && ((parts.length-1) % 4) == 0) {
					//console.devlog('Found *...*: ' + parts.length + ' elements');
					//console.log(parts);
					let i = 0;
					// Add first literal
					addElem(parts[i++]);
					while (i < parts.length-1) {
						openElem('strong');
						addElem(parts[i++], 'delim-open');  //opening delimiter
						addElem(parts[i++], 'delim-text');  //delimited text
						addElem(parts[i++], 'delim-close');  //closing delimiter
						closeElem();
						addElem(parts[i++]);  //inbetween text
					}
				} else {
					addElem(name);
				}
				if (checkbox.present) {
					// This is a checkbox item, give the name the correct class
					setTextClass('checkbox-label', true);
					checkbox.associateLabel(textContainer);
				} else {
					setTextClass('link-name', true);
				}
			}

			// If there is continuation, output those items in this itemContainer too
			if (contItems != null) {
				outputItems(contItems, level, itemContainer, myPath, cancel);
			}
		}
		// Create sub-Items in container
		if (subItems != null) {
			if (addSubContainer) {
				let subContainer = addSubContainer();
				outputItems(subItems, level+1, subContainer, myPath, cancel);
			}
		}
		// Add closing elements
		if (addClosingElements) {
			addClosingElements();
		}
	}

	// Output a <div> element as next child of the container.
	function outputText(lines, container) {
		let html = lines.join('\n');
		let div = document.createElement('div');
		div.className = 'text-block';
		div.innerHTML = html;
		container.appendChild(div);
	}

	// }}}

	// Output Checkbox {{{

	// Create element for a checkbox and return that.
	// Arguments:
	// - type: Type of checkbox, null if no checkbox.
	// - value: Current value of checkbox.
	// - lineNum: Linenumber where this checkbox is in the links. This is used
	//   to update the value when the checkbox' value is changed.
	// Returns object with:
	// - present: True if a checkbox was generated.
	// - element: Represents the checkbox, may be null.
	// - associateLabel: Function to call to associate this checkbox with its
	//   label. The single argument should be a DOM element, representing the
	//   label.
	function outputCheckbox(type, value, lineNum) {
		// If type==null, don't make a checkbox
		let retval = {
			present             : false,
			element             : null,
			associateLabel      : null,
			// Transient data
			selFirstMe          : null,  //true if my current selection is first
			selFirstAllParents  : null,  //true if all parents have current selection first
			selFirstAllChildren : null,  //true if all children's current selection is first
			// parent/children of this checkbox, will be filled in later
			parent              : null,
			children            : [],
			iterateChildren     : iterateChildren,  //iterate the children, calling specified function
			updateSelFirst      : updateSelFirst,  //propagate selFirstXxx
		};
		if (type == null) return retval;

		// Find the checkbox definition for this type
		let def = parsed.checkboxDefs[type];

		// Placeholder for the associated label
		let labelElement = null;
		let setLabelClass = (className, add) => {
			addClass(labelElement, className, add);
			addClass(labelElement, 'not-' + className, !add);
		};
		let initialSetLabel = null;  //will be set to init function
		retval.associateLabel = element => {
			labelElement = element;
			if (initialSetLabel) initialSetLabel();
		};

		// Function to update the Links
		let updateLinks = function(newCheck) {
			const re = new RegExp('(^(?:[^\\n]*\\n){' + (lineNum - 1) + '}\\s*(?:[-*]\\s*)?)\\[(?:\\s+|\\S+)?\\]');
			let links = Data.readLocalLinks();
			let newLinks = links.replace(re, '$1' + newCheck);
			if (newLinks != links) {
				links = newLinks;
				Data.writeLocalLinks(links);
				if (PendingUpload) {
					PendingUpload.add(() => {
						let links = Data.readLocalLinks();
						uploadLinks(links);
					});
				} else {
					uploadLinks(links);
				}
			} else {
				console.error('RegExp did not change Links: ', re);
			}
		}

		// Render the checkbox as specified by the definition
		let checkbox = null;
		if (def == null) {
			// Default checkbox: Use the standard <input> element
			checkbox = document.createElement('input');
			checkbox.type = 'checkbox';
			checkbox.className = 'todo-checkbox';
			checkbox.onchange = function() {
				// Update Links
				let newCheck;
				if (checkbox.checked) {
					// Change checkbox to checked
					console.log('Check checkbox on line ' + lineNum);
					newCheck = '[x]';
					retval.selFirstMe = false;
				} else {
					// Change checkbox to checked
					console.log('Uncheck checkbox on line ' + lineNum);
					newCheck = '[ ]';
					retval.selFirstMe = true;
				}
				updateLinks(newCheck);
				// Update label
				setLabelClass('checked', checkbox.checked);
				// Update parents/children
				updateSelFirst(true);
			};
			let isChecked = value != null && value != '' && value != ' ';
			checkbox.checked = isChecked;
			retval.selFirstMe = !isChecked;
			initialSetLabel = () => setLabelClass('checked', isChecked);
			// Set return value
			retval.present = true;
			retval.element = checkbox;
		} else {
			// The checkbox is defined by def
			let checkbox = document.createElement('span');
			checkbox.className = 'custom-checkbox';
			let sel = def.options[value];
			if (sel == null) sel = def.options[def.first];
			let isFirst = sel.name == def.first;
			retval.selFirstMe = isFirst;
			let icon = renderIcon(parsed, null, sel.value);
			checkbox.appendChild(icon.element);
			checkbox.onclick = function() {
				// Determine next value
				sel = def.options[sel.next];
				isFirst = sel.name == def.first;
				retval.selFirstMe = isFirst;
				// Update Links
				if (sel != null) {
					console.log('Change checkbox on line ' + lineNum + ' to ' + sel.name);
					let newCheck = '[' + sel.name + ']';
					updateLinks(newCheck);
				}
				// Update icon
				let newIcon = renderIcon(parsed, null, sel.value);
				checkbox.replaceChild(newIcon.element, icon.element);
				icon = newIcon;
				// Update label
				setLabelClass('first-option', isFirst);
				// Update parents/children
				updateSelFirst(true);
			};
			initialSetLabel = () => setLabelClass('first-option', isFirst);
			// Set return value
			retval.present = true;
			retval.element = checkbox;
		}

		// Callbacks if parent/child changed
		function iterateChildren(func, recurse) {
			let func2;
			if (recurse) {
				func2 = child => {
					func(child);
					child.iterateChildren(func, recurse);
				};
			} else {
				func2 = func;
			}
			for (let i = 0; i < retval.children.length; ++i) {
				func2(retval.children[i]);
			}
		}
		function updateSelFirst(down) {
			//console.devlog('Checkbox on line ' + lineNum + ': updateSelFirst(' + (down ? 'down' : 'up') + ')');
			// Parent may have set a new value
			retval.selFirstAllChildren = true;
			iterateChildren(child => {
				if (down) {
					// Propagate selFirstMe and selFirstAllParents down
					child.selFirstAllParents = retval.selFirstMe && retval.selFirstAllParents;
					// Recurse down
					child.updateSelFirst(true);
				}
				// Propagate selFirstAllChildren up
				if (!child.selFirstMe || !child.selFirstAllChildren) {
					retval.selFirstAllChildren = false;
				}
			});
			// Recurse up
			if (retval.parent != null) {
				retval.parent.updateSelFirst(false);
			}
			//console.log(retval);
			// Update Appearance
			let classes = {};
			let anyParentChecked = retval.selFirstAllParents === false;
			classes['any-parent-checked'] = anyParentChecked;
			let anyChildChecked = retval.selFirstAllChildren === false;
			classes['any-child-checked'] = anyChildChecked;
			let selfChecked = !retval.selFirstMe;
			classes['self-checked'] = selfChecked;
			// Apply classes
			let target = retval.element.parentElement;  //the itemContainer
			for (className in classes) {
				addClass(target, className, classes[className]);
			}
		}

		return retval;
	}

	// }}}
}

// Render Icon {{{

// Create element for an icon and return that.
// If alt_text is defined, use that.
// icon_url is what is specified in the icon=URL argument, see explanation at
// the top of this file.
// Returns object with:
// - present: True if a non-empty icon was generated.
// - element: Represents the icon, may be null.
//
// To retrieve the icon, first try the primary URL. If that fails and skip_alternatives==false,
// try these alternatives:
// - http://www.google.com/s2/favicons?domain=<target_url domain>
// - http://www.google.com/s2/favicons?domain=<icon_url domain>
function renderIcon(parsed, alt_text, icon_url, target_url, skip_alternatives = false) {
	// By default, construct icon_url from target_url
	if ((icon_url == null || icon_url == 'default') && target_url != null) {
		// Check if the target domain is in IconDefs
		let found = null;
		let m = target_url.match(/^\w+:\/\/([a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)+)/);
		if (m) {
			let domain = m[1];
			let replacement = parsed.resolveIconDefs(domain);
			if (replacement != domain) found = replacement;
		}
		// If not found, use the default URL
		if (found == null) {
			found = getDefaultIconUrl(target_url);
		}
		icon_url = found;
	}

	// See if icon_url is an IconDef and resolve it
	if (icon_url != null) {
		icon_url = parsed.resolveIconDefs(icon_url);
	}

	let icon_present = false;
	let icon_element = null;

	// Render icon_url
	let m;  //for regex matches
	if (icon_url == null) {
		console.debug('Loading icon for target \'' + target_url + '\': null');
	} else if (icon_url == 'none') {
		console.debug('Loading icon for target \'' + target_url + '\': \'' + icon_url + '\'');
	} else if (m = icon_url.match(/^html:(.+)/i)) {
		let html = m[1].replace(/&(?:sp|spc|space);/ig, ' ');
		// Create a 'data:...' pseudo URL that holds the data as SVG and put this text in a text node.
		let iconDiv = document.createElement('div');
		iconDiv.className = 'item-icon text-icon';
		let htmlDiv = document.createElement('div');
		htmlDiv.innerHTML = html;  //also takes care of HTML rendering
		FillScaler.observe(htmlDiv);
		iconDiv.appendChild(htmlDiv);
		icon_element = iconDiv;
		icon_present = true;
	} else {
		console.debug('Loading icon for target \'' + target_url + '\': \'' + icon_url + '\'');
		let img = document.createElement('img');
		img.className = 'item-icon';
		icon_present = true;
		if (icon_url == 'empty') {
			img.style.visibility = 'hidden';
			icon_present = false;  //there is an image, but still empty
		} else if (m = icon_url.match(/^char:(.+)/i)) {
			let text = m[1];
			// Replace 'U+XXX...'
			function hexChar(hex) {
				let i = Number('0x' + hex);
				if (i > 0xFFFF) {
					// JavaScript only supports UTF-16, so for codepoints
					// above 0x10000, surrogate pairs are used, see
					// https://en.wikipedia.org/wiki/UTF-16#U+0000_to_U+D7FF_and_U+E000_to_U+FFFF
					let w1 = 0xD800 + (((i - 0x10000) >> 10) & 0x3FF);  //higher 10 bits
					let w2 = 0xDC00 + (i & 0x3FF);  //lower 10 bits
					return String.fromCharCode(w1, w2);
				} else {
					return String.fromCharCode(i);
				}
			}
			text = text.replace(/^U\+([0-9a-f]+)$/i, s => hexChar(s.substring(2)));
			// Create a 'data:...' pseudo URL that holds the data as SVG and put this text in a text node.
			img.classList.add('text-icon');
			icon_url = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">' + text + '</text></svg>';
			img.src = icon_url;
		} else {
			let alternatives = [], methods = [], urls = [];  //prepare options to use for the icon
			if (m = icon_url.match(/^alt(?::([^?]+))?(?:\?(.+))?/i)) {
				// icon_url contains an alt specification
				let method = m[1];
				let url = m[2];
				if (method == null || method == '' || method == 'any' || method == '*') {
					// Add all known methods
					methods.push('google');
				} else {
					// Add only the specified method
					methods.push(method);
				}
				if (url != null && url != '') {
					// Add the specified URL only
					urls.push(url);
				} else {
					// Add the icon_url (but that doesn't contain a URL) and target_url
					if (target_url != null && target_url != '') {
						urls.push(target_url);
					}
				}
			} else {
				// icon_url contains a URL of the icon
				alternatives.push(icon_url);
				if (!skip_alternatives) {
					// Try the alternatives in order of 'likely correct'.
					// Note that the google-favicons always returns an image, even a generic one, so it
					// will always prevent further alternatives to be attempted.
					methods.push('google');
					if (icon_url != null) {
						urls.push(icon_url);
					}
					if (target_url != null) {
						urls.push(target_url);
					}
				}
			}
			//console.log('All methods for ' + icon_url); console.log(methods);
			//console.log('All urls for ' + icon_url); console.log(urls);
			// Go through methods and urls and add alternatives
			for (let m = 0; m < methods.length; ++m) {
				let method = methods[m];
				for (let u = 0; u < urls.length; ++u) {
					if (method == 'google') {
						alternatives.push(getGoogleAltIconUrl(urls[u]));
					} else {
						console.error('Unknown alt icon method: ' + method);
					}
				}
			}
			//console.log('All alternatives for ' + icon_url); console.log(alternatives);
			// Remove duplicates
			let seen = {};
			let alt_list = alternatives;  //may have duplicates
			alternatives = [];  //get the unique ones
			for (let a = 0; a < alt_list.length; ++a) {
				if (!seen[alt_list[a]]) {
					seen[alt_list[a]] = true;
					alternatives.push(alt_list[a]);
				}
			}
			//console.log('All unique alternatives for ' + icon_url); console.log(alternatives);
			// Set the icon urls until we find one that works
			let try_next = function() {
				if (alternatives.length > 0) {
					// Try next alternative
					//console.log('alternatives.length=' + alternatives.length);
					//console.log('alternatives[0]=' + alternatives[0]);
					let alt = alternatives.shift();
					//console.log('alternatives.length=' + alternatives.length);
					if (img.src != null && img.src != '') {
						console.warn('Cannot load icon \'' + img.src + '\', try \'' + alt + '\'');
					}
					img.src = alt;
				} else {
					// Stop trying
					console.error('Cannot load icon: ' + img.src);
					if (alt_text != null) {
						// prepare to show the alt text
						img.src = '';
					} else {
						// hide entire image
						img.style.visibility = 'hidden';
					}
					img.onerror = null;  //stop handling errors
				}
			}
			img.onerror = try_next;
			try_next();  //set first alternative
		}
		if (alt_text != null) {
			img.alt = alt_text;
		}
		icon_element = img;
	}

	// Return the URL where the default icon should be.
	function getDefaultIconUrl(site_url) {
		return site_url.replace(/(?:(?:(?<!\/)\/(?!\/)|\?|#).*)?$/, '/favicon.ico');  //replace first single '/', '?' or '#' and onwards
	}

	// Return the URL for an icon of the site_url's domain.
	// This method uses the Google database.
	function getGoogleAltIconUrl(site_url) {
		let domain = site_url
			.replace(/^[^\/]*\/\//, '')  //remove scheme
			.replace(/\/.*/, '');  //remove path
		return 'http://www.google.com/s2/favicons?domain=' + domain;
	}

	return {
		present : icon_present,
		element : icon_element,
	};
}

// }}}

// Define a ResizeObserver that is used to resize entries to 100% of their
// parent's size. This is used for icons that are defined with html:<x>.
var FillScaler = new ResizeObserver(function(entries) {
	for (let entry of entries) {
		let element = entry.target;
		// Get entries current size
		let w, h;
		if (entry.borderBoxSize) {
			let rect = entry.borderBoxSize[0];  //area of 1st (and only) fragment
			let writingMode = element.style.writingMode;
			//console.log('FillScaler: Writing mode ' + writingMode);
			if (writingMode.match(/^vertical/i)) {
				// Vertical writing-mode, so inline direction is vertical
				h = rect.inlineSize;
				w = rect.blockSize;
			} else {
				// Assume horizontal writing-mode, so inline direction is horizontal
				w = rect.inlineSize;
				h = rect.blockSize;
			}
		} else {
			let rect = entry.contentRect;
			w = entry.contentRect.width;
			h = entry.contentRect.height;
		}
		console.log('FillScaler: Element size ' + w + ' x ' + h);
		// Get parent's current size
		let parent = element.parentElement;
		let pw = parent.offsetWidth;
		let ph = parent.offsetHeight;
		//console.log('FillScaler: Parent size ' + pw + ' x ' + ph);
		// Calculate new scaling factor
		let scaleX = pw / w;
		let scaleY = ph / h;
		//console.log('FillScaler: Scale with ' + scaleX + ' x ' + scaleY);
		// Check if the change is big enough
		let changeX = element._scaleX / scaleX;
		let changeY = element._scaleY / scaleY;
		//console.log('FillScaler: Scale change ' + changeX + ' x ' + changeY);
		if (isNaN(changeX) || changeX < 0.98 || changeX > 1.02 || isNaN(changeY) || changeY < 0.98 || changeY > 1.02) {
			// More than 2% change
			console.log('FillScaler: Set scale ' + scaleX + ' x ' + scaleY);
			element._scaleX = scaleX;
			element._scaleY = scaleY;
			entry.target.style.scale = scaleX + ' ' + scaleY;
		} else {
			console.log('FillScaler: Scale change too small ' + changeX + ' x ' + changeY);
		}
	}
});

// }}}

// SearchBox related functions {{{

// The search functions will be accessed by name (lower case identifier).
// Every identifier has sub-keys for different functions.
// A search function has the search query as input and should return a URL to
// go to for the results.

var SearchFunction = {
	'duck duck go' : {
		'text'   : getTemplateUrl('https://duckduckgo.com?q=%urlinput'),
	},
	'google' : {
		'text'   : getTemplateUrl('https://www.google.com/search?q=%urlinput'),
	},
	'wikipedia' : {
		'text'   : getTemplateUrl('https://www.wikipedia.org/wiki/Special:Search?go=Go&search=%urlinput'),
	},
	'youtube' : {
		'text'   : getTemplateUrl('https://www.youtube.com/results?search_query=%urlinput'),
	},
	'wayback machine' : {
		'text'   : getWaybackSearchUrl,
		'domain' : getWaybackDomainUrl,
	},
	'google maps' : {
		'text'   : getTemplateUrl('https://maps.google.com/?q=%urlinput'),
	},
	'default' : {
		'text'   : getNoUrl,
		'domain' : getWithSchemaUrl,
	},
};

// This function adds the function to SearchFunction for this identifier.
// searchFunction should have the text as input and return a results URL.
// This function is available for use in the configuration.
function registerSearchFunction(identifier, searchFunction, what = 'text') {
	let id = identifier.toLowerCase();
	if (!(id in SearchFunction)) {
		SearchFunction[id] = {};
	}
	SearchFunction[id][what] = searchFunction;
}

// This function adds the urlTemplate to SearchFunction for this identifier.
// See getTemplateUrl() for templateUrl.
// This function is available for use in the configuration.
function registerSearchTemplate(identifier, urlTemplate, what = 'text') {
	let searchFunction = getTemplateUrl(urlTemplate);
	registerSearchFunction(identifier, searchFunction, what);
}

// This function finds the registered searchFunction for this identifier.
// It then calls it with the searchText and returns the URL.
// Returns null if not found.
// This function is available for use in the configuration.
function getRegisteredSearchUrl(identifier, searchText, what = 'text') {
	let id = identifier.toLowerCase();
	if (id in SearchFunction && what in SearchFunction[id]) {
		return SearchFunction[id][what](searchText);
	} else {
		return null;
	}
}

// Return a URL to handle the address (ie beautify it to go to it).
function getWithSchemaUrl(address) {
	let url = address;
	if (!url.match(/^[\w+-]+:/)) {
		url = 'http://' + url;  //add default scheme
	}
	return url;
}

// This is a dummy search function, that can be used as a default.
function getNoUrl(intput) {
	return null;
}

// This function returns a function that uses the template to construct a URL.
// The template is a URL with the following placeholders:
// - %input: Replaced with the supplied input value.
// - %urlinput: Replaced with the URL-encoded input value.
function getTemplateUrl(template) {
	return function(input) {
		let encoded_input = encodeURIComponent(input).replace(' ', '+');
		return template
			.replace('%input', input)
			.replace('%urlinput', encoded_input);
	};
}

// Returns a URL to perform a lookup for the domain with Wayback Machine.
function getWaybackDomainUrl(domain) {
	let ts = getWaybackTimestamp();
	return 'https://web.archive.org/web/' + ts + '/' + domain;
};

// Returns a URL to perform a search for input with Wayback Machine.
function getWaybackSearchUrl(input) {
	let ts = getWaybackTimestamp();
	let encoded_input = encodeURIComponent(input).replace(' ', '+');
	return 'https://web.archive.org/web/' + ts + '/' + encoded_input;
};

// Create a Wayback Machine timestamp that can be used in queries.
function getWaybackTimestamp(date = new Date()) {
	let pad = function(number, positions) {
		let neg = false;
		if (number < 0) {
			neg = true;
			positions--;  //space for '-'
			number = -number;
		}
		let s = '';
		for (let i = 2, limit = 10; i <= positions; ++i, limit *= 10) {
			if (number < limit) s += '0';
		}
		s += number;
		if (neg) s = '-' + s;
		return s;
	};
	// I assume the format is 'yyyymmddhhmmss*' with yyyy the year
	// to query and the rest '0'.
	let timestamp = pad(date.getFullYear(), 4) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		'*';
	return timestamp;
}

// Process search input.
// Redirects to search.
// May return if search input is not clear.
function processSearchInput(searchBox, getSearchUrl, getDomainSearchUrl = getWithSchemaUrl) {
	let input = searchBox.value;
	if (input.match(/^\s*$/)) {
		console.log('Empty search string');
		// Set the blink animated style
		searchBox.classList.add('blink');
		searchBox.onanimationend = function() {
			//console.log('animation end');
			searchBox.classList.remove('blink');
		};
	} else {
		let m = input.match(/^\s*(\S+\.\S+)\s*$/);
		let url = null;
		if (m && getDomainSearchUrl) {
			//console.log('Looks like URL');
			url = getDomainSearchUrl(m[1]);
			console.log('Go to URL \'' + url + '\'');
		} else {
			url = getSearchUrl(input);
			console.log('Search \'' + url + '\'');
		}
		if (url) {
			window.location.href = url;
		} else {
			console.log('No URL to go to');
		}
	}
}

// Create search button to container and set up the event callback.
// This also adds icons to the buttons. Do that here instead of with
// static HTML, because I saw that the browser tries to render static
// images before the JavaScript generated ones and I'd like to render
// the links as soon as possible.
// The displayed icon is specified by icon_url. If this is 'alt', the
// target domain is derived from getSearchUrl().
function addSearchButton(parsed, container, search_box, button_id, label_text, tooltip, icon_url, getSearchUrl, getDomainSearchUrl) {
	let btn = document.createElement('button');
	if (btn) {
		// Configure the button
		btn.id = 'BtnSearch' + button_id;
		btn.className = 'button';
		btn.onclick = function() {
			processSearchInput(search_box, getSearchUrl, getDomainSearchUrl);
			return false;  //skip default handling
		}
		btn.title = tooltip;

		// Add icon
		let target_domain = getSearchUrl('__favicon_check__');
		//console.log('target_domain=' + target_domain);
		//console.log('favicon=' + getDefaultIconUrl(target_domain));
		// When determining the icon, don't consider alternatives,
		// except when icon_url == 'alt...'
		let icon = renderIcon(parsed, tooltip, icon_url, target_domain, true);
		if (icon.element != null) btn.appendChild(icon.element);

		// Add link text
		if (label_text != null) {
			let label = document.createElement('span');
			label.className = 'label';
			let textNode = document.createTextNode(label_text);
			label.appendChild(textNode);
			btn.appendChild(label);
		}

		// Add the button to the container
		container.appendChild(btn);
	}
}

function addSearchButtons(parsed, searchBox, container) {
	for (let i = 0; i < parsed.searchButtonDefs.length; ++i) {
		// Get the fields from the definition
		let def = parsed.searchButtonDefs[i];
		let f = 0;

		let id = def[f++];
		if (!id) continue;  //id is mandatory, ignore this entry if absent
		let key = id.toLowerCase();  //lower case version
		let label = def[f++];
		let tooltip = def[f++];
		let icon = def[f++];
		let urlTemplate = def[f++];

		// Register UrlTemplate (if specified)
		if (urlTemplate) {
			registerSearchTemplate(key, urlTemplate);
		}

		// Determine referenced Search URL Functions
		let getSearchUrl = null, getDomainSearchUrl = null;
		let searchFunction = SearchFunction[key];
		if (searchFunction) {
			getSearchUrl = SearchFunction[key]['text'];
			getDomainSearchUrl = SearchFunction[key]['domain'];
		}

		// Determine Label
		if (!label) {
			label = id;
		} else if (label == '_') {
			label = null;
		}

		// Determine Tooltip
		if (!tooltip) {
			tooltip = id;
		} else if (tooltip == '_') {
			tooltip = null;
		}

		// Determine Icon
		if (!icon) {
			if (getSearchUrl) {
				// Search URL function is defined. This is
				// needed to retrieve the 'default' icon.
				icon = 'default';
			} else {
				// There is no Search URL function, use a
				// standard magnifying glass icon.
				icon = 'char:' + UNICODE_LEFT_POINTING_MAGNIFYING_GLASS;
			}
		}

		// Determine final Search URL Function
		if (!getSearchUrl) {
			// No Search Function, use default (assume it exists)
			getSearchUrl = SearchFunction['default']['text'];
		}

		// Determine final Domain Search URL Function
		if (!getDomainSearchUrl) {
			// No Search Function, use default (assume it exists)
			getDomainSearchUrl = SearchFunction['default']['domain'];
		}

		// Log the fields
		console.log('addSearchButtons: Identifier=\'' + id + '\'');
		console.debug('addSearchButtons: Label=\'' + label + '\'');
		console.debug('addSearchButtons: Tooltip=\'' + tooltip + '\'');
		console.debug('addSearchButtons: Icon=\'' + icon + '\'');
		console.debug('addSearchButtons: UrlTemplate=\'' + urlTemplate + '\'');
		console.debug('addSearchButtons: getSearchUrl=\'' + getSearchUrl + '\'');
		console.debug('addSearchButtons: getDomainSearchUrl=\'' + getDomainSearchUrl + '\'');
		//console.debug(SearchFunction);

		// Create the button
		addSearchButton(parsed, container, searchBox, id, label, tooltip, icon, getSearchUrl, getDomainSearchUrl);
	}
}

// }}}

// Edit Settings {{{

// These variables will be set in initSettingsPanel()
// Function to open the Settings panel
let showSettingsPanel = null;
// Function to update the displayed Dirty state
let updateSettingsDirty = null;

// Set up the events for the settings panel.
function initSettingsPanel() {
	console.important('Initialize Settings panel...');

	// Assign iconBarClosed, iconBarOpen and settingsPanel variables
	let iconBarClosed = document.getElementById('SettingsIconBarClosed');  //iconbar for closed status
	let iconBarOpen = document.getElementById('SettingsIconBarOpen');  //iconbar for open status
	let settingsPanel = null;
	let iconOpen, iconSave, iconClear, iconCancel, warningDirty;

	// Status
	let visible = false;

	// Other global variables for Settings (will be assigned in createSettings())
	let settingsText;
	let optionEntries = [];

	// Create the minimal hooks (expose functions) and defer rest at first showing
	showSettingsPanel = showSettings;
	updateSettingsDirty = updateDirty;
	// Create iconOpen
	iconOpen = document.createElement('span');
	setUnicodeText(iconOpen, UNICODE_GEARS, '[Settings]');
	iconOpen.title = 'Settings';
	iconOpen.className = 'settings-icon';
	iconOpen.onclick = showSettings;
	iconBarClosed.appendChild(iconOpen);

	// Create rest of the Settings panel. This is called at first showing.
	function createSettings() {
		// First get the panels from the DOM and ensure they're found
		settingsPanel = document.getElementById('SettingsForm');
		if (!settingsPanel) return false;
		let settingsArea = document.getElementById('SettingsArea');
		if (!settingsArea) return false;

		// Now create the basic buttons to at least be able to close
		// the panel. Keep the buttons basic to not end up in a
		// exception, breaking the buttons to close.

		// Create iconSave
		iconSave = document.createElement('span');
		iconSave.title = 'Save (Ctrl-S)';
		iconSave.className = 'settings-icon';
		iconSave.onclick = () => hideSettings(true);
		iconBarOpen.appendChild(iconSave);
		// Create iconClear
		iconClear = document.createElement('span');
		iconClear.title = 'Clear';
		iconClear.className = 'settings-icon';
		iconClear.onclick = () => hideSettings('clear');
		iconBarOpen.appendChild(iconClear);
		// Create iconCancel
		iconCancel = document.createElement('span');
		iconCancel.title = 'Cancel';
		iconCancel.className = 'settings-icon';
		iconCancel.onclick = () => hideSettings(false);
		iconBarOpen.appendChild(iconCancel);

		setUnicodeText(iconSave, UNICODE_WHITE_HARD_SHELL_FLOPPY_DISK, UNICODE_CHECK_MARK, '[OK]');
		setUnicodeText(iconClear, UNICODE_EMPTY_DOCUMENT, UNICODE_CLOCKWISE_OPEN_CIRCLE_ARROW, 'C');
		setUnicodeText(iconCancel, UNICODE_CANCELLATION, UNICODE_CROSS_MARK + UNICODE_VARIATION_SELECTOR_15, 'X');

		//// Create buttonBar
		//let buttonBar = document.createElement('div');
		//buttonBar.className = 'buttonbar';
		//settingsArea.appendChild(buttonBar);
		//
		//// Create btnSave
		//let btnSave = document.createElement('button');
		//btnSave.textContent = 'Save';
		//btnSave.className = 'button';
		//btnSave.onclick = () => { hideSettings(true); return false }
		//buttonBar.appendChild(btnSave);
		//// Create btnClear
		//let btnClear = document.createElement('button');
		//btnClear.textContent = 'Clear';
		//btnClear.className = 'button';
		//btnClear.onclick = () => { hideSettings('clear'); return false }
		//buttonBar.appendChild(btnClear);
		//// Create btnCancel
		//let btnCancel = document.createElement('button');
		//btnCancel.textContent = 'Cancel';
		//btnCancel.className = 'button';
		//btnCancel.onclick = () => { hideSettings(false); return false }
		//buttonBar.appendChild(btnCancel);


		// Configure settingsPanel
		settingsPanel.onkeydown = function(e) {
			//console.log('KeyCode=' + e.keyCode);
			if (e.ctrlKey && e.key == 's') {
				if (visible) hideSettings(true);
				return false;  //stop default button action
			}
			return true;
		};
		// Bind entire document
		//window.addEventListener('keydown', function(e) {
		//	//console.log('KeyCode=' + e.keyCode);
		//	if (e.keyCode == 27) {
		//		// This is the Esc key
		//		if (visible) {  //only if Settings visible
		//			hideSettings(false);
		//			e.preventDefault();
		//			return false;  //stop default button action
		//		}
		//	}
		//	return true;
		//});

		// Create hidden warnings
		warningDirty = document.createElement('div');
		warningDirty.className = 'alert-box hidden';
		warningDirty.innerHTML = `
<span class="label">WARNING</span>: Previous online save was unsuccessful. Choose one of the following:<br>
&bull; <span class="accent">Save</span> will overwrite online changes with this configuration, discarding changes that have been made online.<br>
&bull; <span class="accent">Clear</span> will discard local changes and download the online version.<br>
&bull; <span class="accent">Cancel</span> will not make any changes.
`;
		settingsArea.appendChild(warningDirty);

		// Create settingsText
		settingsText = document.createElement('textarea');
		settingsText.wrap = 'off';
		settingsText.autocomplete = 'off';
		settingsText.autocorrect = false;
		settingsText.autocapitalize = 'off';
		settingsText.spellcheck = false;
		settingsText.placeholder = 'Settings';
		settingsText.className = 'textbox';
		settingsText.onkeydown = function(e) {
			//console.log('KeyCode=' + e.keyCode);
			if (e.keyCode == 9) {
				// This is the TAB key
				tabInsert(this, !e.shiftKey);
				return false;  //stop further handling
			} else if (e.keyCode == 13) {
				// This is the Enter key -> Copy indentation from current line
				textInsert(this, (before, mid, after) => {
					let m = before.match(/(?:^|\r|\n)([ \t]*)[^\r\n]*$/);  //match: 'linebreak whitespace line end'
					return '\n' + m[1];  //insert linebreak plus matched whitespace
				});
				return false;  //stop further handling
			}
			return true;
		};
		settingsArea.appendChild(settingsText);

		// Create optionsPanel
		let optionsPanel = document.createElement('div');
		optionsPanel.className = 'options';
		settingsArea.appendChild(optionsPanel);

		// Create optionEntries
		function createOption(labelText, getData, saveData) {
			let label = document.createElement('div');
			label.className = 'label';
			label.appendChild(document.createTextNode(labelText));
			optionsPanel.appendChild(label);
			let container = document.createElement('div');
			container.className = 'input';
			let entry = document.createElement('input');
			entry.type = 'text';
			container.appendChild(entry);
			optionsPanel.appendChild(container);
			let option = {
				showData : () => entry.value = getData(),
				saveData : () => saveData(entry.value),
				entry    : entry,
			};
			optionEntries.push(option);
			return option;
		}
		let loadConfigName = UrlResolver.getLoadConfigName();
		let loadOverrideConfigName = UrlResolver.getLoadOverrideConfigName();
		if (loadOverrideConfigName && loadConfigName == loadOverrideConfigName) {
			// One entry for both LoadOverrideOptions and LoadOptions
			createOption('Config \'' + loadOverrideConfigName + '\'',
				() => UrlResolver.getLoadOverrideOptions(),
				(value) => {
					UrlResolver.setLoadOptions(value);
					UrlResolver.setLoadOverrideOptions(value);
					Data.writeLoadOverrideOptions(value);
				});
		} else {
			if (loadOverrideConfigName) {
				// Entry for LoadOverrideOptions
				createOption('Config \'' + loadOverrideConfigName + '\'',
					() => UrlResolver.getLoadOverrideOptions(),
					(value) => {
						UrlResolver.setLoadOverrideOptions(value);
						Data.writeLoadOverrideOptions(value);
					});
			}
			if (loadConfigName) {
				// Entry for LoadOptions
				createOption('Config \'' + loadConfigName + '\'',
					() => UrlResolver.getLoadOptions(),
					(value) => {
						UrlResolver.setLoadOptions(value);
						Data.writeLoadOptions(value);
					});
			}
		}
		let saveConfigName = UrlResolver.getSaveConfigName();
		if (saveConfigName) {
			// Entry for SaveOptions
			let saveOptionsDisabled = UrlResolver.getUploadDisabled();
			let option = createOption('Online Save \'' + saveConfigName + '\'',
				() => UrlResolver.getSaveOptions(),
				(value) => {
					if (!saveOptionsDisabled) {
						UrlResolver.setSaveOptions(value);
						Data.writeSaveOptions(value);
					}
				});
			if (saveOptionsDisabled) {
				option.entry.disabled = true;
				option.entry.title = saveOptionsDisabled;  //the text with reason
			} else {
				option.entry.disabled = false;
				option.entry.title = '';
			}
		}
		return true;
	}

	function updateDirty(dirty) {
		if (dirty == null) dirty = UrlResolver.getSaveOptions() && Data.linksDirty();
		// Change visibility
		console.important('Set Links Dirty=' + dirty);
		addClass(iconOpen, 'alert', dirty);
		addClass(iconSave, 'alert', dirty);
		addClass(iconClear, 'alert', dirty);
		addClass(warningDirty, 'hidden', !dirty);
	}

	// Show the Settings panel.
	function showSettings() {
		if (visible) return;  //do nothing if already visible
		// Create panel at first showing
		if (settingsPanel == null) {
			// Panel not yet initialized, create it
			if (!createSettings()) {
				// Creating panel failed, disable button and return
				iconBarClosed.classList.add('hidden');
				return;
			}
		}
		// Display items for dirty Settings
		updateDirty();
		// Update the contents
		settingsText.value = Data.readLocalLinks();
		for (let i = 0; i < optionEntries.length; ++i) {
			optionEntries[i].showData();
		}
		// Slide panel to visible
		settingsPanel.classList.add('expanding');
		settingsPanel.classList.add('show');
		settingsPanel.onanimationend = function() {
			settingsPanel.classList.remove('expanding');
		};
		// Slide iconBarClosed out and iconBarOpen in
		let going = iconBarClosed, coming = iconBarOpen;
		going.classList.add('slide-out');
		going.onanimationend = function() {
			going.classList.add('hidden');
			going.classList.remove('slide-out');
			coming.classList.remove('hidden');
			coming.classList.add('slide-in');
		};
		coming.onanimationend = function() {
			coming.classList.remove('slide-in');
		};
		visible = true;
	};

	// Hide (Save or Cancel) Settings panel.
	function hideSettings(save) {
		if (!visible) return;  //do nothing if already hidden
		let hide = () => {
			// slide panel to hidden
			settingsPanel.classList.add('collapsing');
			settingsPanel.onanimationend = function() {
				settingsPanel.classList.remove('show');
				settingsPanel.classList.remove('collapsing');
			};
			// Slide iconBarOpen out and iconBarClosed in
			let going = iconBarOpen, coming = iconBarClosed;
			going.classList.add('slide-out');
			going.onanimationend = function() {
				going.classList.add('hidden');
				going.classList.remove('slide-out');
				coming.classList.remove('hidden');
				coming.classList.add('slide-in');
			};
			coming.onanimationend = function() {
				coming.classList.remove('slide-in');
			};
			visible = false;
		};
		if (save) {
			// Update Options
			for (let i = 0; i < optionEntries.length; ++i) {
				optionEntries[i].saveData();
			}
			// Update Links and close panel
			let saveLinks = Data.readLocalLinks();
			if (save == 'clear' || settingsText.value == '') {
				console.log('Clear settings');
				loadLinks(true)  //re-resolve, download and render Links
				.then(() => {
					// Links are correct
					let links = Data.readLocalLinks();
					settingsText.value = links;
					Data.writeLocalLinks(links);
					Data.writeCleanLinks(links);
					updateDirty(false);
					// Just read from URL, don't call uploadLinks().
					// Close the panel
					hide();
				})
				.catch(error => {
					// There was an error
					// Always log for debugging
					console.error(error);
					// Put newly read value in settingsText to correct.
					// Restore old value in Links in case of cancel.
					settingsText.value = Data.readLocalLinks();
					Data.writeLocalLinks(saveLinks);
					if (error instanceof UserInputError) {
						// It is a UserInputError, show a dialog,
						// because the user can fix it.
						window.alert('Error when reloading settings: ' +
							error.message +
							'\n\nPlease correct or cancel.');
					} else {
						// It is another error, discard it, because
						// it has already been logged.
					}
				});
			} else {
				console.log('Save settings');
				try {
					let links = settingsText.value;
					processLinks(links);  //Render Links
					// Links are correct
					Data.writeLocalLinks(links);
					uploadLinks(links);
					// Close the panel
					hide();
				} catch (error) {
					// Always log for debugging
					console.error(error);
					if (error instanceof UserInputError) {
						// It is a UserInputError, show a dialog,
						// because the user can fix it.
						window.alert('Error when saving settings: ' +
							error.message +
							'\n\nPlease correct or cancel.');
					} else {
						// It is another error, discard it, because
						// it has already been logged.
					}
					// Leave the value in settingsText to correct.
					// Restore old value in Links in case of cancel.
					Data.writeLocalLinks(saveLinks);
				}
			}
		} else {
			// Cancel
			hide();
		}
	};
}

// Assume the ctl is an input control.
// Return the sanitized insertion point or selection range.
function getSelection(ctl) {
	// The selection position indicates the selection, but also the insertion point
	let start = ctl.selectionStart;  //char pos AT which the selection starts
	let end = ctl.selectionEnd;  //char pos AFTER the selection end
	let dir = ctl.selectionDirection;  //forward, backward or none
	// Sanitize, so it is within the string:
	// - start is in [0, len]
	// - end is in [start, len]
	let len = ctl.value.len;
	if (start == null || start < 0) start = 0;
	if (start > len) start = len;
	if (end == null || end < start) end = start;
	if (end > len) end = len;

	return [start, end, dir];
}

// Assume the ctl is an input control.
// Determine the strings before and after the insertion point.
// Then call the inserter with these values. The inserter should return the insertion string.
// Update ctl and place the new insertion point after the insertion.
function textInsert(ctl, inserter) {
	let pos = getSelection(ctl);
	let start = pos[0], end = pos[1];
	// Do the insertion, replace the selection if any
	let val = ctl.value;
	let before = val.substring(0, start), mid = val.substring(start, end), after = val.substring(end);
	let mid2 = inserter(before, mid, after);
	ctl.value = before + mid2 + after;
	// Put the insertion point after the insertion
	let newPos = start + mid2.length;
	ctl.selectionStart = ctl.selectionEnd = newPos;
}

// Assume the ctl is an input control.
// 'Insert' a TAB. This may be a few different things:
// - If there is a selection, add/remove indentation.
// - If there is no selection, add N spaces.
// Return true if handled.
function tabInsert(ctl, add) {
	const N = 4;
	const space = ' ';
	let sel = getSelection(ctl);
	let val = ctl.value;
	let start = sel[0], end = sel[1], dir = sel[2];
	let pos = (dir == 'backward') ? start : end;
	if (start != end) {
		// There is a slection -> add/remove indentation
		// Get the indexes of the starts of the lines in the selection
		let locs = [];
		let i = start;
		while (i > 0) {
			let ch = val.charAt(i-1);  //char before
			if (ch == '\r' || ch == '\n') break;
			--i;
		}
		let spaceBeforeStart = start - i;  //chars in line before selection
		locs.push(i);  //start of line at or before start
		i = start+1;
		while (i <= end) {
			let ch = val.charAt(i-1);  //char before
			if (ch == '\r' || ch == '\n') locs.push(i);
			++i;
		}
		let spaceBeforeEnd = end - locs[locs.length-1];  //chars in line after selection
		// Split the value at these indexes
		let parts = [];
		parts.push(val.substring(0, locs[0]));
		for (let i = 1; i < locs.length; ++i) {
			parts.push(val.substring(locs[i-1], locs[i]));
		}
		parts.push(val.substring(locs[locs.length-1]));
		// Change the parts
		if (add) {
			// At every location, insert indentation
			for (let i = 1; i < parts.length; ++i) {
				// Add n (max N) spaces
				let n = N;
				let ch = parts[i].charAt(0);
				if (ch == '\r' || ch == '\n' || ch == '') n = 0;
				//console.devlog('Part ' + i + ': Add ' + n + ' spaces');
				if (n > 0) {
					parts[i] = space.repeat(n) + parts[i];
					// Adjust the selection
					if (i == 1) start += n;  //the first is before start
					end += n;
				}
			}
		} else {
			// At every location, remove indentation
			for (let i = 1; i < parts.length; ++i) {
				// Find the number of spaces to remove with max N
				let n = 0;
				while (n < N) {
					let ch = parts[i].charAt(n);
					if (ch != space) break;
					++n;
				}
				// Remove n spaces
				//console.devlog('Part ' + i + ': Remove ' + n + ' spaces');
				if (n > 0) {
					parts[i] = parts[i].substring(n);
					if (i == 1) {
						start -= Math.min(n, spaceBeforeStart);
					}
					if (i == parts.length-1) {
						end -= Math.min(n, spaceBeforeEnd);
					} else {
						end -= n;
					}
				}
			}
		}
		// Put back the parts
		ctl.value = parts.join('');
		// Set the new selection
		ctl.selectionStart = start;
		ctl.selectionEnd = end;
		ctl.selectionDirection = dir;
	} else {
		// There is no selection -> add/remove N spaces at current position
		let before = val.substring(0, pos), after = val.substring(pos);
		let newBefore;
		if (add) {
			// Insert N spaces
			newBefore = before + space.repeat(N);
		} else {
			// Remove max N spaces
			let re = new RegExp(space + '{1,' + N + '}$');
			//console.devlog('Applying regex: ' + re);
			newBefore = before.replace(re, '');
		}
		ctl.value = newBefore + after;
		// Put the insertion point after the change
		ctl.selectionStart = ctl.selectionEnd = newBefore.length;
	}
	return true;
}

// }}}

// StatusLine {{{

// These variables will be set in initStatus()
// Add a SatusLine statement.
let addStatus = () => {};
// Clear current StatusLine.
let clearStatus = () => {};

// Initialize StatusLine functions
function initStatus() {
	let statusLine = document.getElementById('StatusLine');
	if (!statusLine) return;

	let currentLine = '';
	let lastStatus = null;
	let count = 0;

	function withCount() {
		return currentLine + '(' + count + 'x)';
	}

	function renderStatus() {
		if (count > 1) {
			statusLine.textContent = withCount();
		} else {
			statusLine.textContent = currentLine;
		}
	}

	addStatus = (status) => {
		if (status == lastStatus) {
			count++;
		} else {
			if (count > 1) {
				currentLine = withCount();
			}
			currentLine += ' [' + status + ']';
			lastStatus = status;
			count = 1;
		}
		renderStatus();
	};

	clearStatus = () => {
		currentLine = '';
		lastStatus = null;
		count = 0;
		renderStatus();
	};

	statusLine.onclick = () => {
		statusLine.classList.toggle('visible');
	};
}

// }}}

// Handling prefer-color-scheme and PageTheme {{{

// Global variables that are used to monitor prefers-color-scheme
var PrefersColorSchemeListener = null;

// Function to set the theme of the body to the specified string.
// NB: The string theme can contain multiple CSS-class names.
function setPageTheme(theme) {
	// Determine value or default
	if (theme == null) theme = 'dark-theme';
	// Overwrite the current values
	console.log('Set PageTheme to \'' + theme + '\'');
	document.body.className = theme;
}

// Initialize monitoring of light/dark theme and adjust PageTheme accordingly.
function initMonitorPreferColorScheme(enable) {
	// Remove existing listener
	if (PrefersColorSchemeListener) {
		console.log('call PrefersColorSchemeListener.finit()');
		PrefersColorSchemeListener.finit();
		PrefersColorSchemeListener = null;
	}

	// Enable listener
	if (enable) {
		// Create a new listener
		// Note: If the function(){} syntax is used, 'this' refers to
		// the object. If ()=>{} syntax is used, 'this' refers to the
		// global window object, which is not what we need here.
		PrefersColorSchemeListener = {
			dark : window.matchMedia('(prefers-color-scheme: dark)'),
			light : window.matchMedia('(prefers-color-scheme: light)'),
			init : function() {
				console.log('Install prefers-color-scheme listener');
				this.dark.addEventListener('change', this.handler);
				this.light.addEventListener('change', this.handler);
			},
			finit : function() {
				console.log('Remove prefers-color-scheme listener');
				this.dark.removeEventListener('change', this.handler);
				this.light.removeEventListener('change', this.handler);
			},
			handler : function() {
				// Note: This handler may be called as event of
				// a matchMedia, in which case 'this' refers
				// to *that* object.
				if (!PrefersColorSchemeListener) return;
				if (PrefersColorSchemeListener.dark.matches) {
					console.log('User prefers dark mode.');
					setPageTheme('dark-theme');
				} else if (PrefersColorSchemeListener.light.matches) {
					console.log('User prefers light mode.');
					setPageTheme('light-theme');
				} else {
					console.log('No specific preference detected, use default.');
					setPageTheme(null);
				}
			},
		};
		//console.log('call PrefersColorSchemeListener.init()');
		PrefersColorSchemeListener.init();

		// Set the current theme
		//console.log('call PrefersColorSchemeListener.handler()');
		PrefersColorSchemeListener.handler();
	}
}

// }}}

// Initialization {{{

// The input is direct content or an array with blocks that contain lines and
// a starting line number. If blocks==null, nothing is done.
// The blocks are used to create a single content string. applyFunc is caled
// with that string. This function returns whatever applyFunc() returned.
// If applyFunc() throws an error, the stacktrace is searched and if it
// contains an eval(), that line number is converted and added to the error
// string. This (optionally modified) error is re-thrown.
function applyBlocks(blocks, applyFunc) {
	if (blocks == null) return;

	let contents, lineNums;
	if ('length' in blocks) {
		// This is an array, assume of Block objects.
		// Concatenate and translate line numbers.
		if (blocks.length <= 0) return;
		contents = [];
		lineNums = [ 0 ];  //eval lineNum -> input lineNum
		let inputLineNum;
		for (let i = 0; i < blocks.length; ++i) {
			let block = blocks[i];
			inputLineNum = block.lineNum + 1;  //content starts 1 line after block
			for (let j = 0; j < block.lines.length; ++j) {
				contents.push(block.lines[j]);
				lineNums.push(inputLineNum + j);
			}
		}
		contents = contents.join('\n');
	} else {
		contents = blocks;  //single string
		lineNums = null;  // not available
	}
	try {
		// Try to apply the contents
		return applyFunc(contents);
	} catch (error) {
		if ('stack' in error && lineNums != null) {
			// There's a stack and line numbers to try to
			// report on the original input line number.
			let stack = error.stack.toString();
			let m = stack.match(/\beval:(\d+)/);  //Firefox syntax
			if (!m) m = stack.match(/<?\banonymous>?:(\d+)/);  //Edge syntax
			if (m) {
				// We got the line number inside an eval
				// translate it to the input line numbers
				let lineNum = m[1];
				if (lineNum >= 1 && lineNum < lineNums.length) {
					// It in the expected range
					lineNum = lineNums[lineNum];
					error.message += ' on line ' + lineNum;
				}
			}
		}
		throw error;  //re-throw
	}
}

// Function to set the styles defined by the configuration.
// Should not throw exception, because errors are silently ignored.
function setStyleBlocks(styles) {
	applyBlocks(styles, function(str) {
		let el = document.getElementById('dynamic-styles');
		if (!el) {
			// Does not yet exist, create it
			el = document.createElement('style');
			el.id = 'dynamic-styles';
			document.head.appendChild(el);
		}
		el.innerHTML = str;
	});
}

// Function to add the script defined by the configuration.
// Throws exception if something is wrong.
function addScriptBlocks(script) {
	applyBlocks(script, function(str) {
		// Do an indirect eval().
		// According to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval ,
		// indirect eval() is safer.
		//console.log('Eval script: ', contents, lineNums);
		eval?.(str);
	});
	// Note: Script is added and I don't know of a way to remove script
	// (especially if they are used for events). This could be remedied
	// by performing a reload (window.location = window.location or so)
	// if the supplied script is different from the previously supplied
	// script.
	// I'm not doing automatic reload, because:
	// - With many scripts, reloading is not needed.
	// - Reloading may have side-effect, especially with events handlers.
	// - It wouldn't be sufficient, because a !text block may also contain
	//   script.
	// - The work-around of a manual page reload is not a big issue.
}

// Function to set the title to the specified string.
function setPageTitle(title) {
	// Determine value or default
	if (title == null) title = 'Favorites';
	// Set the title
	console.log('Set PageTitle to \'' + title + '\'');
	document.title = title;
	let titleCtl = document.getElementById('Title');
	if (titleCtl)
		titleCtl.innerText = title;
}

// Function to set the font-size to the specified string.
function setFontSize(size) {
	// Determine value or default
	if (size == null) size = '100%';
	// Set the --font-size variable that is used in the CSS classes
	console.log('Set FontSize to \'' + size + '\'');
	document.documentElement.style.setProperty('--font-size', size);
}

// From the Links configuration, parse its content and display it.
// This function may throw a UserInputError exceptions when something is wrong
// with the contents of the Links variable.
function processLinks(links, cancel = null) {
	if (!cancel) cancel = () => false;

	// Parse Links
	let parsed = parseLinks(links);

	if (cancel()) return;

	console.important('Render styles, scripts, title, etc');

	// First handle scripts and styles (to catch errors quickly)
	try {
		setStyleBlocks(parsed.styleBlocks);
		addScriptBlocks(parsed.scriptBlocks);
	} catch (error) {
		let newError = new UserInputError(error.message);
		newError.cause = error;
		throw newError;
	}

	if (cancel()) return;

	// Set page title, theme and font size
	setPageTitle(parsed.pageTitle);
	if (parsed.pageTheme == null || parsed.pageTheme.toLowerCase() == 'auto') {
		initMonitorPreferColorScheme(true);
	} else {
		initMonitorPreferColorScheme(false);
		setPageTheme(parsed.pageTheme);
	}
	setFontSize(parsed.fontSize);

	// Set AutoUploadDelay if specified
	if (parsed.autoUploadDelay != null) {
		if (PendingUpload) {
			if (parsed.autoUploadDelay > 0) {
				console.log('Change AutoUploadDelay to ' + parsed.autoUploadDelay);
				PendingUpload.setTimeout(parsed.autoUploadDelay);
			} else {
				console.log('Disable AutoUploadDelay');
				PendingUpload.dispose();
				PendingUpload = null;
			}
		} else {
			if (parsed.autoUploadDelay > 0) {
				console.log('Set AutoUploadDelay to ' + parsed.autoUploadDelay);
				PendingUpload = CreatePending('PendingUpload', parsed.autoUploadDelay, true);
			}
		}
	}

	// Render links
	console.important('Render Links...');
	let container = document.getElementById('LinksBox');
	render(parsed, container, cancel);

	if (cancel()) return;

	// Fill SearchForm
	console.important('Render SearchButtons...');
	let searchForm = document.getElementById('SearchForm');
	// Use a static input field, so that the browser retains its contents
	// after going back to this page.
	if (parsed.searchButtonDefs != null && parsed.searchButtonDefs.length > 0) {
		// There are SearchButtens, fill SearchForm
		console.log('There are ' + parsed.searchButtonDefs.length + ' SearchButtonDefs');
		// Focus SearchBox
		let searchBox = document.getElementById('SearchBox');
		if (searchBox) {
			console.log('Hide & focus SearchForm');
			searchForm.classList.remove('hidden');
			searchBox.focus();
			searchBox.select();
		}
		// Initialize the search buttons
		let buttonBox = document.getElementById('SearchButtons');
		buttonBox.textContent = '';
		addSearchButtons(parsed, searchBox, buttonBox);
	} else {
		// No SearchButtons defined, hide SearchForm
		console.log('There are no SearchButtonDefs');
		if (searchForm) {
			console.log('Hide SearchForm');
			searchForm.classList.add('hidden');
		}
	}
}

// Create object that can be called as a function. The return value of the
// function can be set with the setReturn() method.
// This object can be used as 'cancel' argument for processLinks().
function CreateCancel() {
	let cancel = false;  //default value
	let retval = () => cancel;  //returns a function that returns cancel
	retval['setReturn'] = (value) => cancel = value;  //extra method
	return retval;
}

// Load the Links and render them.
// If forcedownload==true, the Links are downloaded without fallbackLinks.
// This function returns a Promise to communicate when it's done or if there
// are exceptions.
function loadLinks(forcedownload = false) {
	let result = new PendingPromise();

	// If forcedownload, don't do preliminary links
	let preliminaryLinks = forcedownload ? null : UrlResolver.getPreliminaryLinks();
	let preliminaryLinksCancel = CreateCancel();
	let preliminaryLinksRenderPromise = null;

	// Helper function to render fallbackLinks, logging the reason.
	function handleFallbackLinks(reason) {
		if (forcedownload) {
			// The download is forced, but we ended up in the
			// fallback. Report to the user.
			alert('Could not download, see console log for details.');
			return;
		}
		let fallbackLinks = UrlResolver.getFallbackLinks();
		if (fallbackLinks != null) {
			if (preliminaryLinks == null || fallbackLinks.trim() != preliminaryLinks.trim()) {
				console.important(reason + ', use fallback Links');
				addStatus('Render fallback');
				Data.writeLocalLinks(fallbackLinks);
				processLinks(fallbackLinks);
			} else {
				console.important(reason + ' and fallback same as preliminary, keep preliminary Links');
			}
		} else {
			console.important(reason + ', keep preliminary Links');
		}
	}

	// NOTE: The intention is to start 2 Promises, one doing the rendition
	// of the preliminaryLinks and a second doing the download. As soon as
	// the download has finished and the result is different, the
	// preliminary render is cancelled and a new rendition is started.
	//
	// Unfortunately, this is not how JavaScript Promises work. It seems
	// like Promises are like co-operative multi-tasking and each Promise
	// has to yield control in order for other Promises to progress.
	// Since the processLinks() doesn't need to wait, it does not yield by
	// itself. It could be made to in the cancel() call, but I have not
	// found a way to yield control manually.
	// Surprisingly, also the downloading does not yield control.
	// This means that the first Promise will finish before the second and
	// preliminary rendition and downloading is not done in parallel.
	// I tried the following:
	// - Use fetch() for download, but that does not yield either
	// - Place preliminary render in a setTimeout() with value 1ms to
	//   forcibly yield. This works in the sense that the download is
	//   started, but as soon as the render gets control again, it doesn't
	//   let go anymore.

	// Start rendering preliminaryLinks (if defined)
	if (preliminaryLinks != null) {
		preliminaryLinksRenderPromise = new Promise((resolveFunc, rejectFunc) => {
			// Use a short timeout to give the download a chance to start
			// so that the response will be received asap after the
			// preliminary render is done (since processLinks() does not
			// yield control).
			setTimeout(() => {
				console.important('Start processing preliminaryLinks');
				addStatus('Pre-render');
				processLinks(preliminaryLinks, preliminaryLinksCancel);
				if (preliminaryLinksCancel()) {
					console.important('preliminaryLinks have been cancelled');
				} else {
					console.important('preliminaryLinks finished successfully');
				}
				resolveFunc();
			}, 50);
		});
	}

	// Start download (if defined)
	// Depending on download and last download (CleanLinks), handle as in table below.
	//        |          |            || Update |      |   Update   |
	//  Local | Download | CleanLinks ||  Local | Save | CleanLinks | StatusLine
	// -------|----------|------------||--------|------|------------|------------
	//    -   |     A    |      A     ||   yes  |   no |      no    | [No Local]
	//    -   |     B    |      A     ||   yes  |   no |     yes    | [No Local] [Save Dirty]
	//    A   |     A    |      A     ||    no  |   no |      no    | [Same]
	//    B   |     B    |      A     ||    no  |   no |     yes    | [Same]
	//    A   |     B    |      A     ||   yes  |   no |     yes    | [Render]
	//    B   |     A    |      A     ||    no  |  yes |      no    | [Save Dirty]
	//    B   |     C    |      A     ||    no  |   no |      no    | [Conflict], do not render downloaded
	// Note the following relations between input and output columns:
	// - Local = Cache, normally that is displayed now as Preliminary Render
	// - Update Local = Also Re-Render displayed content
	// - Save = Update content that is downloaded next time
	// - CleanLinks are the last downloaded Links. This is used as the
	//   common ancestor for determining if LocalLinks or newly
	//   DownloadedLinks have changed.
	let loadPromise = downloadLinks();
	if (loadPromise != null) {
		loadPromise
		.then(download => {
			// Links have been downloaded successfully
			let localT, links;
			if (forcedownload) {
				localT = links = null;
			} else {
				links = Data.readLocalLinks();
				localT = (links != null) ? links.trim() : '';
			}
			let downloadT = download.trim();
			let cleanT = Data.readCleanLinks();
			cleanT = (cleanT != null) ? cleanT.trim() : '';

			let render = false, updateLocal = false, upload = false, updateClean = false, conflict = false;
			if (preliminaryLinks == null) {
				// Nothing yet shown
				render = true;
			}
			if (!localT) {
				// Case -AA, -BA: There are no local Links
				if (forcedownload) {
					console.important('Force downloaded links');
				} else {
					console.important('Downloaded links, no local Links');
				}
				addStatus('No Local');
				updateLocal = true;
				render = true;
				if (downloadT != cleanT) {
					// Case -BA: Update CleanLinks
					updateClean = true;
				}
			} else if (localT == downloadT) {
				// Case AAA, BBA: local Links same as download Links
				console.important('Downloaded links same as local, keep pre-rendered Links');
				addStatus('Same');
				if (downloadT != cleanT) {
					// Case BBA: Update CleanLinks
					updateClean = true;
				}
			} else {
				// Case ABA, BAA, BCA: local Links different from download Links
				if (localT == cleanT) {
					// Case ABA: download Links different from others
					console.important('Downloaded Links newer than local, use downloaded Links');
					render = true;
					updateLocal = true;
					updateClean = true;
				} else {
					// Case BAA, BCA
					if (UrlResolver.getLoadOverrideOptions()) {
						// Downloaded from links-override=
						if (downloadT == cleanT) {
							// Case BAA: local Links different from others
							console.important('Local Links newer than downloaded override Links, use override');
						} else {
							// Case BCA: All three are different
							console.important('Local Links and downloaded override Links have both changed, use override');
							updateClean = true;
						}
						addStatus('Discard Local changes');
						updateLocal = true;
						render = true;
					} else {
						// Downloaded from links=
						if (downloadT == cleanT) {
							// Case BAA: local Links different from others
							console.important('Local Links newer than downloaded, use local Links');
							upload = true;
						} else {
							// Case BCA: All three are different
							console.important('Local Links and downloaded Links have both changed, display local');
							addStatus('Conflict');
							conflict = true;
						}
					}
				}
			}

			// Stop pre-render
			if (render) {
				preliminaryLinksCancel.setReturn(true);
			}
			// Set conflict state or accept downloaded Links
			if (conflict) {
				updateSettingsDirty(true);
			}
			// Update LocalStorage
			if (updateLocal) {
				console.log('Update LocalLinks');
				Data.writeLocalLinks(download);
			}
			if (updateClean) {
				console.log('Update CleanLinks');
				Data.writeCleanLinks(download);
				updateSettingsDirty(false);
			}
			if (upload) {
				if (UrlResolver.getSaveOptions()) {
					addStatus('Save Dirty');
					uploadLinks(links);  //will set CleanLinks after successful upload
				} else {
					console.log('No SaveOptions, cannot save');
					updateSettingsDirty(false);  //no SaveOptions, no dirty
				}
			}
			// Re-render or wait for pre-render
			if (render) {
				addStatus('Render');
				processLinks(download);
				result.resolve(true);
			} else {
				preliminaryLinksRenderPromise.then(() => result.resolve(true));
			}
		})
		.catch(error => {
			if (error === false) {
				handleFallbackLinks('Download failed');
				result.resolve(true);
			} else if (error instanceof UserInputError) {
				// It is a UserInputError, trigger reject, because
				// the user can fix it.
				console.log('Download failed with UserInputError');
				result.reject(error);
			} else {
				// It is another error, log it for debugging, but
				// do a resolve, so that no dialog is triggered.
				console.error('Download failed with erro', error);
				result.resolve(false);
			}
		});
	} else {
		// No download, go straight to fallback
		addStatus('No Download');
		handleFallbackLinks('No download');
	}

	return result;
}

// Initialize the JavaScript on the page
function init() {
	initStatus();
	initSettingsPanel();
	loadLinks()
	.catch(error => {
		// There is an error, report and open Settings
		// Always log for debugging
		console.error(error);
		if (error instanceof UserInputError) {
			// It is a UserInputError, show a dialog,
			// and open Settings, because the user can fix it.
			window.alert('Error when loading settings: ' +
				error.message +
				'\n\nPlease correct or cancel.');
			showSettingsPanel();
		} else {
			// It is another error, discard it, because
			// it has already been logged.
		}
	});
}
window.onload = init;

// }}}
</script>

</head>

<body class="dark-theme">

<h1 id="Title">Favorites</h1>

<span id="SettingsIconBar" class="settings-iconbar">
<div id="SettingsIconBarClosed"></div>
<div id="SettingsIconBarOpen" class="hidden"></div>
</span>

<form id="SettingsForm" class="settings-form">
  <div class="panel">
    <div id="SettingsArea" class="client"></div>
  </div>
  <hr>
</form>

<form id="SearchForm" class="search-form hidden">
  Search:
  <input id="SearchBox" name="q" type="text" inputmode="search" autocorrect="off" autocapitalize="off" autocomplete="off" size="40" class="textbox"/>
  <span id="SearchButtons"></span>
</form>

<div id="LinksBox"></div>

<div id="StatusLine" class="status-line">STATUS</div>

</body>

</html>

<!-- vim: set fdm=marker: -->

