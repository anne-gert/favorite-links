<!DOCTYPE html>
<html>

<!--
For description of this file, see README.md
For syntax description of Links, see help.html
-->

<head>

<!-- This page may contain UTF-8 encoded text, especially in the Links definition. -->
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>Favorites</title>

<style>
/* CSS styles {{{ */

/****************************************************************************
 * Global definitions
 ****************************************************************************/

/* Color palette - dark theme */
.dark-theme {
	--foreground: #DDDDDD;
	--background: #2E323B;
	--accent-color: #50A0EE;
	--block-foreground: #000000;
	--block-background: #C9CDD0;
	--block-border: #EEEEEE;
	--selection-foreground: #000000;
	--selection-background: #DDDDFF;
	--code-foreground: var(--foreground);
	--code-background: #282828;
	--link-color: #6666FF;
	--disabled-color: #888888;
	--error-foreground: #FF6600;
	--error-background: #FFD8C0;
	--error-border: var(--error-foreground);
}

/* Color palette - light theme */
.light-theme {
	--foreground: #444444;
	--background: #E8F0F8;
	--accent-color: #4444EE;
	--block-foreground: #222222;
	--block-background: #D9DDE0;
	--block-border: #666666;
	--selection-foreground: #FFFFFF;
	--selection-background: #000099;
	--code-foreground: var(--foreground);
	--code-background: #C0C0C0;
	--link-color: #2222AA;
	--disabled-color: #888888;
	--error-foreground: #FFBB88;
	--error-background: #FFEEDD;
	--error-border: var(--error-foreground);
}

:root {
	/* Define variables that will be used on visible elements */
	--font-family: 'Segoe UI', 'Lucida Grande', Helvetica, sans-serif;
	--font-size: 100%
	/* Set default font and size */
	font-family: var(--font-family);
	font-size: 12pt;  /* absolute, so --font-size can be relative too */
	scrollbar-width: thin;
}


/****************************************************************************
 * Resizing for mobile devices
 ****************************************************************************/

/*
https://www.w3schools.com/css/css_rwd_mediaqueries.asp advices the following sizes:
- max-width=600px: Extra small devices (phones)
- min-width=600px: Small devices (portrait tablets and large phones)
- min-width=768px: Medium devices (landscape tablets)
- min-width=992px: Large devices (laptops/desktops)
- min-width=1200px: Extra large devices (large laptops and desktops)

https://www.w3schools.com/cssref/css_units.php makes the following recommendations:
- Use relative lengths (em, %, rem, vw, vh) for screen display.
- Use absolute lengths (cm, px, pt) for print display.
- Pixels (px) are only literal pixels for low-dpi devices. For high-dpi
  devices, 1px is multiple physical pixels.
  The ratio of physical to logical pixels can be retrieved in JavaScript with
  window.devicePixelRatio;
- Here it defines: 1in = 2.54cm = 25.4mm = 72pt = 6pc = 96px

https://stackoverflow.com/questions/8785643/what-exactly-is-device-pixel-ratio describes the direct use of device-pixel-ratio in CSS:
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	only screen and (min--moz-device-pixel-ratio: 1.5),
	only screen and (-o-device-pixel-ratio: 3/2),
	only screen and (min-device-pixel-ratio: 1.5) {
	... high-resolution screens ...
}

Also, disable automatic text-sizing, because that determines the font-size
for each block independently.
*/
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	only screen and (min--moz-device-pixel-ratio: 1.5),
	only screen and (-o-device-pixel-ratio: 3/2),
	only screen and (min-device-pixel-ratio: 1.5) {
	/* high-resolution screens */
	:root {
		/* Make text bigger, because otherwise it gets too small on
		   phones. (I'm not sure why, because 12pt should be the same
		   absolute size on every screen. */
		font-size: 18pt;
	}
	html {
		text-size-adjust: none;
		-moz-text-size-adjust: none;
		-webkit-text-size-adjust: none;
	}
	input[type=checkbox] {
		/* For mobile, make checkboxes bigger with more padding for fat fingers. */
		transform: scale(2);
		margin: 0.7em;
		position: relative; left: -0.5em;
	}
	/* For some reason, the right-hand side of the items is hidden (if overflow=clip it
	   *is* shown, but then the animation does not work correctly. Also using another
	   unit besides fr makes the animation not work correctly.
	   Since this only happens on mobile (I tested Firefox as well as Chrome on Android),
	   I can force a bit of extra padding on the block-items level.
	   I also tested if the font-adjustment had any influence. It didn't. */
	.block-items {
		padding-right: 1em;
	}
}

body, input, textarea, button {
	font-family: var(--font-family);
	font-size: var(--font-size);
}

body {
	color: var(--accent-color); background: var(--background);
}
::selection {
	color: var(--selection-foreground); background: var(--selection-background);
}


/****************************************************************************
 * Shared styles for displaying text-blocks
 * These syles are shared between all pages
 ****************************************************************************/

.text-block {
	color: var(--foreground); background: var(--background);
}
.text-block h1, .text-block h2, .text-block h3, .text-block dt {
	color: var(--accent-color);
}
.text-block code, .text-block pre {
	color: var(--code-foreground); background: var(--code-background);
	padding: 0.1em 0.4em;
}
.text-block dt {
	display: inline;
}
.text-block a {
	color: var(--link-color);
	text-decoration: none;
}
.text-block a:hover {
	text-decoration: underline;
}
.text-block .important {
	color: var(--error-foreground);
}


/****************************************************************************
 * Section styles
 ****************************************************************************/

.section {
	display: block;
}


/****************************************************************************
 * Block styles
 ****************************************************************************/

.block {
	display: inline-block;
	vertical-align: top;
	border: .15em solid var(--block-border);
	border-radius: .5em;
	padding: 1em;
	margin: .5em;
	color: var(--block-foreground); background: var(--block-background);
}
.items {
	margin-left: 2em;
}
.block-items {  /* First indentatiion level in a Block (kind-of like the title of a Block) */
	margin-left: 0.5em;
}


/****************************************************************************
 * Item and SubItem styles
 ****************************************************************************/

.item {
	display: block;
	padding: 0.1em;
}

/* Item Groups for continuation */

.group .item {
	display: inline;
	margin-left: 0.4em;
}
.group .item:first-child {
	margin-left: unset;
}

/* Item Checkboxes */

.todo-checkbox {
	margin-right: 0.2em;
}
.todo-checkbox:checked {
}
.checkbox-label {
}
.checkbox-label.checked {
	color: var(--disabled-color);
	text-decoration: line-through;
}

/* Item Icons */

.item-icon {
	width: 1.0em; height: 1.0em;
	margin-right: 0.2em;
	vertical-align: -10%;
}
.link .item-icon {
	vertical-align: -15%;
}
.items > .item {  /* selects all non-grouped elements */
}
.link {  /* selects all links */
}
.items > .item .link {  /* selects all non-grouped links */
	vertical-align: 15%;
}
.items > .group > .item .link {  /* selects all grouped links */
}
.text-icon {
	display: inline-block;
	padding: 0em;
	text-decoration: none;
}
.text-icon div {
	position: absolute;
	margin: 0em; padding: 0em;
	transform-origin: 0 0;
}

/* Item Separator */

.item .separator {
	margin: 0em -1em 0em -1em;
}


/****************************************************************************
 * Search Form
 ****************************************************************************/

.search-form .textbox {
	font-size: 110%;
}
.search-form .button {
	margin: 0.3em;
}
.search-form .button .item-icon {
	width: 1.5em; height: 1.5em;
	vertical-align: -25%;
}
.search-form .button .label {
	margin: 0em 0.3em;
}


/****************************************************************************
 * Settings Form
 ****************************************************************************/

.settings-iconbar {
	position: absolute;
	top: 10px; right: 10px;
	text-align: right;
}
.settings-icon {
	font-size: 200%;
	cursor: pointer;
	padding: 0px 0.1em;
}
.settings-form .panel {
	width: 95%;
}
.settings-form .textbox {
	width: 100%;
	height: 47em;
	resize: both;
	overflow: scroll;
	color: var(--foreground); background: var(--background);
	font-family: monospace;
}
.settings-form .buttonbar {
	text-align: right;
	display: none;  /* use icons instead */
}
.settings-form .button {
}


/****************************************************************************
 * blink animation
 ****************************************************************************/

.blink {
	border: .15em solid transparent;
	animation: 500ms 4 blinker;
}
@keyframes blinker {
	30% {
		color: var(--error-foreground);
		background-color: var(--error-background);
		border-color: var(--error-border);
	}
}


/****************************************************************************
 * settings-form and settings-iconbar animation
 ****************************************************************************/

.settings-form {
	display: none;
	height: 50em;
}
.settings-form.show {
	display: block;
}
.settings-form.expanding {
	animation: 700ms ease settings-form-slider;
}
.settings-form.collapsing {
	animation: 700ms ease reverse settings-form-slider;
}
@keyframes settings-form-slider {
	0% {
		transform: scaleY(0);
		transform-origin: top;
		height: 0em;
	}
	100% {
		transform: scaleY(1);
		transform-origin: top;
		height: 50em;
	}
}

.settings-iconbar .hidden {
	display: none;
}
.settings-iconbar .slide-in {
	animation: 200ms ease-in settings-iconbar-slider;
}
.settings-iconbar .slide-out {
	animation: 200ms ease-out reverse settings-iconbar-slider;
}
@keyframes settings-iconbar-slider {
	0% {
		transform: scale(0, 0.4);
		transform-origin: right;
	}
	100% {
		transform: scale(1, 1);
		transform-origin: right;
	}
}


/****************************************************************************
 * slider-container and resize-button animation
 ****************************************************************************/

/* Note: On Firefox, if all collapsing/expanding animations do not take the
   same amount of time, it becomes jerky. Therefore, use the same amount of
   time and arrange different animation speeds with the @keyframes. */

.slider-container {
	/* As described in https://keithjgrant.com/posts/2023/04/transitioning-to-height-auto/,
	   animating height to height:auto is not always possible, e.g. on Firefox. A solution
	   is to animate grid-template-rows and add an extra intermediate <div>. */
	display: grid;
	grid-template-rows: 1fr;
	grid-template-columns: 1fr;
}
.slider-container > .items {  /* the first level of items in the container */
	overflow: hidden;
	white-space: nowrap;
}
.collapsing .slider-container {
	animation:
		400ms ease-out reverse block-expanding-x,
		400ms ease-out reverse block-expanding-y;
}
.expanding .slider-container {
	animation:
		400ms ease-out block-expanding-x,
		400ms ease-out block-expanding-y;
}
.collapsed .slider-container {
	grid-template-rows: 0fr;
	grid-template-columns: 0fr;
}
@keyframes block-expanding-x {
	0% {
		grid-template-columns: 0fr;
	}
	60%, 100% {
		grid-template-columns: 1fr;
	}
}
@keyframes block-expanding-y {
	0%, 20% {
		transform: scaleY(0);
		transform-origin: top;
		grid-template-rows: 0fr;
	}
	100% {
		transform: scaleY(1);
		transform-origin: top;
		grid-template-rows: 1fr;
	}
}

/* resize-button animation */

.resize-icon {
	float: right;
	position: relative;
	top: -0.9em; right: -0.6em;
	cursor: pointer;
	color: var(--disabled-color);
	transform: rotate(90deg);
}
.collapsing .resize-icon {
	animation: 400ms ease animate-resize-icon;
}
.expanding .resize-icon {
	animation: 400ms ease reverse animate-resize-icon;
}
.collapsed .resize-icon {
	color: var(--block-foreground);
	transform: rotate(0deg);
}
@keyframes animate-resize-icon {
	0%, 30% {
		color: var(--disabled-color);
		transform: rotate(90deg);
	}
	70%, 100% {
		color: var(--block-foreground);
		transform: rotate(0deg);
	}
}

/* }}} */
</style>

<script>
// Some constants {{{

const UNICODE_BLACK_DOWN_POINTING_TRIANGLE = '\u{25BC}';
const UNICODE_BLACK_RIGHT_POINTING_TRIANGLE = '\u{25B6}';
const UNICODE_LEFT_POINTING_MAGNIFYING_GLASS = '\u{1F50D}';
const UNICODE_RIGHT_POINTING_MAGNIFYING_GLASS = '\u{1F50E}';
const UNICODE_GEARS = '\u{2699}';  //gears wheel
const UNICODE_EMPTY_DOCUMENT = '\u{1F5CB}';
const UNICODE_CHECK_MARK = '\u{2713}';
const UNICODE_HEAVY_CHECK_MARK = '\u{2714}';
const UNICODE_LIGHT_CHECK_MARK = '\u{1F5F8}';
const UNICODE_CANCELLATION = '\u{1F5D9}';  //cross
const UNICODE_FLOPPY_DISK = '\u{1F4BE}';  //colored floppy disk
const UNICODE_BLACK_HARD_SHELL_FLOPPY_DISK = '\u{1F5AA}';  //black&white 3½" floppy disk
const UNICODE_WHITE_HARD_SHELL_FLOPPY_DISK = '\u{1F5AB}';  //black&white 3½" floppy disk
const UNICODE_SOFT_SHELL_FLOPPY_DISK = '\u{1F5AB}';  //black&white 5¼" floppy disk

// DefaultLinks is a textual part with a copy of example-links.txt at the end.
const DefaultLinks = `
// For the syntax description, see help.html.

!title Example Favorites

!text
<a name="description"></a>
<h2>Description</h2>

<p>
<a href="favorites.html">favorites.html</a> is a single page that can be
configured to show <u>links</u> and <u>todo lists</u>, organized in
<u>sections</u>, <u>blocks</u> and <u>items</u>. This configuration can be
downloaded via a URL and/or edited in the browser's LocalStorage (see below).
<br>
This page can be set as home page in the browser's settings and as the Tab
start page via an add-on like <a
href="https://addons.mozilla.org/en-US/firefox/addon/new-tab-override/">New Tab
Override</a>.
</p>
!endtext

Section

!text
<p>
The configuration consists primarily of a list of <a
href="help.html#link-syntax">Link Definitions</a>.  The Links form an
hierarchical structure, indicated by the line's indentation:
<ul>
<li><dt>Section</dt>: The first indentation level is the Section. Sections are
    separated by horizontal lines.
<li><dt>Block</dt>: The second indentation level are the blocks within a
    Section. Each Block is a visual area that can be collapsed and expanded.
<li><dt>Item</dt>: The third indentation level are the Items that populate
    the Blocks.
<li><dt>SubItem</dt>: The fourth and higher indentation levels are SubItems
    that are displayed under their respective parent Items
</ul>
</p>
!endtext

    Block
        Item
            SubItem
                SubSubItem
                SubSubItem
                    ...
            SubItem
        Item
            SubItem

!text
<p>
Each link can be a hyperlink, have an icon and/or a checkbox.
</p>
!endtext

!text
<a name="usage"></a>
<h2>Usage</h2>

<p>
The standard usage is to open the page favorites.html (or possibly set it as
your home page). Upon first opening, it shows a default example page.  This
page can be edited by going to the Settings (gears (&#x2699;) icon) and just
edit and save the textual configuration. Optionally, this configuration can be
maintained in a separate text file and copy-pasted into the Settings.
<br>
Since GitHub provides for a way to serve HTML pages directly, this can be used
to open and use favorites.html directly from <a
href="https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html">GitHub</a>.
Save the target of this link to your home page and you're set.
</p>

<p>
See <a href="help.html#usage">Help</a> for more information on how to use a
separate URL to retrieve the configuration.
</p>

<p>
In addition to Links, the configuration also supports comments, different
web-search functions and other directives, see <a
href="help.html#line-syntax">Line Syntax</a> for further details.
</p>
!endtext

Examples

!text
<p>
These are some examples of the available features.
</p>
!endtext

    Search
        DuckDuckGo https://duckduckgo.com
        Google Maps icon=alt https://maps.google.com
        Wikipedia https://www.wikipedia.org
        YouTube https://www.youtube.com
    Source
        GitHub favorite-links https://github.com/anne-gert/favorite-links
            Use favorites.html icon=github https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html
            Example Links override icon=github https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html&links-override=example-links.txt
            Help icon=github https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/help.html
        Firefox
            Home page settings icon=firefox target=manual about:preferences#home
            Plugins
                New Tab Override https://addons.mozilla.org/en-US/firefox/addon/new-tab-override/
    To Do
        Shopping
            [ ] Books
            [x] Presents
        At work
            [x] icon=firefox Install Firefox https://www.mozilla.org/firefox/download
            [ ] icon=github Start using favorite-links as todo-list
            []  icon=empty Write review
                & Goto Blog icon=none url=https://blog.example.com
    Socials
        Facebook https://www.facebook.com
            Instagram https://www.instagram.com/
            WhatsApp Web https://web.whatsapp.com/
        ---
        LinkedIn https://www.linkedin.com/

// Icon definitions
!icondef firefox    https://www.mozilla.org/media/img/favicons/firefox/browser/favicon.ico
!icondef github     https://github.com

// Search button definitions
//      Identifier   | Label  | Tooltip | Icon
!search Duck Duck Go | Search |
!search Wikipedia
!search YouTube
!search Google Maps  | Maps   |         | alt
`;

// LocalStorage keys.
const LSKey_Prefix = 'favlist_';
const LSKey_Links = LSKey_Prefix + 'links';
const LSKey_ItemExpandedPrefix = LSKey_Prefix + 'expanded_';

// }}}

// Loading Links {{{

// Global variables to hold the URL and Promise for the Links.
// Set by resolveLinks().
var LinksUrl = null;
var LinksPromise = null;

// This function tries to find the configuration for the Links.
// It sets the global LinksPromise variable with a Promise that should resolve
// to the Links contents..
// It also returns this Promise for chaining.
//
// The contents of Links can be obtained from links-override=, links=,
// LocalStorage or DefaultLinks. See the table in the function for the details.
//
// If this search results in a URL to download, it may be an absolute or
// relative URL. Download it and use its contents for the Links variable.
function resolveLinks(skipLocalStorage = false) {
	LinksUrl = null;
	LinksPromise = null;

	// The general order is:
	// 1) links-override=
	// 2) LocalStorage if skipLocalStorage==false
	// 3) links=
	//
	// If save= is set, the order of LocalStorage and links= is swapped,
	// resulting in a modified table:
	// 1) links-override=
	// 2) links=
	// 3) LocalStorage if skipLocalStorage==false
	//
	// We now need to find 2 things:
	// - Source to use for links, which can be a URL or a stored string.
	// - URL, that may not actually be used, because the string is stored
	//   in LocalStorage.
	// Below are 2 tables to derive these values.
	//
	// Derive LinksUrl:
	// - LinksUrl should always be the first of links-override= or links=
	//   or null if neither is set.
	//
	// Derive linksText:
	// - If LinksUrl is set, the contents should generally be downloaded.
	//   There is 1 exception if we're in read-only mode in which case
	//   LocalStorage is used before links=. This can be expressed as
	//   LinksUrl set AND save= not set AND LocalStorage set AND not
	//   skipped. In that case, use LocalStorage. Otherwise set to null
	//   to indicate LinksUrl should be downloaded.
	// - If LocalStorage is set and not skipped, use that.
	// - Otherwise, use DefaultLinks.
	//
	// Derive LinksPromise:
	// - If linksText is set, use that.
	// - Otherwise LinksUrl should be set, download that.

	let params = new URLSearchParams(location.search);
	let linksOverride = params.get('links-override');
	let save = params.get('save');
	let links = params.get('links');
	//console.log(params);

	// Derive LinksUrl: The first of links-override= or links=
	if (linksOverride) {
		console.log('LinksUrl: Use links-override= URL argument');
		LinksUrl = linksOverride;
	} else if (links) {
		console.log('LinksUrl: Use links= URL argument');
		LinksUrl = links;
	} else {
		console.log('LinksUrl: No URL specified');
		LinksUrl = null;
	}

	// Derive linksText
	let checkLocalStorage = () => {
		if (skipLocalStorage) return null;  //ignore LocalStorage
		let locStor = readLocalLinks();
		if (locStor === false) return null;  //nothing in LocalStorage
		// LocalStorage is available, return that
		console.log('LinksPromise: Use links from the LocalStorage');
		return locStor;
	}
	let linksText = null;  //defaults to download LinksUrl
	if (LinksUrl) {
		// LinksUrl is set. Generally download it, except in 1 exception
		if (!linksOverride && !save) linksText = checkLocalStorage();  //the exception
	} else {
		// LinksUrl not set, linksText must be set here to display anything.
		linksText = checkLocalStorage();
		if (linksText == null) {
			// Nothing in LocalStorage, use DefaultLinks
			console.log('LinksPromise: Use standard example links');
			linksText = DefaultLinks;
		}
	}

	// Here, either or both of LinksUrl or linksText must be set.

	// If no text found yet, there must be a URL, resolve it
	if (linksText == null) {
		// links is a URL
		let matchTargetUrl = LinksUrl.match(/^\s*((https?:\/\/)?(.*?))\s*$/i);  //always matches
		//console.log(matchTargetUrl);
		// Captured:
		// 1: url
		// 2: protocol
		// 3: domain + path + rest
		let url = matchTargetUrl[1];
		if (!matchTargetUrl[2]) {
			// URL is relative, check if we need to adjust it
			let matchBaseUrl = window.location.href.match(/^([^\/]*?:\/\/)([^\/]*\bhtml-?preview\.github\.[^\/]*)([^?#]*)/i);
			//console.log(matchBaseUrl);
			// Captured:
			// 1: protocol
			// 2: host ('html-preview.github.io')
			// 3: path without query string or fragment
			if (matchBaseUrl) {
				// The current URL is html-preview.github.io (or similar)
				// This should have a url= parameter that contains the real location
				let referredUrl = params.get('url');
				//console.log(referredUrl);
				let matchReferredUrl = referredUrl.match(/^([^\/]*:\/\/)([^\/]*\bgithub\.[^\/]*)([^?#]*)/i);
				//console.log(matchReferredUrl);
				// Captured:
				// 1: protocol
				// 2: host ('github.com')
				// 3: path without query string or fragment
				if (matchReferredUrl) {
					// The referred URL is on github.com

					// We are now in a situation where this page is hosted
					// on GitHub and links tries to point to a file on
					// there as well.
					// If you have a normal link to github.com, you get the
					// file inside the environment. If you use
					// raw.githubusercontent.com, you get the content of the
					// file, but with Content-Type=text/plain. When
					// html-preview.github.io is used, it uses
					// raw-githubcontent.com and serves it with
					// Content-Type=text/html.
					console.log('Fix links= relative URL for GitHub');
					// To make this relative link work, it should be grafted
					// onto githubusercontent.
					let matchReferredPath = matchReferredUrl[3].match(/(.*?)([^\/]*)$/);
					//console.log(matchReferredPath);
					// Captured:
					// 1: directory
					// 2: filename (everything after last '/')
					url = matchReferredUrl[1] + 'raw.githubusercontent.com' + matchReferredPath[1] + matchTargetUrl[3];
				}
			}
		}

		// Derive LinksPromise: Download the URL
		console.log('LinksPromise: Download URL \'' + url + '\'');
		LinksPromise = new Promise((resolveFunc, rejectFunc) => {
			let xhr = new XMLHttpRequest();
			xhr.open('GET', url);
			xhr.onreadystatechange = function() {
				if (this.readyState == 4) {
					// Request has been handled
					if (this.status == 200) {
						// Success
						console.log('LinksPromise: Download successful');
						resolveFunc(xhr.responseText);
					} else {
						// Failed
						console.log('LinksPromise: Download failed, use standard example links');
						resolveFunc(DefaultLinks);
					}
				}
			};
			xhr.send();  //send the request
		});
	} else {
		// Derive LinksPromise: Return linksText
		LinksPromise = Promise.resolve(linksText);
	}

	// Here LinkPromise has been set to the links contents.
	// Also LinksUrl has been set to the URL used or that would have been used.

	// Return the Promise too (for chaining)
	return LinksPromise;
}

// The resolveLinks() should be called as soon as possible to start the
// downloading already.
resolveLinks();

// Read links settings from LocalStorage.
// Return links or false in case of error or if it does not exist.
function readLocalLinks() {
	if (localStorage) {
		let v = localStorage.getItem(LSKey_Links);
		if (v) return v;
	}
	return false;
}

// Store links in LocalStorage.
// If value is null, empty or whitespace, delete value from LocalStorage.
// Return true if success, false if not saved.
function _writeLocalLinks(value) {
	if (localStorage) {
		if (value == null || value.match(/^\s*$/))
			localStorage.removeItem(LSKey_Links);
		else
			localStorage.setItem(LSKey_Links, value);
		return true;
	}
	return false;
}

// Save links online by the method specified.
// If the value is null, empty or whitespace, save an empty string.
// Returns Promise of the upload or false if not saving.
function _writeOnlineLinks(value) {
	let params = new URLSearchParams(location.search);
	let save = params.get('save');
	if (!save) {
		console.log('No save=, skip saving');
		return false;
	}

	// If value is null or whitespace, send an empty string
	if (value == null || value.match(/^\s*$/)) {
		value = '';
	}

	// Split into parts
	let parts = save.split('\\');

	// The first part should specify the method and the URL
	let method, saveUrl, special = false;
	let method_url = parts.shift().match(/^(?:(put|post):)?(.*)$/i);
	if (method_url) {
		if (method_url[1]) {
			// This is the standard syntax method:url
			method = method_url[1].toUpperCase();
		} else {
			// This is the special save syntax
			method = 'POST';
			special = true;
		}
		if (method_url[2]) {
			// A URL has been specified
			saveUrl = method_url[2];
		} else if (LinksUrl) {
			// No URL has been specified, use the URL for reading
			saveUrl = LinksUrl;
		} else {
			// No URL to use
			console.error('Cannot find read nor write url');
			return false;
		}
	} else {
		console.error('Incorrect method/url in \'' + save + '\'');
		return false;
	}

	// Derive absolute URL to save
	let saveUrlAbs;
	if (LinksUrl) {
		// LinksUrl may be relative to this script and saveUrl may be relative to LinksUrl
		let linksUrlAbs = new URL(LinksUrl, window.location).href;
		saveUrlAbs = new URL(saveUrl, linksUrlAbs).href;
	} else {
		// No LinksUrl known, assume base of saveUrl is this script
		saveUrlAbs = new URL(saveUrl, window.location).href;
	}

	console.log((special ? 'Special ' : '') + method + ' ' + value.length + ' characters to ' + saveUrlAbs);

	// The other parts are additional headers
	let headers = [];
	if (special) {
		// For the special syntax, the next part is the token
		if (parts.length > 0) {
			headers.push([ 'x-token', parts.shift() ]);
		}
		// Create the x-name header
		if (LinksUrl) {
			let name = LinksUrl.replace(/\?.*/, '').replace(/.*\//, '');
			headers.push([ 'x-name', name ]);
		} else {
			console.error('Special save cannot find LinksUrl for x-name');
			return false;
		}
	}
	// The other parts are additional headers in name:value format
	for (let i = 0; i < parts.length; ++i) {
		let name_value = parts[i].match(/([^:]+):(.+)/);
		if (name_value) {
			headers.push(name_value.slice(1,3));
		} else {
			console.warning('Expected header: ' + parts[i]);
		}
	}

	console.log('Request headers: ', headers);

	// Create the Promise for uploading
	let uploadPromise = new Promise((resolveFunc, rejectFunc) => {
		let xhr = new XMLHttpRequest();
		xhr.open(method, saveUrlAbs);
		for (let i = 0; i < headers.length; ++i) {
			xhr.setRequestHeader(headers[i][0], headers[i][1]);
		}
		xhr.onreadystatechange = function() {
			if (this.readyState == 4) {
				// Request has been handled
				if (this.status == 200) {
					// Success
					console.log('Uploaded links successfully');
					resolveFunc(this.status);
				} else {
					// Failed
					console.log('Failed to upload links, good luck next time (' + this.status + ')');
					resolveFunc(this.status);  //do not see this as a fail
				}
			}
		};
		xhr.send(value);  //send the request
	});

	return uploadPromise;
}

// Save links by calling _writeLocalLinks() and _saveOnlineLinks().
function writeLinks(value) {
	_writeLocalLinks(value);
	_writeOnlineLinks(value);
}

// }}}

// Parsing Links {{{

// Global variables in which parseLinks() puts its output.
var Links = null;  //links text, input for parseLinks()
var PageTitle = null;  //specified title
var PageTheme = null;  //specified color theme
var FontSize = null;  //specified font-size (may be relative, but that doesn't work very well)
var SearchButtonDefs = null;  //specified search button declarations
var RootLinks = null;  //array of Link objects that have no parents (i.e. are roots)
var IconDefs = null;  //specified icondef declarations
var StyleBlocks = null;  //array of !style...!endstyle blocks
var ScriptBlocks = null;  //array of !script...!endscript blocks


// Parse the string in Links and fills the global variables above.
function parseLinks() {
	// Parse the input lines and construct a list of objects
	let allLinks = [];  //specified Link objects
	PageTitle = null;
	PageTheme = null;
	FontSize = null;
	SearchButtonDefs = [];
	RootLinks = [];
	IconDefs = {};
	StyleBlocks = null;
	ScriptBlocks = null;
	let textBlock = null;  //used for literal !text ... !endtext blocks
	let styleBlock = null;  //used for literal !style ... !endstyle blocks
	let scriptBlock = null;  //used for literal !script ... !endscript blocks
	let openIndentLevels = [];  //indentation level (number of spaces) for each open level
	let maxLevel = null;  //keep track of the maximum level
	let lines = Links.split(/\r?\n\r?/);  //lines with Link specifications
	for (let i = 0; i < lines.length; ++i) {
		let line = lines[i];
		//console.log('Line=\'' + line + '\'');
		let m;  //for regex matches

		// If we're in a !text block, add this line to the block
		if (textBlock != null) {
			// Check if it is the end of a literal block
			m = line.match(/^\s*!endtext\s*$/i);
			if (m) {
				// It is the end, save the object and reset textBlock.
				allLinks.push(textBlock);  //all items go here
				textBlock = null;  //reset
				continue;
			}
			// Otherwise add this line too
			textBlock.lines.push(line);
			continue;
		}

		// If we're in a !style block, add this line to the block
		if (styleBlock != null) {
			// Check if it is the end of a literal block
			m = line.match(/^\s*!endstyle\s*$/i);
			if (m) {
				// It is the end, save the object and reset styleBlock.
				if (StyleBlocks == null) StyleBlocks = [];
				console.log('Add !style block (' + styleBlock.lines.length + ' lines)');
				StyleBlocks.push(styleBlock);
				styleBlock = null;  //reset
				continue;
			}
			// Otherwise add this line too
			styleBlock.lines.push(line);
			continue;
		}

		// If we're in a !script block, add this line to the block
		if (scriptBlock != null) {
			// Check if it is the end of a literal block
			m = line.match(/^\s*!endscript\s*$/i);
			if (m) {
				// It is the end, save the object and reset scriptBlock.
				if (ScriptBlocks == null) ScriptBlocks = [];
				console.log('Add !script block (' + scriptBlock.lines.length + ' lines)');
				ScriptBlocks.push(scriptBlock);
				scriptBlock = null;  //reset
				continue;
			}
			// Otherwise add this line too
			scriptBlock.lines.push(line);
			continue;
		}

		// Remove vim folding markers at the end of lines
		line = line.replace(/\s*(?:{{{|}}})\s*$/, '');

		// Skip empty lines
		if (line.match(/^\s*(?:\/\/|#|;|$)/))
			continue;

		// Check if it is a title definition
		m = line.match(/^\s*!title\s+(.+?)\s*$/i);
		if (m) {
			// This is an title
			PageTitle = m[1];  //save string
			continue;
		}

		// Check if it is a theme definition
		m = line.match(/^\s*!theme\s+(.+?)\s*$/i);
		if (m) {
			// This is a theme
			PageTheme = m[1];  //save string
			continue;
		}

		// Check if it is a font-size definition
		m = line.match(/^\s*!size\s+(.+?)\s*$/i);
		if (m) {
			// This is a size
			FontSize = m[1];  //save string
			continue;
		}

		// Check if it is an icon definition
		m = line.match(/^\s*!icondef\s+(\S+)(?:\s+|\s*=\s*)(\S+)\s*$/i);
		if (m) {
			// This is an icondef
			IconDefs[m[1]] = m[2];  //save mapping
			continue;
		}

		// Check if it is a search button definition
		m = line.match(/^\s*!search\s+(.+?)\s*$/i);
		if (m) {
			// This is a search button definition
			let def = m[1].split(/\s*\|\s*/);  //split fields on '|', allowing whitespace
			SearchButtonDefs.push(def);  //save button def
			continue;
		}

		// Check if it is the start of a literal !text block
		m = line.match(/^\s*!text\s*$/i);
		if (m) {
			// Mark the start of the block
			textBlock = {  //special type of Link object
				'lineNum'  : i+1,  //start of this block
				'type'     : 'text',
				'level'    : null,  //adjusted later
				'lines'    : [],
				'toString' : function() { return '{ !text, #Lines=' + this.lines.length + ' }' },
			};
			continue;
		}

		// Check if it is the start of a literal !style block
		m = line.match(/^\s*!style\s*$/i);
		if (m) {
			// Mark the start of the block
			styleBlock = {
				'lineNum'  : i+1,  //start of this block
				'lines'    : [],
				'toString' : function() { return '{ !style, #Lines=' + this.lines.length + ' }' },
			};
			continue;
		}

		// Check if it is the start of a literal !script block
		m = line.match(/^\s*!script\s*$/i);
		if (m) {
			// Mark the start of the block
			scriptBlock = {
				'lineNum'  : i+1,  //start of this block
				'lines'    : [],
				'toString' : function() { return '{ !script, #Lines=' + this.lines.length + ' }' },
			};
			continue;
		}

		// Take out indentation
		let indent = 0;
		m = line.match(/^(\s+)(.*)$/);
		if (m) {
			indent = m[1].replaceAll('\t', '        ').length;
			line = m[2];  //the rest
		}
		// Take out continucation: & ...
		let cont = false;
		m = line.match(/^&\s*(.*)$/);
		if (m) {
			cont = true;
			line = m[1];  //the rest
		}
		// Take out Icon: /icon=non-whitespace/
		let icon = null;
		m = line.match(/^(.*)(?:\s|^)icon=(\S*)(.*)$/i);
		if (m) {
			icon = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out Check: start with '[ ]' '[]' or '[x]'
		let check = null;
		m = line.match(/^(\s*)(?:(\[ ?\])|(\[x\]))(.*)$/i);
		if (m) {
			if (m[2]) check = false;
			if (m[3]) check = true;
			line = m[1] + m[4];  //the rest
		}
		// Take out Target: /target=non-whitespace/
		let target = null;
		m = line.match(/^(.*)(?:\s|^)target=(\S*)(.*)$/i);
		if (m) {
			target = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out URL: /url=non-whitespace/ or last /schema:non-whitespace/
		let url = null;
		m = line.match(/^(.*)(?:\s|^)url=(\S*)(.*)$/i);
		if (!m)
			m = line.match(/^(.*)(?:\s|^)([-+a-zA-Z]{2,}:\S+)(.*)$/);
		if (m) {
			url = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out Name: what remains without leading&trailing whitespae
		let name = line.trim();

		// Handle special items
		if (name.match(/^---+$/)) {  //name with 3 or more '-'
			// This is a separator
			name = '---';  //standardize to 3 '-'
		}

		// Determine level of this object
		let level;
		if (cont) {
			// This link is a continuation, ignore the indentation
			level = null;
		} else {
			// Find level with indentation strictly less
			for (level = openIndentLevels.length - 1; level >= 0 && openIndentLevels[level] >= indent; --level) {}
			// We found the parent's level (-1 if no parent), add 1 for this level
			++level;
			if (maxLevel == null || level > maxLevel) maxLevel = level;
			// Remove all open levels after that
			openIndentLevels.length = level;
			// Add this link as open parent
			openIndentLevels.push(indent);
		}

		// Create the Link object
		let link = {
			'lineNum'  : i+1,
			'type'     : 'link',
			'level'    : level,
			'name'     : name,
			'url'      : url,
			'icon'     : icon,
			'check'    : check,
			'target'   : target,
			'cont'     : [],
			'subs'     : [],
			'toString' : function() { return '{ Name=\'' + this.name + '\', URL=' + this.url + ', Icon=' + this.icon + ', check=' + check + ', #SubItems=' + this.subs.length + ' }' },
		};
		//console.log('Indentation=' + indent + ', Link=' + link);

		// Add this Link
		if (cont) {
			// This link is a continuation, add it to the previous link
			var previous = allLinks[allLinks.length - 1];
			previous.cont.push(link);
		} else {
			allLinks.push(link);
		}
	}

	// Search from position to the front in allLinks and find the first
	// link item that has a level set.
	// Returns item or null if not found.
	let findLinkBefore = function(position) {
		for (let i = position - 1; i >= 0; --i) {
			let item = allLinks[i];
			if (item.level != null) return item;
		}
		return null;
	}

	// Search from position to the end in allLinks and find the first
	// link item that has a level set.
	// Returns item or null if not found.
	let findLinkAfter = function(position) {
		for (let i = position + 1; i < allLinks.length; ++i) {
			let item = allLinks[i];
			if (item.level != null) return item;
		}
		return null;
	}

	// If maxLevel==0, all items are at root level. It was probably
	// intended to have all items in a block. To fix this, add a
	// dummy Section (level 0) and Block (level 1).
	// Similarly with maxLevel==0. Now all items are separate blocks.
	// Fix this by adding a dummy Section (level 0).
	if (maxLevel < 2) {
		// These are the special cases
		let firstLink = findLinkAfter(-1);
		if (firstLink == null) {
			// There are no links at all.
			// In this case, there is nothing to adjust
		} else {
			// Add 1 or 2 levels in the front of allLinks
			// In either case, we need to add a Section
			let section = {
				'lineNum'  : 0,
				'type'     : 'link',
				'level'    : 0,
				'name'     : '_',  //this makes this section not render
				'url'      : null,
				'icon'     : null,
				'check'    : null,
				'target'   : null,
				'cont'     : [],
				'subs'     : [],
				'toString' : function() { return '{ Dummy Section }' },
			};
			if (maxLevel == 0) {
				// Only in this case, we need to add a Block level too
				let block = {
					'lineNum'  : 0,
					'type'     : 'link',
					'level'    : 1,
					'name'     : firstLink.name,  //give it the same name as the first link
					'url'      : null,
					'icon'     : null,
					'check'    : null,
					'target'   : null,
					'cont'     : [],
					'subs'     : [],
					'toString' : function() { return '{ Dummy Block }' },
				};
				console.log('Add dummy Block');
				allLinks.unshift(block);
			}
			console.log('Add dummy Section');
			allLinks.unshift(section);
			// Increase level of all existing items
			//  maxLevel | num items added | start original items | increase
			// ----------|-----------------|----------------------|----------
			//         0 |               2 |                    2 |        2
			//         1 |               1 |                    1 |        1
			//        >2 |               0 |                  n/a |      n/a
			let x = 2 - maxLevel;
			for (let i = x; i < allLinks.length; ++i) {
				let level = allLinks[i].level;
				if (level != null) {
					allLinks[i].level = level + x;
				}
			}
		}
	}
	//console.log(allLinks);

	// Go through allLinks and adjust the level if needed
	for (let i = 0; i < allLinks.length; ++i) {
		let item = allLinks[i];
		if (item.type == 'text') {
			// This is a text block
			// Make its level the lowest of the item before and the item after
			let before = findLinkBefore(i);
			let after = findLinkAfter(i);
			if (before != null) {
				if (after != null) {
					// There is a line before and a line after
					if (before.level < after.level) {
						// Indent in -> regard this item as 1 below before
						item.level = before.level + 1;
					} else if (before.level == after.level) {
						// Same indent -> regard this item as that level too
						item.level = before.level;
					} else {
						// Indent out -> regard this item as 1 deeper than after
						item.level = after.level + 1;
					}
				} else {
					// There is a line before, but no line after
					// This is at the end of the page -> root level
					item.level = 0;
				}
			} else {
				// There is a line after, but no line before
				// This is at the start of the page -> root level
				item.level = 0;
			}
		} else if (item.type == 'link' && item.name == '---') {
			// This is a separator.
			// A separator is only useful at block level or lower
			if (item.level <= 1) {
				item.level = null;
			}
		}
	}

	// Go through allLinks and create a parent-child structure
	let openParents = [];  //currently open parents: 0 is root, 1 its child, etc
	for (let i = 0; i < allLinks.length; ++i) {
		let item = allLinks[i];
		if (item.level == null) {
			// This has no level and should not be put in the parent-child structure
		} else {
			if (item.level > 0) {
				// This is a regular item, find a parent
				let parent = openParents[item.level - 1];
				parent.subs.push(item);
			} else {
				// This item does not have a parent, it's a root
				RootLinks.push(item);
			}

			// If this item can be a parent too, replace from this level and below
			if ('subs' in item) {
				openParents.length = item.level;
				openParents.push(item);
			}
		}
	}

	// Check if all blocks have been closed
	if (textBlock) {
		throw new UserInputError('Missing !endtext for !text', textBlock.lineNum);
	}
	if (styleBlock) {
		throw new UserInputError('Missing !endstyle for !style', styleBlock.lineNum);
	}
	if (scriptBlock) {
		throw new UserInputError('Missing !endscript for !script', scriptBlock.lineNum);
	}

	// Log all links
	//for (let i = 0; i < allLinks.length; ++i) console.log('Link=' + allLinks[i]);
	// Log all roots
	//for (let i = 0; i < RootLinks.length; ++i) console.log('RootLink=' + RootLinks[i]);
}

class UserInputError extends Error {
	constructor(message, lineNumber) {
		// Update message
		let fileName = 'configuration';
		if (lineNumber != null) {
			message += ' on line ' + lineNumber;
		}

		// Construct object
		super(message, fileName, lineNumber);
		this.name = 'UserInputError';
	}
}

// }}}

// Rendering Links {{{

// Output Link {{{

// Render Link object, including its children to the container at specified level.
// Level 1 is called Section and is rendered with a heading.
// Level 2 is called Block and is rendered as a rectangular block.
// Level 3 is called Item and is rendered as a line in a Block.
// Level 4 and higher are called sub-Items and are rendered as indented Items.
function outputItem(link, level, container, parentPath) {
	//console.log('outputItem ' + link.toString());
	// Copy input data
	let name = link.name;
	let url = link.url;
	let icon = link.icon;
	let check = link.check;
	let target = link.target;
	let tooltip = null;
	let contItems = link.cont;
	if (contItems != null && contItems.length == 0) contItems = null;
	let subItems = link.subs;
	if (subItems != null && subItems.length == 0) subItems = null;
	if (name == '') name = null;
	if (url == '') url = null;
	if (icon == '') icon = null;
	if (target == '') target = null;
	let myPath = parentPath + '->' + name;
	// Fill in defaults for missing elements
	if (name == null) {
		if (url != null) {
			name = url;  //name defaults to url
		} else {
			name = '_';  //indicates the name may be hidden
		}
	}
	// Change URL if target=manual
	if (target == 'manual') {
		let msg = 'Due to security reasons, this URL cannot be opened automatically.\nCopied URL \'' + url + '\' to clipboard.\n\nManually paste this to the address bar.';
		msg = msg.replaceAll('\'', '\\\'').replaceAll('\n', '\\n');
		tooltip = url;  //preserve original URL
		url = 'javascript:navigator.clipboard.writeText(\'' + url + '\');alert(\'' + encodeURI(msg) + '\');void(0)';
		target = null;
	}
	// Render the item
	// State variables for this item; will be used in closures
	let addItemContainer;  //function to add a container to put the Item into
	let addSubContainer;  //function to add a container to put the subItems into
	let addClosingElements = null;  //function to add closing elements to the container
	// Create element container
	if (level == 1) {
		// Render Item as Section
		//console.log('Render Section ' + name);
		let _itemContainer;
		let _subContainer;
		addItemContainer = function() {
			_itemContainer = document.createElement('h2');
			container.appendChild(_itemContainer);
			return _itemContainer;
		}
		addSubContainer = function() {
			_subContainer = document.createElement('div');
			_subContainer.className = 'section';
			container.appendChild(_subContainer);
			return _subContainer;
		};
		addClosingElements = function() {
			let closingElements = document.createElement('hr');
			container.appendChild(closingElements);
		}
	} else if (level == 2) {
		// Render Item as Block
		//console.log('Render Block ' + name);
		let _itemContainer;
		let _subContainer;
		addItemContainer = function() {
			_itemContainer = document.createElement('div');
			_itemContainer.className = 'block';
			container.appendChild(_itemContainer);
			if (subItems != null) {
				let expandIcon = document.createElement('span');  //container to display '-' or '+'
				expandIcon.className = 'resize-icon';
				expandIcon.textContent = UNICODE_BLACK_RIGHT_POINTING_TRIANGLE;
				_itemContainer.appendChild(expandIcon);
				let isExpanded = true;  //true if block is expanded
				let storageKey = LSKey_ItemExpandedPrefix + myPath;
				if (localStorage) {
					// LocalStorage is available, use persistent value
					let v = localStorage.getItem(storageKey);
					console.log('Preset isExpanded for \'' + myPath + '\' to ' + v);
					if (v == 'false')
						isExpanded = false;
				}
				let displayExpandState = function() {
					console.log('Display isExpanded for \'' + myPath + '\' as ' + isExpanded);
					if (isExpanded) {
						// Expand this block
						_itemContainer.classList.add('expanding');
						_itemContainer.onanimationend = function() {
							_itemContainer.classList.remove('collapsed');
							_itemContainer.classList.remove('expanding');
						};
						// Reflect action of resize-icon
						expandIcon.title = 'Hide';
					} else {
						// Collapse this block
						_itemContainer.classList.add('collapsing');
						_itemContainer.onanimationend = function() {
							_itemContainer.classList.add('collapsed');
							_itemContainer.classList.remove('collapsing');
						};
						// Reflect action of resize-icon
						expandIcon.title = 'Show';
					}
				};
				expandIcon.onclick = function() {
					isExpanded = !isExpanded;
					console.log('Set isExpanded for \'' + name + '\' to ' + isExpanded);
					if (localStorage) {
						// LocalStorage is available, persist it
						localStorage.setItem(storageKey, isExpanded);
					}
					displayExpandState();
				};
				addClosingElements = function() {
					// Display the initial state
					//displayExpandState();  //display initial state
					if (isExpanded) {
						expandIcon.title = 'Hide';
					} else {
						_itemContainer.classList.add('collapsed');
						expandIcon.title = 'Show';
					}
				}
			}
			return _itemContainer;
		}
		addSubContainer = function() {
			_subContainer = document.createElement('div');
			_subContainer.className = 'items block-items';
			let sliderContainer = document.createElement('div');
			sliderContainer.className = 'slider-container';
			sliderContainer.appendChild(_subContainer);
			_itemContainer.appendChild(sliderContainer);
			return _subContainer;
		}
	} else {
		// Render Item is (sub-)Item
		//console.log('Render Item ' + name);
		let _itemContainer;
		let _subContainer;
		addItemContainer = function() {
			let groupContainer;
			if (contItems != null) {
				groupContainer = document.createElement('div');  //make a div for the continuation group
				groupContainer.className = 'group';
				container.appendChild(groupContainer);
			} else {
				groupContainer = container;  //there is no group, use same container
			}
			_itemContainer = document.createElement('div');
			_itemContainer.className = 'item';
			groupContainer.appendChild(_itemContainer);
			return _itemContainer;
		}
		addSubContainer = function() {
			_subContainer = document.createElement('div');
			_subContainer.className = 'items';
			container.appendChild(_subContainer);
			return _subContainer;
		}
	}
	// Create element itself
	if (name == '---') {
		// Special separator item
		let item = document.createElement('hr');
		item.className = 'separator';
		container.appendChild(item);
	} else {
		let itemContainer = addItemContainer();
		// The containers are structured as follows:
		// - groupContainer: Only if there are continued Items
		//     - itemContainer: Holds the entire (Sub)Item
		//         - checkbox: Only if it is a checkbox item
		//         - linkContainer: Only if there is a URL
		//             - icon: In itemContainer if there is no linkContainer
		//             - textContainer: Only present if there is a name
		//                              In itemContainer if there is no linkContainer
		//                 - text: name
		//         - continued items
		//         - items: Only if there are subItems

		// Declare textContainer to hold the name/label
		let textContainer = null;
		let setTextClass = function(className, add) {
			if (textContainer != null) {
				if (add)
					textContainer.classList.add(className);
				else
					textContainer.classList.remove(className);
			}
		};

		// Create checkbox
		let checkbox = null;
		if (check != null) {
			// Render a checkbox
			checkbox = document.createElement('input');
			checkbox.type = 'checkbox';
			checkbox.className = 'todo-checkbox';
			checkbox.onchange = function() {
				let re = new RegExp('(^(?:[^\\n]*\\n){' + link.lineNum + '}\\s*)\\[.?\\]');
				let newCheck;
				if (checkbox.checked) {
					// Change checkbox to checked
					console.log('Check checkbox on line ' + link.lineNum);
					newCheck = '[x]';
				} else {
					// Change checkbox to checked
					console.log('Uncheck checkbox on line ' + link.lineNum);
					newCheck = '[ ]';
				}
				Links = Links.replace(re, '$1' + newCheck);
				writeLinks(Links);
				setTextClass('checked', checkbox.checked);
			};
			checkbox.checked = check;
		}

		// Create icon_control
		let icon_control = outputIcon(null, icon, url);

		// Create textContainer to hold the name/label
		if (name != null) {
			let display_name = true;
			if (name == '_') {
				// Name indicates it should not be displayed.
				// Do this only if this doesn't lead to
				// unclickable links and the like.
				if (icon_control.present) {
					// There is an icon that is clickable too.
					display_name = false;
				} else if (url == null) {
					// This item is not clickable anyway.
					display_name = false;
				} else {
					// We cannot hide it, give it a better name
					if (level == 1) name = 'Heading';
					else if (level == 2) name = 'Block';
					else name = 'Item';
				}
			}
			if (display_name) {
				textContainer = document.createElement('span');
				textContainer.appendChild(document.createTextNode(name));
				if (check != null) {
					// This is a checkbox item, give the name the correct class
					textContainer.className = 'checkbox-label';
					setTextClass('checked', check);
				} else {
					textContainer.className = 'link-name';
				}
			}
		}

		// Create hyperlink
		let hyperlink = null;
		if (url != null) {
			hyperlink = document.createElement('a');
			hyperlink.href = url;
			hyperlink.className = 'link';
			if (target != null)
				hyperlink.target = target;
			if (tooltip != null)
				hyperlink.title = tooltip;
		}

		// Add checkbox to the itemContainer
		if (checkbox != null) {
			itemContainer.appendChild(checkbox);
		}

		// Add hyperlink to itemContainer
		// Alias linkContainer to hyperlink if it exists, itemContainer otherwise
		let linkContainer;  //this container holds the link
		if (hyperlink != null) {
			itemContainer.appendChild(hyperlink);
			linkContainer = hyperlink;
		} else {
			linkContainer = itemContainer;
		}

		// Add icon_control to linkContainer
		if (icon_control.element != null) {
			linkContainer.appendChild(icon_control.element);
		}

		// Add textContainer to linkContainer
		if (textContainer != null) {
			linkContainer.appendChild(textContainer);
		}

		// If there is continuation, output those items in this itemContainer too
		if (contItems != null) {
			outputItems(contItems, level, itemContainer, myPath);
		}
	}
	// Create sub-Items in container
	if (subItems != null) {
		if (addSubContainer) {
			let subContainer = addSubContainer();
			outputItems(subItems, level+1, subContainer, myPath);
		}
	}
	// Add closing elements
	if (addClosingElements) {
		addClosingElements();
	}
}

// Output a <div> element as next child of the container.
function outputText(lines, container) {
	let html = lines.join('\n');
	let div = document.createElement('div');
	div.className = 'text-block';
	div.innerHTML = html;
	container.appendChild(div);
}

// Render array of Links to the container at specified level.
function outputItems(links, level, container, parentPath = '') {
	for (let i = 0; i < links.length; ++i) {
		let link = links[i];
		if (link.type == 'link') {
			outputItem(link, level, container, parentPath);
		} else if (link.type == 'text') {
			outputText(link.lines, container);
		}
	}
}

// }}}

// Output Icon {{{

// Create element for icon and return that
// If alt_text is defined, use that.
// icon_url is what is specified in the icon=URL argument, see explanation at
// the top of this file.
// Returns object with:
// - present: true if a non-empty icon is generated.
// - element: represents the icon, may be null.
//
// To retrieve the icon, first try the primary URL. If that fails and skip_alternatives==false,
// try these alternatives:
// - http://www.google.com/s2/favicons?domain=<target_url domain>
// - http://www.google.com/s2/favicons?domain=<icon_url domain>
function outputIcon(alt_text, icon_url, target_url, skip_alternatives = false) {
	// By default, construct icon_url from target_url
	if ((icon_url == null || icon_url == 'default') && target_url != null) {
		icon_url = getDefaultIconUrl(target_url);
	}

	// Resolve the IconDefs
	if (icon_url != null) {
		icon_url = resolveIconDefs(icon_url);
	}

	let icon_present = false;
	let icon_element = null;

	// Render icon_url
	let m;  //for regex matches
	if (icon_url == null) {
		console.log('Loading icon for target \'' + target_url + '\': null');
	} else if (icon_url == 'none') {
		console.log('Loading icon for target \'' + target_url + '\': \'' + icon_url + '\'');
	} else if (m = icon_url.match(/^html:(.+)/i)) {
		let html = m[1];
		// Create a 'data:...' pseudo URL that holds the data as SVG and put this text in a text node.
		let iconDiv = document.createElement('div');
		iconDiv.className = 'item-icon text-icon';
		let htmlDiv = document.createElement('div');
		htmlDiv.innerHTML = html;  //also takes care of HTML rendering
		FillScaler.observe(htmlDiv);
		iconDiv.appendChild(htmlDiv);
		icon_element = iconDiv;
		icon_present = true;
	} else {
		console.log('Loading icon for target \'' + target_url + '\': \'' + icon_url + '\'');
		let img = document.createElement('img');
		icon_present = true;
		if (icon_url == 'empty') {
			img.style.visibility = 'hidden';
			icon_present = false;  //there is an image, but still empty
		} else if (m = icon_url.match(/^char:(.+)/i)) {
			let text = m[1];
			// Create a 'data:...' pseudo URL that holds the data as SVG and put this text in a text node.
			icon_url = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">' + text + '</text></svg>';
			img.src = icon_url;
		} else {
			let alternatives = [], methods = [], urls = [];  //prepare options to use for the icon
			if (m = icon_url.match(/^alt(?::([^?]+))?(?:\?(.+))?/i)) {
				// icon_url contains an alt specification
				let method = m[1];
				let url = m[2];
				if (method == null || method == '' || method == 'any' || method == '*') {
					// Add all known methods
					methods.push('google');
				} else {
					// Add only the specified method
					methods.push(method);
				}
				if (url != null && url != '') {
					// Add the specified URL only
					urls.push(url);
				} else {
					// Add the icon_url (but that doesn't contain a URL) and target_url
					if (target_url != null && target_url != '') {
						urls.push(target_url);
					}
				}
			} else {
				// icon_url contains a URL of the icon
				alternatives.push(icon_url);
				if (!skip_alternatives) {
					// Try the alternatives in order of 'likely correct'.
					// Note that the google-favicons always returns an image, even a generic one, so it
					// will always prevent further alternatives to be attempted.
					methods.push('google');
					if (icon_url != null) {
						urls.push(icon_url);
					}
					if (target_url != null) {
						urls.push(target_url);
					}
				}
			}
			//console.log('All methods for ' + icon_url); console.log(methods);
			//console.log('All urls for ' + icon_url); console.log(urls);
			// Go through methods and urls and add alternatives
			for (let m = 0; m < methods.length; ++m) {
				let method = methods[m];
				for (let u = 0; u < urls.length; ++u) {
					if (method == 'google') {
						alternatives.push(getGoogleAltIconUrl(urls[u]));
					} else {
						console.error('Unknown alt icon method: ' + method);
					}
				}
			}
			//console.log('All alternatives for ' + icon_url); console.log(alternatives);
			// Remove duplicates
			let seen = {};
			let alt_list = alternatives;  //may have duplicates
			alternatives = [];  //get the unique ones
			for (let a = 0; a < alt_list.length; ++a) {
				if (!seen[alt_list[a]]) {
					seen[alt_list[a]] = true;
					alternatives.push(alt_list[a]);
				}
			}
			//console.log('All unique alternatives for ' + icon_url); console.log(alternatives);
			// Set the icon urls until we find one that works
			let try_next = function() {
				if (alternatives.length > 0) {
					// Try next alternative
					//console.log('alternatives.length=' + alternatives.length);
					//console.log('alternatives[0]=' + alternatives[0]);
					let alt = alternatives.shift();
					//console.log('alternatives.length=' + alternatives.length);
					if (img.src != null && img.src != '') {
						console.warn('Cannot load icon \'' + img.src + '\', try \'' + alt + '\'');
					}
					img.src = alt;
				} else {
					// Stop trying
					console.error('Cannot load icon: ' + img.src);
					if (alt_text != null) {
						// prepare to show the alt text
						img.src = '';
					} else {
						// hide entire image
						img.style.visibility = 'hidden';
					}
					img.onerror = null;  //stop handling errors
				}
			}
			img.onerror = try_next;
			try_next();  //set first alternative
		}
		if (alt_text != null) {
			img.alt = alt_text;
		}
		img.className = 'item-icon';
		icon_element = img;
	}

	return {
		'present' : icon_present,
		'element' : icon_element,
	};
}

// Take icon_url and perform the icondef replacements.
// Returns the resolved value or the original value if no icondefs matched.
function resolveIconDefs(icon_url) {
	let retval = icon_url;
	let seen = {};  //to break cycles
	seen[icon_url] = 1;
	let override = IconDefs[icon_url];
	while (override !== undefined && !seen[override]) {
		console.log('Replace icon=' + icon_url + ' by IconDefs ' + override);
		retval = override;
		seen[override] = 1;
		override = IconDefs[override];
	}
	//console.log('Returning ' + retval);
	return retval;
};

// Define a ResizeObserver that is used to resize entries to 100% of their
// parent's size. This is used for icons that are defined with html:<x>.
var FillScaler = new ResizeObserver(function(entries) {
	for (let entry of entries) {
		let element = entry.target;
		// Get entries current size
		let w, h;
		if (entry.borderBoxSize) {
			let rect = entry.borderBoxSize[0];  //area of 1st (and only) fragment
			let writingMode = element.style.writingMode;
			//console.log('FillScaler: Writing mode ' + writingMode);
			if (writingMode.match(/^vertical/i)) {
				// Vertical writing-mode, so inline direction is vertical
				h = rect.inlineSize;
				w = rect.blockSize;
			} else {
				// Assume horizontal writing-mode, so inline direction is horizontal
				w = rect.inlineSize;
				h = rect.blockSize;
			}
		} else {
			let rect = entry.contentRect;
			w = entry.contentRect.width;
			h = entry.contentRect.height;
		}
		console.log('FillScaler: Element size ' + w + ' x ' + h);
		// Get parent's current size
		let parent = element.parentElement;
		let pw = parent.offsetWidth;
		let ph = parent.offsetHeight;
		//console.log('FillScaler: Parent size ' + pw + ' x ' + ph);
		// Calculate new scaling factor
		let scaleX = pw / w;
		let scaleY = ph / h;
		//console.log('FillScaler: Scale with ' + scaleX + ' x ' + scaleY);
		// Check if the change is big enough
		let changeX = element._scaleX / scaleX;
		let changeY = element._scaleY / scaleY;
		//console.log('FillScaler: Scale change ' + changeX + ' x ' + changeY);
		if (isNaN(changeX) || changeX < 0.98 || changeX > 1.02 || isNaN(changeY) || changeY < 0.98 || changeY > 1.02) {
			// More than 2% change
			console.log('FillScaler: Set scale ' + scaleX + ' x ' + scaleY);
			element._scaleX = scaleX;
			element._scaleY = scaleY;
			entry.target.style.scale = scaleX + ' ' + scaleY;
		} else {
			console.log('FillScaler: Scale change too small ' + changeX + ' x ' + changeY);
		}
	}
});

// Return the URL where the default icon should be.
function getDefaultIconUrl(site_url) {
	return site_url.replace(/(?:(?:(?<!\/)\/(?!\/)|\?|#).*)?$/, '/favicon.ico');  //replace first single '/', '?' or '#' and onwards
}

// Return the URL for an icon of the site_url's domain.
// This method uses the Google database.
function getGoogleAltIconUrl(site_url) {
	let domain = site_url
		.replace(/^[^\/]*\/\//, '')  //remove scheme
		.replace(/\/.*/, '');  //remove path
	return 'http://www.google.com/s2/favicons?domain=' + domain;
}

// }}}

// }}}

// SearchBox related functions {{{

// The search functions will be accessed by name (lower case identifier).
// Every identifier has sub-keys for different functions.
// A search function has the search query as input and should return a URL to
// go to for the results.

var SearchFunction = {
	'duck duck go' : {
		'text'   : getTemplateUrl('https://duckduckgo.com?q=%urlinput'),
	},
	'google' : {
		'text'   : getTemplateUrl('https://www.google.com/search?q=%urlinput'),
	},
	'wikipedia' : {
		'text'   : getTemplateUrl('https://www.wikipedia.org/wiki/Special:Search?go=Go&search=%urlinput'),
	},
	'youtube' : {
		'text'   : getTemplateUrl('https://www.youtube.com/results?search_query=%urlinput'),
	},
	'wayback machine' : {
		'text'   : getWaybackSearchUrl,
		'domain' : getWaybackDomainUrl,
	},
	'google maps' : {
		'text'   : getTemplateUrl('https://maps.google.com/?q=%urlinput'),
	},
	'default' : {
		'text'   : getNoUrl,
		'domain' : getWithSchemaUrl,
	},
};

// Return a URL to handle the address (ie beautify it to go to it).
function getWithSchemaUrl(address) {
	let url = address;
	if (!url.match(/^[\w+-]+:/)) {
		url = 'http://' + url;  //add default scheme
	}
	return url;
}

// This is a dummy search function, that can be used as a default.
function getNoUrl(intput) {
	return null;
}

// This function returns a function that uses the template to construct a URL.
// The template is a URL with the following placeholders:
// - %input: Replaced with the supplied input value.
// - %urlinput: Replaced with the URL-encoded input value.
function getTemplateUrl(template) {
	return function(input) {
		let encoded_input = encodeURIComponent(input).replace(' ', '+');
		return template
			.replace('%input', input)
			.replace('%urlinput', encoded_input);
	};
}

// Returns a URL to perform a lookup for the domain with Wayback Machine.
function getWaybackDomainUrl(domain) {
	let ts = getWaybackTimestamp();
	return 'https://web.archive.org/web/' + ts + '/' + domain;
};

// Returns a URL to perform a search for input with Wayback Machine.
function getWaybackSearchUrl(input) {
	let ts = getWaybackTimestamp();
	let encoded_input = encodeURIComponent(input).replace(' ', '+');
	return 'https://web.archive.org/web/' + ts + '/' + encoded_input;
};

// Create a Wayback Machine timestamp that can be used in queries.
function getWaybackTimestamp(date = new Date()) {
	let pad = function(number, positions) {
		let neg = false;
		if (number < 0) {
			neg = true;
			positions--;  //space for '-'
			number = -number;
		}
		let s = '';
		for (let i = 2, limit = 10; i <= positions; ++i, limit *= 10) {
			if (number < limit) s += '0';
		}
		s += number;
		if (neg) s = '-' + s;
		return s;
	};
	// I assume the format is 'yyyymmddhhmmss*' with yyyy the year
	// to query and the rest '0'.
	let timestamp = pad(date.getFullYear(), 4) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		'*';
	return timestamp;
}

// Process search input.
// Redirects to search.
// May return if search input is not clear.
function processSearchInput(searchBox, getSearchUrl, getDomainSearchUrl = getWithSchemaUrl) {
	let input = searchBox.value;
	if (input.match(/^\s*$/)) {
		console.log('Empty search string');
		// Set the blink animated style
		searchBox.classList.add('blink');
		searchBox.onanimationend = function() {
			//console.log('animation end');
			searchBox.classList.remove('blink');
		};
	} else {
		let m = input.match(/^\s*(\S+\.\S+)\s*$/);
		let url = null;
		if (m && getDomainSearchUrl) {
			//console.log('Looks like URL');
			url = getDomainSearchUrl(m[1]);
			console.log('Go to URL \'' + url + '\'');
		} else {
			url = getSearchUrl(input);
			console.log('Search \'' + url + '\'');
		}
		if (url) {
			window.location.href = url;
		} else {
			console.log('No URL to go to');
		}
	}
}

// Create search button to container and set up the event callback.
// This also adds icons to the buttons. Do that here instead of with
// static HTML, because I saw that the browser tries to render static
// images before the JavaScript generated ones and I'd like to render
// the links as soon as possible.
// The displayed icon is specified by icon_url. If this is 'alt', the
// target domain is derived from getSearchUrl().
function addSearchButton(container, search_box, button_id, label_text, tooltip, icon_url, getSearchUrl, getDomainSearchUrl) {
	let btn = document.createElement('button');
	if (btn) {
		// Configure the button
		btn.id = 'BtnSearch' + button_id;
		btn.className = 'button';
		btn.onclick = function() {
			processSearchInput(search_box, getSearchUrl, getDomainSearchUrl);
			return false;  //skip default handling
		}
		btn.title = tooltip;

		// Add icon
		let target_domain = getSearchUrl('__favicon_check__');
		//console.log('target_domain=' + target_domain);
		//console.log('favicon=' + getDefaultIconUrl(target_domain));
		// When determining the icon, don't consider alternatives,
		// except when icon_url == 'alt...'
		let icon = outputIcon(tooltip, icon_url, target_domain, true);
		if (icon.element != null) btn.appendChild(icon.element);

		// Add link text
		let label = document.createElement('span');
		label.className = 'label';
		let textNode = document.createTextNode(label_text);
		label.appendChild(textNode);
		btn.appendChild(label);

		// Add the button to the container
		container.appendChild(btn);
	}
}

function addSearchButtons(searchBox, container) {
	for (let i = 0; i < SearchButtonDefs.length; ++i) {
		// Get the fields from the definition
		let def = SearchButtonDefs[i];
		let f = 0;

		// Determine Identifier
		let id = def[f++];
		if (!id) continue;  //id is mandatory, ignore this entry if absent
		let key = id.toLowerCase();  //lower case version

		// Determine referenced Search URL Functions
		let getSearchUrl = null, getDomainSearchUrl = null;
		let searchFunction = SearchFunction[key];
		if (searchFunction) {
			getSearchUrl = SearchFunction[key]['text'];
			getDomainSearchUrl = SearchFunction[key]['domain'];
		}

		// Determine Label
		let label = def[f++] || id;

		// Determine Tooltip
		let tooltip = def[f++] || id;

		// Determine Icon
		let icon = def[f++];
		if (!icon) {
			if (getSearchUrl) {
				// Search URL function is defined. This is
				// needed to retrieve the 'default' icon.
				icon = 'default';
			} else {
				// There is no Search URL function, use a
				// standard magnifying glass icon.
				icon = 'char:' + UNICODE_LEFT_POINTING_MAGNIFYING_GLASS;
			}
		}

		// Determine final Search URL Function
		if (!getSearchUrl) {
			// No Search Function, use default (assume it exists)
			getSearchUrl = SearchFunction['default']['text'];
		}

		// Determine final Domain Search URL Function
		if (!getDomainSearchUrl) {
			// No Search Function, use default (assume it exists)
			getDomainSearchUrl = SearchFunction['default']['domain'];
		}

		// Log the fields
		console.log('addSearchButtons: Identifier=\'' + id + '\'');
		console.log('addSearchButtons: Label=\'' + label + '\'');
		console.log('addSearchButtons: Tooltip=\'' + tooltip + '\'');
		console.log('addSearchButtons: Icon=\'' + icon + '\'');
		console.log('addSearchButtons: getSearchUrl=\'' + getSearchUrl + '\'');
		console.log('addSearchButtons: getDomainSearchUrl=\'' + getDomainSearchUrl + '\'');
		//console.log(SearchFunction);

		// Create the button
		addSearchButton(container, searchBox, id, label, tooltip, icon, getSearchUrl, getDomainSearchUrl);
	}
}

// }}}

// Edit Settings {{{

let showSettings = null;  // will be set later

// Set up the events for the settings panel.
function initSettingsPanel() {
	let iconOpen = document.getElementById('SettingsIcon');
	let iconSave = document.getElementById('SettingsSaveIcon');
	let iconClear = document.getElementById('SettingsClearIcon');
	let iconCancel = document.getElementById('SettingsCancelIcon');
	let pnlSettings = document.getElementById('SettingsForm');
	let txtSettings = document.getElementById('SettingsText');
	let btnSave = document.getElementById('BtnSaveSettings');
	let btnClear = document.getElementById('BtnClearSettings');
	let btnCancel = document.getElementById('BtnCancelSettings');
	let iconBarClosed = document.getElementById('SettingsIconBarClosed');  //iconbar for closed status
	let iconBarOpen = document.getElementById('SettingsIconBarOpen');  //iconbar for open status
	// Set characters in icons
	setIfSupported(iconOpen, 'textContent', UNICODE_GEARS);
	setIfSupported(iconSave, 'textContent', UNICODE_WHITE_HARD_SHELL_FLOPPY_DISK);
	setIfSupported(iconClear, 'textContent', UNICODE_EMPTY_DOCUMENT);
	setIfSupported(iconCancel, 'textContent', UNICODE_CANCELLATION);
	// Set show/hide animations
	let visible = false;
	showSettings = function() {
		txtSettings.value = Links;
		// Slide panel to visible
		pnlSettings.classList.add('expanding');
		pnlSettings.classList.add('show');
		pnlSettings.onanimationend = function() {
			pnlSettings.classList.remove('expanding');
		};
		// Slide iconBarClosed out and iconBarOpen in
		let going = iconBarClosed, coming = iconBarOpen;
		going.classList.add('slide-out');
		going.onanimationend = function() {
			going.classList.add('hidden');
			going.classList.remove('slide-out');
			coming.classList.remove('hidden');
			coming.classList.add('slide-in');
		};
		coming.onanimationend = function() {
			coming.classList.remove('slide-in');
		};
		visible = true;
	};
	let hideSettings = function(save) {
		let hide = () => {
			// slide panel to hidden
			pnlSettings.classList.add('collapsing');
			pnlSettings.onanimationend = function() {
				pnlSettings.classList.remove('show');
				pnlSettings.classList.remove('collapsing');
			};
			// Slide iconBarOpen out and iconBarClosed in
			let going = iconBarOpen, coming = iconBarClosed;
			going.classList.add('slide-out');
			going.onanimationend = function() {
				going.classList.add('hidden');
				going.classList.remove('slide-out');
				coming.classList.remove('hidden');
				coming.classList.add('slide-in');
			};
			coming.onanimationend = function() {
				coming.classList.remove('slide-in');
			};
			visible = false;
		};
		if (save) {
			let saveLinks = Links;
			if (save == 'clear' || txtSettings.value == '') {
				console.log('Clear settings');
				loadLinks(true, true)  //re-resolve Links
				.then(() => {
					// Links are correct
					txtSettings.value = '';
					writeLinks(null);  //remove previous stored Links
					// Close the panel
					hide();
				})
				.catch(error => {
					// There was an error
					// Always log for debugging
					console.error(error);
					// Put newly read value in txtSettings to correct.
					// Restore old value in Links in case of cancel.
					txtSettings.value = Links;
					Links = saveLinks;
					if (error instanceof UserInputError) {
						// It is a UserInputError, show a dialog,
						// because the user can fix it.
						window.alert('Error when reloading settings: ' +
							error.message +
							'\n\nPlease correct or cancel.');
					} else {
						// It is another error, discard it, because
						// it has already been logged.
					}
				});
			} else {
				console.log('Save settings');
				try {
					Links = txtSettings.value;
					processLinks();  //Render Links
					// Links are correct
					writeLinks(Links);
					// Close the panel
					hide();
				} catch (error) {
					// Always log for debugging
					console.error(error);
					if (error instanceof UserInputError) {
						// It is a UserInputError, show a dialog,
						// because the user can fix it.
						window.alert('Error when saving settings: ' +
							error.message +
							'\n\nPlease correct or cancel.');
					} else {
						// It is another error, discard it, because
						// it has already been logged.
					}
					// Leave the value in txtSettings to correct.
					// Restore old value in Links in case of cancel.
					Links = saveLinks;
				}
			}
		} else {
			// Cancel
			hide();
		}
	};
	// Set initial state
	if (visible) {
		// showSettings() without animation
		txtSettings.value = Links;
		pnlSettings.classList.add('show');
		iconBarClosed.classList.add('hidden');
		iconBarOpen.classList.remove('hidden');
	} else {
		// hideSettings() without animation
		pnlSettings.classList.remove('show');
		iconBarClosed.classList.remove('hidden');
		iconBarOpen.classList.add('hidden');
	}
	// Bind iconOpen
	if (iconOpen && pnlSettings) {
		iconOpen.onclick = function() {
			if (visible) hideSettings(false); else showSettings();
		};
	}
	// Initialize special behavior in the text panel
	if (txtSettings) {
		txtSettings.onkeydown = function(e) {
			//console.log('KeyCode=' + e.keyCode);
			if (e.keyCode == 9) {
				// This is the TAB key -> Insert 4 spaces
				textInsert(this, () => ' '.repeat(4));
				return false;  //stop further handling
			} else if (e.keyCode == 13) {
				// This is the Enter key -> Copy indentation from current line
				textInsert(this, (before, mid, after) => {
					let m = before.match(/(?:^|\r|\n)([ \t]*)[^\r\n]*$/);  //match: 'linebreak whitespace line end'
					return '\n' + m[1];  //insert linebreak plus matched whitespace
				});
				return false;  //stop further handling
			}
			return true;
		};
	}
	// Bind buttons (in case those are used)
	if (btnSave) {
		btnSave.onclick = function() {
			if (visible) hideSettings(true);
			return false;  //stop default button action
		};
	}
	if (btnClear) {
		btnClear.onclick = function() {
			if (visible) hideSettings('clear');
			return false;  //stop default button action
		};
	}
	if (btnCancel) {
		btnCancel.onclick = function() {
			if (visible) hideSettings(false);
			return false;  //stop default button action
		};
	}
	// Bind icons (in case those are used)
	if (iconSave) {
		iconSave.onclick = function() {
			if (visible) hideSettings(true);
		};
	}
	if (iconClear) {
		iconClear.onclick = function() {
			if (visible) hideSettings('clear');
		};
	}
	if (iconCancel) {
		iconCancel.onclick = function() {
			if (visible) hideSettings(false);
		};
	}
}

// Assume the ctl is an input control.
// Return the sanitized insertion point or selection range.
function getSelectionPos(ctl) {
	// The selection position indicates the selection, but also the insertion point
	let start = ctl.selectionStart;  //char pos AT which the selection starts
	let end = ctl.selectionEnd;  //char pos AFTER the selection end
	// Sanitize, so it is within the string:
	// - start is in [0, len]
	// - end is in [start, len]
	let len = ctl.value.len;
	if (start == null || start < 0) start = 0;
	if (start > len) start = len;
	if (end == null || end < start) end = start;
	if (end > len) end = len;

	return [start, end];
}

// Assume the ctl is an input control.
// Determine the strings before and after the insertion point.
// Then call the inserter with these values. The inserter should return the insertion string.
// Update ctl and place the new insertion point after the insertion.
function textInsert(ctl, inserter) {
	let pos = getSelectionPos(ctl);
	let start = pos[0], end = pos[1];
	// Do the insertion, replace the selection if any
	let before = ctl.value.substring(0, start), mid = ctl.value.substring(start, end), after = ctl.value.substring(end);
	let mid2 = inserter(before, mid, after);
	ctl.value = before + mid2 + after;
	// Put the insertion point after the insertion
	let newPos = start + mid2.length;
	ctl.selectionStart = ctl.selectionEnd = newPos;
}

// }}}

// Handling prefer-color-scheme and PageTheme {{{

// Global variables that are used to monitor prefers-color-scheme
var PrefersColorSchemeListener = null;

// Function to set the theme of the body to the specified string.
// NB: The string theme can contain multiple CSS-class names.
function setPageTheme(theme) {
	// Determine value or default
	if (theme == null) theme = 'dark-theme';
	// Overwrite the current values
	console.log('Set PageTheme to \'' + theme + '\'');
	document.body.className = theme;
}

// Initialize monitoring of light/dark theme and adjust PageTheme accordingly.
function initMonitorPreferColorScheme(enable) {
	// Remove existing listener
	if (PrefersColorSchemeListener) {
		console.log('call PrefersColorSchemeListener.finit()');
		PrefersColorSchemeListener.finit();
		PrefersColorSchemeListener = null;
	}

	// Enable listener
	if (enable) {
		// Create a new listener
		// Note: If the function(){} syntax is used, 'this' refers to
		// the object. If ()=>{} syntax is used, 'this' refers to the
		// global window object, which is not what we need here.
		PrefersColorSchemeListener = {
			dark : window.matchMedia('(prefers-color-scheme: dark)'),
			light : window.matchMedia('(prefers-color-scheme: light)'),
			init : function() {
				console.log('Install prefers-color-scheme listener');
				this.dark.addEventListener('change', this.handler);
				this.light.addEventListener('change', this.handler);
			},
			finit : function() {
				console.log('Remove prefers-color-scheme listener');
				this.dark.removeEventListener('change', this.handler);
				this.light.removeEventListener('change', this.handler);
			},
			handler : function() {
				// Note: This handler may be called as event of
				// a matchMedia, in which case 'this' refers
				// to *that* object.
				if (!PrefersColorSchemeListener) return;
				if (PrefersColorSchemeListener.dark.matches) {
					console.log('User prefers dark mode.');
					setPageTheme('dark-theme');
				} else if (PrefersColorSchemeListener.light.matches) {
					console.log('User prefers light mode.');
					setPageTheme('light-theme');
				} else {
					console.log('No specific preference detected, use default.');
					setPageTheme(null);
				}
			},
		};
		//console.log('call PrefersColorSchemeListener.init()');
		PrefersColorSchemeListener.init();

		// Set the current theme
		//console.log('call PrefersColorSchemeListener.handler()');
		PrefersColorSchemeListener.handler();
	}
}

// }}}

// Initialization {{{

// Function to detect if a unicode character is supported by the specified font.
// - character: Character to test.
// - font: Font to test. Defaults to font as specified for the body.
// - recursion is for internal use.
// Return true if supported, false if not.
function characterIsSupported(character, font = null, recursion = false) {
	// This function is copied from https://stackoverflow.com/questions/1911000/detecting-individual-unicode-character-support-with-javascript

	// This function creates a referenceCanvas with the character U+FFFF,
	// which does not have a representation.
	// It then creates the testCanvas with the character to test.
	// The final test is to see if both canvases are the same (by testing
	// the contents of the BASE64 data: URL). If they are the same, the
	// test character cannot be represented either.

	if (font === null) font = getComputedStyle(document.body).fontFamily;

	const Debug = false;
	const Transparent = false;

	// Create the canvases
	let testCanvas = document.createElement('canvas');
	let referenceCanvas = document.createElement('canvas');
	testCanvas.width = referenceCanvas.width = testCanvas.height = referenceCanvas.height = 100;
	if (Debug) {
		testCanvas.style.backgroundColor = referenceCanvas.style.backgroundColor = 'magenta';
		testCanvas.style.margin = referenceCanvas.style.margin = '10px';
	}

	// Render the characters
	let testContext = testCanvas.getContext('2d');
	let referenceContext = referenceCanvas.getContext('2d');
	testContext.font = referenceContext.font = '100px ' + font;
	testContext.fillStyle = referenceContext.fillStyle = 'black';
	testContext.fillText(character, 0, 100);
	referenceContext.fillText('\uffff', 0, 100);

	// Firefox renders unsupported characters by placing their character
	// code inside the rectangle making each unsupported character look
	// different.  As a workaround, in Firefox, we hide the inside of the
	// character by placing a black rectangle on top of it.
	// The rectangle we use to hide the inside has an offset of 10px so it
	// can still see part of the character, reducing the risk of false
	// positives.  We check for Firefox and browers that behave similarly
	// by checking if U+FFFE is supported, since U+FFFE is, just like
	// U+FFFF, guaranteed not to be supported.
	if (!recursion && characterIsSupported('\ufffe', font, true)) {
		let fillStyle = Transparent ? 'rgba(0, 0, 0, 0.6)' : 'black';
		testContext.fillStyle = referenceContext.fillStyle = fillStyle;
		testContext.fillRect(5, 5, 90, 90);
		referenceContext.fillRect(5, 5, 90, 90);
	}

	// Check if the canvases are identical
	let displayedSame = testCanvas.toDataURL() == referenceCanvas.toDataURL();

	// Output images at the end of the body for debugging
	if (Debug) {
		var div = document.createElement('div');
		document.body.appendChild(div);
		div.appendChild(document.createTextNode('Character U+' +
			character.charCodeAt(0).toString(16).toUpperCase() +
			', recursion=' + recursion));
		div.appendChild(referenceCanvas);
		div.appendChild(testCanvas);
		div.appendChild(document.createTextNode(displayedSame ? ' => Not supported' : ' => Unique'));
	}

	// Character is not supported if it looks the same as the reference
	return !displayedSame;
}

// Helper function.
// If character is supported by the control, set the property with the
// specified name. Use the control's fontFamily if available.
function setIfSupported(control, property, character) {
	let style = getComputedStyle(control);
	let font = style ? style.fontFamily : null;
	if (!font) font = null;
	let supported = characterIsSupported(character, font);
	if (supported) {
		control[property] = character;
	}
	return supported;
}

// The input is direct content or an array with blocks that contain lines and
// a starting line number. If blocks==null, nothing is done.
// The blocks are used to create a single content string. applyFunc is caled
// with that string. This function returns whatever applyFunc() returned.
// If applyFunc() throws an error, the stacktrace is searched and if it
// contains an eval(), that line number is converted and added to the error
// string. This (optionally modified) error is re-thrown.
function applyBlocks(blocks, applyFunc) {
	if (blocks != null) {
		let contents, lineNums;
		if ('length' in blocks) {
			// This is an array, assume of Block objects.
			// Concatenate and translate line numbers.
			contents = [];
			lineNums = [ 0 ];  //eval lineNum -> input lineNum
			let inputLineNum;
			for (let i = 0; i < blocks.length; ++i) {
				let block = blocks[i];
				inputLineNum = block.lineNum + 1;  //content starts 1 line after block
				for (let j = 0; j < block.lines.length; ++j) {
					contents.push(block.lines[j]);
					lineNums.push(inputLineNum + j);
				}
			}
			contents = contents.join('\n');
		} else {
			contents = blocks;  //single string
			lineNums = null;  // not available
		}
		try {
			// Try to apply the contents
			return applyFunc(contents);
		} catch (error) {
			if ('stack' in error && lineNums != null) {
				// There's a stack and line numbers to try to
				// report on the original input line number.
				let stack = error.stack.toString();
				let m = stack.match(/\beval:(\d+)/);  //Firefox syntax
				if (!m) m = stack.match(/<?\banonymous>?:(\d+)/);  //Edge syntax
				if (m) {
					// We got the line number inside an eval
					// translate it to the input line numbers
					let lineNum = m[1];
					if (lineNum >= 1 && lineNum < lineNums.length) {
						// It in the expected range
						lineNum = lineNums[lineNum];
						error.message += ' on line ' + lineNum;
					}
				}
			}
			throw error;  //re-throw
		}
	}
}

// Function to set the styles defined by the configuration.
// Should not throw exception, because errors are silently ignored.
function setStyleBlocks(styles) {
	applyBlocks(styles, function(str) {
		let el = document.getElementById('dynamic-styles');
		if (!el) {
			// Does not yet exist, create it
			el = document.createElement('style');
			el.id = 'dynamic-styles';
			document.head.appendChild(el);
		}
		el.innerHTML = str;
	});
}

// Function to add the script defined by the configuration.
// Throws exception if something is wrong.
function addScriptBlocks(script) {
	applyBlocks(script, function(str) {
		// Do an indirect eval().
		// According to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval ,
		// indirect eval() is safer.
		//console.log('Eval script: ', contents, lineNums);
		eval?.(str);
	});
	// Note: Script is added and I don't know of a way to remove script
	// (especially if they are used for events). This could be remedied
	// by performing a reload (window.location = window.location or so)
	// if the supplied script is different from the previously supplied
	// script.
	// I'm not doing automatic reload, because:
	// - With many scripts, reloading is not needed.
	// - Reloading may have side-effect, especially with events handlers.
	// - It wouldn't be sufficient, because a !text block may also contain
	//   script.
	// - The work-around of a manual page reload is not a big issue.
}

// Function to set the title to the specified string.
function setPageTitle(title) {
	// Determine value or default
	if (title == null) title = 'Favorites';
	// Set the title
	console.log('Set PageTitle to \'' + title + '\'');
	let titleCtl = document.getElementById('Title');
	if (titleCtl)
		titleCtl.innerText = title;
}

// Function to set the font-size to the specified string.
function setFontSize(size) {
	// Determine value or default
	if (size == null) size = '100%';
	// Set the --font-size variable that is used in the CSS classes
	console.log('Set FontSize to \'' + size + '\'');
	document.documentElement.style.setProperty('--font-size', size);
}

// From the Links configuration, parse its content and display it.
// This function may throw a UserInputError exceptions when something is wrong
// with the contents of the Links variable.
function processLinks() {
	// Parse Links
	parseLinks();

	// First handle scripts and styles (to catch errors quickly)
	try {
		setStyleBlocks(StyleBlocks);
		addScriptBlocks(ScriptBlocks);
	} catch (error) {
		let newError = new UserInputError(error.message);
		newError.cause = error;
		throw newError;
	}

	// Set page title, theme and font size
	setPageTitle(PageTitle);
	if (PageTheme == null || PageTheme.toLowerCase() == 'auto') {
		PageTheme = 'auto';
		initMonitorPreferColorScheme(true);
	} else {
		initMonitorPreferColorScheme(false);
		setPageTheme(PageTheme);
	}
	setFontSize(FontSize);

	// Render links
	let container = document.getElementById('LinksBox');
	container.textContent = '';
	outputItems(RootLinks, 1, container);

	// Fill SearchForm
	// Use a static input field, so that the browser retains its contents
	// after going back to this page.
	if (SearchButtonDefs != null && SearchButtonDefs.length > 0) {
		// There are SearchButtens, fill SearchForm
		console.log('There are ' + SearchButtonDefs.length + ' SearchButtonDefs');
		// Focus SearchBox
		let searchBox = document.getElementById('SearchBox');
		if (searchBox) {
			searchBox.focus();
			searchBox.select();
		}
		// Initialize the search buttons
		let buttonBox = document.getElementById('SearchButtons');
		buttonBox.textContent = '';
		addSearchButtons(searchBox, buttonBox);
	} else {
		// No SearchButtons defined, hide SearchForm
		console.log('There are no SearchButtonDefs');
		let searchForm = document.getElementById('SearchForm');
		if (searchForm) {
			console.log('Hide SearchForm');
			searchForm.style.display = 'none';
		}
	}
}

// Constructor function to construct a Promise in a pending state with
// additional functions resolve(value) and reject(error) to settle it.
function PendingPromise()
{
	let resolve, reject;
	let result = new Promise((resolveFunc, rejectFunc) => {  //Promise in pending state
		// Expose callbacks to be called later
		resolve = resolveFunc;
		reject = rejectFunc;
	});
	result['resolve'] = resolve;
	result['reject'] = reject;
	return result;
}

// Load the Links and render them.
// If reload==true, the Links are completely resolved again and possibly
// reloaded from URLs.
// If resolveLinks() is called, the value of skipLocalStorage is passed to
// control whether the value in LocalStorage is considered.
// This function returns a Promise to communicate when it's done or if there
// are exceptions.
function loadLinks(reload = false, skipLocalStorage = false, ready = null) {
	if (LinksPromise == null || reload) {
		// Resolve links if not already done so
		resolveLinks(skipLocalStorage);
	}

	let result = new PendingPromise();

	LinksPromise
	.then((value) => {
		// Links have been resolved
		//console.log(value);
		Links = value;

		// Process the Links
		processLinks();

		// Signal that this is done.
		result.resolve(true);
	})
	.catch(error => {
		if (error instanceof UserInputError) {
			// It is a UserInputError, trigger reject, because
			// the user can fix it.
			result.reject(error);
		} else {
			// It is another error, log it for debugging, but
			// do a resolve, so that no dialog is triggered.
			console.error(error);
			result.resolve(false);
		}
	});

	return result;
}

// Initialize the JavaScript on the page
function init() {
	initSettingsPanel();
	loadLinks(false, false)
	.catch(error => {
		// There is an error, report and open Settings
		// Always log for debugging
		console.error(error);
		if (error instanceof UserInputError) {
			// It is a UserInputError, show a dialog,
			// and open Settings, because the user can fix it.
			window.alert('Error when loading settings: ' +
				error.message +
				'\n\nPlease correct or cancel.');
			showSettings();
		} else {
			// It is another error, discard it, because
			// it has already been logged.
		}
	});
}
window.onload = init;

// }}}
</script>

</head>

<body class="dark-theme">

<h1 id="Title">Favorites</h1>

<span id="SettingsIconBar" class="settings-iconbar">

<div id="SettingsIconBarClosed">
  <span id="SettingsIcon" class="settings-icon" title="Settings">[Settings]</span>
</div>

<div id="SettingsIconBarOpen">
  <span id="SettingsSaveIcon" class="settings-icon" title="Save">[OK]</span>
  <span id="SettingsClearIcon" class="settings-icon" title="Clear">[_]</span>
  <span id="SettingsCancelIcon" class="settings-icon" title="Cancel">[X]</span>
</div>

</span>

<form id="SettingsForm" class="settings-form">
  <div class="panel">
    <textarea id="SettingsText" wrap="off" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Settings" class="textbox"></textarea>
    <div class="buttonbar">
      <button id="BtnSaveSettings" class="button">Save</button>
      <button id="BtnClearSettings" class="button">Clear</button>
      <button id="BtnCancelSettings" class="button">Cancel</button>
    </div>
  </div>
  <hr>
</form>

<form id="SearchForm" class="search-form">
  Search:
  <input id="SearchBox" name="q" type="text" size="40" class="textbox"/>
  <span id="SearchButtons"></span>
</form>

<div id="LinksBox"></div>

</body>

</html>

<!-- vim: set fdm=marker: -->

