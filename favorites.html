<!DOCTYPE html>
<html>

<!--
For description of this file, see README.md
For syntax description of Links, see help.html
-->

<head>

<!-- This page may contain UTF-8 encoded text, especially in the Links definition. -->
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>Favorites</title>

<style>
/* CSS styles {{{ */

/* Color palette */
:root {
	--background: #2E323B;
	--foreground: #DDDDDD;
	--accent-color: #50A0EE;
	--selection-background: #DDDDFF;
	--selection-foreground: #000000;
	--block-background: #C9CDD0;
	--block-foreground: #000000;
	--block-border: #EEEEEE;
	--disabled-color: #888888;
	--code-background: #282828;
	--code-foreground: var(--foreground);
	--link-color: #6666FF;
}

:root, body, input, textarea, button {
	font-family: 'Segoe UI', 'Lucida Grande', Helvetica, sans-serif;
	font-size: 12pt;
}
/*
https://www.w3schools.com/css/css_rwd_mediaqueries.asp advices the following sizes:
- max-width=600px: Extra small devices (phones)
- min-width=600px: Small devices (portrait tablets and large phones)
- min-width=768px: Medium devices (landscape tablets)
- min-width=992px: Large devices (laptops/desktops)
- min-width=1200px: Extra large devices (large laptops and desktops)

https://www.w3schools.com/cssref/css_units.php makes the following recommendations:
- Use relative lengths (em, %, rem, vw, vh) for screen display.
- Use absolute lengths (cm, px, pt) for print display.
- Pixels (px) are only literal pixels for low-dpi devices. For high-dpi
  devices, 1px is multiple physical pixels.
  The ratio of physical to logical pixels can be retrieved in JavaScript with
  window.devicePixelRatio;
- Here it defines: 1in = 2.54cm = 25.4mm = 72pt = 6pc = 96px

https://stackoverflow.com/questions/8785643/what-exactly-is-device-pixel-ratio describes the direct use of device-pixel-ratio in CSS:
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	only screen and (min--moz-device-pixel-ratio: 1.5),
	only screen and (-o-device-pixel-ratio: 3/2),
	only screen and (min-device-pixel-ratio: 1.5) {
	... high-resolution screens ...
}

Also, disable automatic text-sizing, because that determines the font-size
for each block independently.
*/
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	only screen and (min--moz-device-pixel-ratio: 1.5),
	only screen and (-o-device-pixel-ratio: 3/2),
	only screen and (min-device-pixel-ratio: 1.5) {
	/* high-resolution screens */
	:root, body, input, textarea, button {
		/* Make text bigger, because otherwise it gets too small on
		   phones. (I'm not sure why, because 12pt should be the same
		   absolute size on every screen. */
		font-size: 18pt;
	}
	html {
		text-size-adjust: none;
		-moz-text-size-adjust: none;
		-webkit-text-size-adjust: none;
	}
	input[type=checkbox] {
		/* For mobile, make checkboxes bigger with more padding for fat fingers. */
		transform: scale(2);
		margin: 0.7em;
		position: relative; left: -0.5em;
	}
}

:root, body {
	color: var(--accent-color); background: var(--background);
}
::selection {
	color: var(--selection-foreground); background: var(--selection-background);
}

.section {
	display: block;
}

.block {
	display: inline-block;
	vertical-align: top;
	border: .15em solid var(--block-border);
	border-radius: .5em;
	padding: 1em;
	margin: .5em;
	color: var(--block-foreground); background: var(--block-background);
}
.items {
	margin-left: 2em;
}
.block-items {  /* First indentatiion level in a block */
	margin-left: 0.5em;
}

/* Note: On Firefox, if all collapsing/expanding animations do not take the
 * same amount of time, it becomes jerky. Therefore, use the same amount of
 * time and arrange different animation speeds with the @keyframes. */

.block .resize-icon {
	float: right;
	position: relative;
	top: -0.9em; right: -0.6em;
	cursor: pointer;
	color: var(--disabled-color);
	transform: rotate(90deg);
}
.block.collapsing .resize-icon {
	animation: 400ms ease animate-resize-icon;
}
.block.expanding .resize-icon {
	animation: 400ms ease reverse animate-resize-icon;
}
.block.collapsed .resize-icon {
	color: var(--block-foreground);
	transform: rotate(0deg);
}
@keyframes animate-resize-icon {
	0%, 30% {
		color: var(--disabled-color);
		transform: rotate(90deg);
	}
	70%, 100% {
		color: var(--block-foreground);
		transform: rotate(0deg);
	}
}

.block .slider-container {
	/* As described in https://keithjgrant.com/posts/2023/04/transitioning-to-height-auto/,
	 * animating height to height:auto is not always possible, e.g. on Firefox. A solution
	 * is to animate grid-template-rows and add an extra intermediate <div>. */
	display: grid;
	grid-template-rows: 1fr;
	grid-template-columns: 1fr;
}
.slider-container .items {
	overflow: hidden;
	white-space: nowrap;
}
.block.collapsing .slider-container {
	animation:
		400ms ease-out reverse block-expanding-x,
		400ms ease-out reverse block-expanding-y;
}
.block.expanding .slider-container {
	animation:
		400ms ease-out block-expanding-x,
		400ms ease-out block-expanding-y;
}
.block.collapsed .slider-container {
	grid-template-rows: 0fr;
	grid-template-columns: 0fr;
}
@keyframes block-expanding-x {
	0% {
		grid-template-columns: 0fr;
	}
	60%, 100% {
		grid-template-columns: 1fr;
	}
}
@keyframes block-expanding-y {
	0%, 20% {
		transform: scaleY(0);
		transform-origin: top;
		grid-template-rows: 0fr;
	}
	100% {
		transform: scaleY(1);
		transform-origin: top;
		grid-template-rows: 1fr;
	}
}

.item {
	display: block;
	padding: 0.1em;
}
.group .item {
	display: inline;
	margin-left: 0.4em;
}
.group .item:first-child {
	margin-left: unset;
}

.todo-checkbox {
	margin-right: 0.2em;
}
.todo-checkbox:checked {
}
.checkbox-label {
}
.checkbox-label.checked {
	color: var(--disabled-color);
	text-decoration: line-through;
}
.item .icon {
	width: 1.0em; height: 1.0em;
	margin-right: 0.2em;
	vertical-align: -10%;
}
.item .link .icon {
	vertical-align: -20%;
}
.item .separator {
	margin: 0em -1em 0em -1em;
}

.text-icon {
	display: inline-block;
	padding: 0em;
	text-decoration: none;
}
.text-icon div {
	position: absolute;
	margin: 0em; padding: 0em;
	transform-origin: 0 0;
}

.search-form .box {
	font-size: 110%;
}
.search-form .button {
	margin: 0.3em;
}
.search-form .button .icon {
	width: 1.5em; height: 1.5em;
	vertical-align: -25%;
}
.search-form .button .label {
	margin: 0em 0.3em;
}
.blink {
	animation: 500ms 4 blinker;
	color: rgb(0, 0, 0, 0);  /* transparent (also placeholder) */
}
.blink::placeholder {
	opacity: 1;  /* in case browser has this lower by default */
}
@keyframes blinker {
	30% {
		border: .15em solid red;
		background: #FFCCCC;
		color: rgb(0, 0, 0, 1);  /* fully visible (also placeholder) */
	}
}

#SettingsIcon {
	position: absolute;
	top: 10px; right: 10px;
	font-size: 200%;
	cursor: pointer;
}
#SettingsContainer {
	width: 95%;
}
#SettingsText {
	width: 100%;
	height: 47em;
	resize: both;
	overflow: scroll;
	color: var(--foreground); background: var(--background);
	font-family: monospace;
}
.button-bar {
	text-align: right;
}
#SettingsPanel {
	display: none;
	height: 50em;
}
#SettingsPanel.show {
	display: block;
}
#SettingsPanel.slide-in {
	animation: 700ms ease settings-panel-slider;
}
#SettingsPanel.slide-out {
	animation: 700ms ease reverse settings-panel-slider;
}
@keyframes settings-panel-slider {
	0% {
		transform: scaleY(0);
		transform-origin: top;
		height: 0em;
	}
	100% {
		transform: scaleY(1);
		transform-origin: top;
		height: 50em;
	}
}

/* The following .text-block items are the same between all pages */
.text-block {
	color: var(--foreground); background: var(--background);
}
.text-block h1, .text-block h2, .text-block h3, .text-block dt {
	color: var(--accent-color);
}
.text-block code, .text-block pre {
	color: var(--code-foreground); background: var(--code-background);
	padding: 0.1em 0.4em;
}
.text-block dt {
	display: inline;
}
.text-block a {
	color: var(--link-color);
	text-decoration: none;
}
.text-block a:hover {
	text-decoration: underline;
}

/* }}} */
</style>

<script>
// Some constants {{{

const UNICODE_ANGRY_FACE = '\u{1F620}';  //angry face
const UNICODE_POUTING_FACE = '\u{1F621}';  //red angry face
const UNICODE_FACE_WITH_LOOK_OF_TRIUMPH = '\u{1F624}';  //steamy nose angry face
const UNICODE_SERIOUS_FACE_WITH_SYMBOLS_COVERING_MOUTH = '\u{1F92C}';  //red swearing face
const UNICODE_BLACK_DOWN_POINTING_TRIANGLE = '\u{25BC}';
const UNICODE_BLACK_RIGHT_POINTING_TRIANGLE = '\u{25B6}';
const UNICODE_GEARS = '\u{2699}';  //gears wheel

const DefaultLinks = `
// See also example-links.txt

!title Example Favorites

!text
<a name="description"></a>
<h2>Description</h2>

<p>
<a href="favorites.html">favorites.html</a> is a single page that can be
configured to show links and todo lists, organized in sections and blocks. This
configuration can be downloaded via a URL and/or edited in the browser's
LocalStorage.
</p>


<a name="usage"></a>
<h2>Usage</h2>

<p>
The standard usage is to open the page favorites.html (or possibly set it as
your homepage). Upon first opening, it shows a default example page.  This
page can be edited by going to the Settings (Gears (&#x2699;) icon) and just
edit and save the textual configuration. It might be a good idea to maintain a
text file with the configuration and copy-paste it into the Settings.<br>
favorites.html can also be opened and used directly from <a
href="https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html">GitHub</a>.
</p>

<p>
See <a href="help.html#usage">Help</a> for more information on how to use a
separate URL to retrieve the configuration.
</p>


<a name="syntax"></a>
<h2>Configuration Syntax</h2>

<p>
The configuration consists primarily of a list of <a
href="help.html#link-syntax">Link Definitions</a>.  The Links form an
hierarchical structure, indicated by the line's indentation:
<ul>
<li><dt>Section</dt>: The first indentation level is the Section. Sections are
    separated by horizontal lines.
<li><dt>Block</dt>: The second indentation level are the blocks within a
    Section. Each Block is a visual area that can be collapsed and expanded.
<li><dt>Item</dt>: The third indentation level are the Items that populate
    the Blocks.
<li><dt>SubItem</dt>: The fourth and higher indentation levels are SubItems
    that are displayed under their respective parent Items
</ul>
Each link can be a hyperlink, have an icon and/or a checkbox.
</p>

<p>
In addition to Links, the configuration also supports comments, different
web-search functions and other directives, see <a
href="help.html#line-syntax">Line Syntax</a> for further details.
</p>
!endtext

Section
    Block
        Item
            SubItem
                SubSubItem
                SubSubItem
                    ...
            SubItem
        Item
            SubItem
Examples
    Search
        DuckDuckGo https://duckduckgo.com
        Google Maps icon=alt https://maps.google.com
        Wikipedia https://www.wikipedia.org
        YouTube https://www.youtube.com
    Source
        GitHub favorite-links https://github.com/anne-gert/favorite-links
        & Direct icon=none https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html
        Example Links icon=github https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html&links=url:example-links.txt
    To Do
        Shopping
            [ ] Books
            [x] Presents
        At work
            [x] icon=firefox Install Firefox https://www.mozilla.org/firefox/download
            [ ] icon=github Start using favorite-links as todo-list
            []  icon=empty Write review
                & Goto Blog icon=none url=#
    Socials
        Facebook https://www.facebook.com
            Instagram https://www.instagram.com/
            WhatsApp Web https://web.whatsapp.com/
        ---
        LinkedIn https://www.linkedin.com/

// Icon definitions
!icondef firefox    https://www.mozilla.org/media/img/favicons/firefox/browser/favicon.ico
!icondef github     https://github.com

// Search button definitions
//      Identifier   | Label  | Tooltip | Icon
!search Duck Duck Go | Search |
!search Wikipedia
!search YouTube
!search Google Maps  | Maps   |         | alt
`;

const KeyLinks = 'links';

// }}}

// Loading Links {{{

// This function returns a Promise to set the Links content. It is intended to
// be called as soon as possible, so that a download may start.
// When the page is ready to use the result, it can wait for the Promise and
// use it.
//
// The contents of Links can be obtained in the following way:
// 1) If the links-override= query string is set on the URL, that contents is
//    used. This can also be a url:xxx value.
// 2) Otherwise if there is a 'links' key in LocalStorage, that value is used.
// 3) Otherwise if the links= query string is set on the URL, that contents is
//    used. This can also be a url:xxx value.
// 4) If Links matches 'url:<url>', the contents of that URL is downloaded and
//    evaluated as script. It should set the Links variable.
// 5) If Links is empty at this point, use a default contents.
// 6) Links should now have a value that can be parsed as specified below.
function resolveLinks() {
	var links = null;

	var params = new URLSearchParams(location.search);
	//console.log(params);

	// Step 1) Check if links-override is defined in the query string
	if (links == null) {
		var v = params.get('links-override');
		if (v) {
			// Use this URL argument for links
			console.log('Use links-override= URL argument');
			links = v;
		}
	}

	// Step 2) Check if links is defined in LocalStorage
	if (links == null) {
		var v = readLocalLinks();
		if (v !== false) {
			// LocalStorage is available, use persistent value
			console.log('Use links from the LocalStorage');
			links = v;
		}
	}

	// Step 3) Check if links is defined in the query string
	if (links == null) {
		var v = params.get('links');
		if (v) {
			// Use this URL argument for links
			console.log('Use links= URL argument');
			links = v;
		}
	}

	// Step 4) If links is a URL, resolve it
	if (links != null) {
		var matchTargetUrl = links.match(/^\s*url\s*:\s*((https?:\/\/)?(.*?))\s*$/i);
		//console.log(matchTargetUrl);
		// Captured:
		// 1: url
		// 2: protocol
		// 3: domain + path + rest
		if (matchTargetUrl) {
			// links is a URL
			var url = matchTargetUrl[1];
			if (!matchTargetUrl[2]) {
				// URL is relative, check if we need to adjust it
				var matchBaseUrl = window.location.href.match(/^([^\/]*?:\/\/)([^\/]*\bhtml-?preview\.github\.[^\/]*)([^?#]*)/i);
				//console.log(matchBaseUrl);
				// Captured:
				// 1: protocol
				// 2: host ('html-preview.github.io')
				// 3: path without query string or fragment
				if (matchBaseUrl) {
					// The current URL is html-preview.github.io (or similar)
					// This should have a url= parameter that contains the real location
					var referredUrl = params.get('url');
					//console.log(referredUrl);
					var matchReferredUrl = referredUrl.match(/^([^\/]*:\/\/)([^\/]*\bgithub\.[^\/]*)([^?#]*)/i);
					//console.log(matchReferredUrl);
					// Captured:
					// 1: protocol
					// 2: host ('github.com')
					// 3: path without query string or fragment
					if (matchReferredUrl) {
						// The referred URL is on github.com

						// We are now in a situation where this page is hosted
						// on GitHub and links tries to point to a file on
						// there as well.
						// If you have a normal link to github.com, you get the
						// file inside the environment. If you use
						// raw.githubusercontent.com, you get the content of the
						// file, but with Content-Type=text/plain. When
						// html-preview.github.io is used, it uses
						// raw-githubcontent.com and serves it with
						// Content-Type=text/html.
						console.log('Fix links= relative URL for GitHub');
						// To make this relative link work, it should be grafted
						// onto githubusercontent.
						var matchReferredPath = matchReferredUrl[3].match(/(.*?)([^\/]*)$/);
						//console.log(matchReferredPath);
						// Captured:
						// 1: directory
						// 2: filename (everything after last '/')
						url = matchReferredUrl[1] + 'raw.githubusercontent.com' + matchReferredPath[1] + matchTargetUrl[3];
					}
				}
			}

			// Retrieve the url
			console.log('Links defined by URL \'' + url + '\'');
			links = new Promise((resolveFunc, rejectFunc) => {
				var xhr = new XMLHttpRequest();
				xhr.open('GET', url);
				xhr.onreadystatechange = function() {
					if (this.readyState == 4) {
						// Request has been handled
						if (this.status == 200) {
							// Success
							console.log('Loaded links successfully');
							resolveFunc(xhr.responseText);
						} else {
							// Failed
							console.log('Failed to load links, use standard example links');
							resolveFunc(DefaultLinks);
						}
					}
				};
				xhr.send();  //send the request
			});
		} else {
			// Links is not a URL
			links = Promise.resolve(links);  //make it into a Promise
		}
	}

	// Step 5) If links is still empty, use a default contents.
	if (links == null) {
		console.log('Use standard example links');
		links = Promise.resolve(DefaultLinks);
	}

	// Step 6) Now links can be parsed when init() is called.
	return links;  //return the Promise for later consumption
}

// Start resolving the links here.
var LinksPromise = resolveLinks();

// Read links settings from LocalStorage.
// Return links or false in case of error or if it does not exist.
function readLocalLinks() {
	if (localStorage) {
		var v = localStorage.getItem(KeyLinks);
		if (v) return v;
	}
	return false;
}

// Store links in LocalStorage.
// If value is null, empty or whitespace, delete value from LocalStorage.
// Return true if success, false if not saved.
function writeLocalLinks(value) {
	if (localStorage) {
		if (value == null || value.match(/^\s*$/))
			localStorage.removeItem(KeyLinks);
		else
			localStorage.setItem(KeyLinks, value);
		return true;
	}
	return false;
}
// }}}

// Parsing Links {{{

// Global variables in which parseLinks() puts its output.
var Links = null;  //links text, input for parseLinks()
var PageTitle = null;  //specified title
var SearchButtonDefs = null;  //specified search button declarations
var RootLinks = null;  //array of Link objects that have no parents (i.e. are roots)
var IconDefs = null;  //specified icondef declarations


// Parse the string in Links and fills the global variables above.
function parseLinks() {
	// Parse the input lines
	var allLinks = [];  //specified Link objects
	PageTitle = null;
	SearchButtonDefs = [];
	RootLinks = [];
	IconDefs = {};
	var block = null;  //used for literal !text ... !endtext blocks
	var openParents = [];  //currently open parents: 0 is root, 1 its child, etc
	var openParentIndentSpaces = [];  //indentation level (number of spaces) for each open parent
	var lines = Links.split(/\r?\n\r?/);  //lines with Link specifications
	for (var i = 0; i < lines.length; ++i) {
		var line = lines[i];
		//console.log('Line=\'' + line + '\'');

		// If we're in a !text block, add this line to the block
		if (block != null) {
			// We're in a !text block
			// Check if it is the end of a literal !text block
			var m = line.match(/^\s*!endtext\s*$/i);
			if (m) {
				// It is the end, save the object and reset block.
				// Add this object without changing the indent or parents.
				RootLinks.push(block);
				allLinks.push(block);
				block = null;
				continue;
			}
			// Otherwise add this line too
			block.lines.push(line);
			continue;
		}

		// Remove vim folding markers at the end of lines
		line = line.replace(/\s*(?:{{{|}}})\s*$/, '');

		// Skip empty lines
		if (line.match(/^\s*(?:\/\/|#|;|$)/))
			continue;

		// Check if it is a title definition
		var m = line.match(/^\s*!title\s+(.+?)\s*$/i);
		if (m) {
			// This is an title
			PageTitle = m[1];  //save string
			continue;
		}

		// Check if it is an icon definition
		var m = line.match(/^\s*!icondef\s+(\S+)(?:\s+|\s*=\s*)(\S+)\s*$/i);
		if (m) {
			// This is an icondef
			IconDefs[m[1]] = m[2];  //save mapping
			continue;
		}

		// Check if it is a search button definition
		var m = line.match(/^\s*!search\s+(.+?)\s*$/i);
		if (m) {
			// This is a search button definition
			var def = m[1].split(/\s*\|\s*/);  //split fields on '|', allowing whitespace
			SearchButtonDefs.push(def);  //save button def
			continue;
		}

		// Check if it is the start of a literal !text block
		var m = line.match(/^\s*!text\s*$/i);
		if (m) {
			// Mark the start of a !text block
			block = {  //special type of Link object
				'lineNum' : i,  //start of this !text block
				'type': 'text',
				'lines' : [],
				'toString' : function() { return '{ !text, #Lines=' + this.lines.length + ' }' },
			};
			continue;
		}

		// Take out indentation
		var indent = 0;
		var m = line.match(/^(\s+)(.*)$/);
		if (m) {
			indent = m[1].replaceAll('\t', '        ').length;
			line = m[2];  //the rest
		}
		// Take out continucation: & ...
		var cont = false;
		var m = line.match(/^&\s*(.*)$/);
		if (m) {
			cont = true;
			line = m[1];  //the rest
		}
		// Take out Icon: /icon=non-whitespace/
		var icon = null;
		var m = line.match(/^(.*)(?:\s|^)icon=(\S*)(.*)$/i);
		if (m) {
			icon = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out Check: start with '[ ]' '[]' or '[x]'
		var check = null;
		var m = line.match(/^(\s*)(?:(\[ ?\])|(\[x\]))(.*)$/i);
		if (m) {
			if (m[2]) check = false;
			if (m[3]) check = true;
			line = m[1] + m[4];  //the rest
		}
		// Take out Target: /target=non-whitespace/
		var target = null;
		var m = line.match(/^(.*)(?:\s|^)target=(\S*)(.*)$/i);
		if (m) {
			target = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out URL: /url=non-whitespace/ or last /schema:non-whitespace/
		var url = null;
		var m = line.match(/^(.*)(?:\s|^)url=(\S*)(.*)$/i);
		if (!m)
			m = line.match(/^(.*)(?:\s|^)([-+a-zA-Z]{2,}:\S+)(.*)$/);
		if (m) {
			url = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out Name: what remains without leading&trailing whitespae
		var name = line.trim();

		// Handle special items
		if (name.match(/^---+$/)) {  //name with 3 or more '-'
			// This is a separator
			name = '---';  //standardize to 3 '-'
			var minLevel = 2;  //item level
			if (openParentIndentSpaces.length <= minLevel) {
				continue;  //no open parent at this level yet, skip this item
			} else {
				if (indent < openParentIndentSpaces[minLevel]) {
					// Separator has lower indent than level 2, pretend it's
					// at the same level as the line before
					indent = openParentIndentSpaces[openParentIndentSpaces.length - 1];
				}
			}
		}

		// Create the Link object
		var link = {
			'lineNum': i,
			'type': 'link',
			'name' : name,
			'url' : url,
			'icon' : icon,
			'check' : check,
			'target' : target,
			'cont' : [],
			'subs' : [],
			'toString' : function() { return '{ Name=\'' + this.name + '\', URL=' + this.url + ', Icon=' + this.icon + ', check=' + check + ', #SubItems=' + this.subs.length + ' }' },
		};
		//console.log('Indentation=' + indent + ', Link=' + link);

		if (cont) {
			// This link is a continuation of the previous link
			// Ignore the indentation and add it to the last parent
			var level = openParents.length - 1;
			openParents[level].cont.push(link);
			// Do not add this link as a possible parent itself
		} else {
			// Find parent level with indentation strictly less
			for (var level = openParentIndentSpaces.length - 1; level >= 0 && openParentIndentSpaces[level] >= indent; --level) {}
			// Remove all open parents after that
			openParentIndentSpaces.length = level + 1;
			openParents.length = level + 1;
			// Add this link to the parent's children
			if (level >= 0) {
				// It has a parent
				openParents[level].subs.push(link);
			} else {
				// It has no parent
				RootLinks.push(link);
			}
			// Add this link as open parent
			openParentIndentSpaces.push(indent);
			openParents.push(link);
		}

		// Add this Link
		allLinks.push(link);
	}

	// Log all links
	//for (var i = 0; i < allLinks.length; ++i) console.log('Link=' + allLinks[i]);
	// Log all roots
	//for (var i = 0; i < RootLinks.length; ++i) console.log('RootLink=' + RootLinks[i]);
}

// }}}

// Rendering Links {{{

// Output Link {{{

// Render Link object, including its children to the container at specified level.
// Level 1 is called Section and is rendered with a heading.
// Level 2 is called Block and is rendered as a rectangular block.
// Level 3 is called Item and is rendered as a line in a Block.
// Level 4 and higher are called sub-Items and are rendered as indented Items.
function outputItem(link, level, container, parentPath) {
	//console.log('outputItem ' + link.toString());
	// Copy input data
	var name = link.name;
	var url = link.url;
	var icon = link.icon;
	var check = link.check;
	var target = link.target;
	var tooltip = null;
	var contItems = link.cont;
	if (contItems != null && contItems.length == 0) contItems = null;
	var subItems = link.subs;
	if (subItems != null && subItems.length == 0) subItems = null;
	if (name == '') name = null;
	if (url == '') url = null;
	if (icon == '') icon = null;
	if (target == '') target = null;
	var myPath = parentPath + '->' + name;
	// Fill in defaults for missing elements
	if (name == null) {
		if (url != null) {
			name = url;  //name defaults to url
		} else {
			name = 'LINK';  //default name
		}
	}
	// Change URL if target=manual
	if (target == 'manual') {
		var msg = 'Due to security reasons, this URL cannot be opened automatically.\nCopied URL \'' + url + '\' to clipboard.\n\nManually paste this to the address bar.';
		msg = msg.replaceAll('\'', '\\\'').replaceAll('\n', '\\n');
		tooltip = url;  //preserve original URL
		url = 'javascript:navigator.clipboard.writeText(\'' + url + '\');alert(\'' + encodeURI(msg) + '\');void(0)';
		target = null;
	}
	// Render the item
	// State variables for this item; will be used in closures
	var addItemContainer;  //function to add a container to put the Item into
	var addSubContainer;  //function to add a container to put the subItems into
	var addClosingElements = null;  //function to add closing elements to the container
	// Create element container
	if (level == 1) (function(){  //define function to have a separate variable scope
		// Render Item as Section
		//console.log('Render Section ' + name);
		var _itemContainer;
		var _subContainer;
		addItemContainer = function() {
			_itemContainer = document.createElement('h2');
			container.appendChild(_itemContainer);
			return _itemContainer;
		}
		addSubContainer = function() {
			_subContainer = document.createElement('div');
			_subContainer.className = 'section';
			container.appendChild(_subContainer);
			return _subContainer;
		};
		addClosingElements = function() {
			var closingElements = document.createElement('hr');
			container.appendChild(closingElements);
		}
	})();
	else if (level == 2) (function(){  //define function to have a separate variable scope
		// Render Item as Block
		//console.log('Render Block ' + name);
		var _itemContainer;
		var _subContainer;
		addItemContainer = function() {
			_itemContainer = document.createElement('div');
			_itemContainer.className = 'block';
			container.appendChild(_itemContainer);
			if (subItems != null) {
				var expandIcon = document.createElement('span');  //container to display '-' or '+'
				expandIcon.className = 'resize-icon';
				expandIcon.textContent = UNICODE_BLACK_RIGHT_POINTING_TRIANGLE;
				_itemContainer.appendChild(expandIcon);
				var isExpanded = true;  //true if block is expanded
				var storageKey = 'expanded ' + myPath;
				if (localStorage) {
					// LocalStorage is available, use persistent value
					var v = localStorage.getItem(storageKey);
					console.log('Preset isExpanded for \'' + myPath + '\' to ' + v);
					if (v == 'false')
						isExpanded = false;
				}
				var displayExpandState = function() {
					console.log('Display isExpanded for \'' + myPath + '\' as ' + isExpanded);
					if (isExpanded) {
						// Expand this block
						_itemContainer.classList.add('expanding');
						_itemContainer.onanimationend = function() {
							_itemContainer.classList.remove('collapsed');
							_itemContainer.classList.remove('expanding');
						};
					} else {
						// Collapse this block
						_itemContainer.classList.add('collapsing');
						_itemContainer.onanimationend = function() {
							_itemContainer.classList.add('collapsed');
							_itemContainer.classList.remove('collapsing');
						};
					}
				};
				expandIcon.onclick = function() {
					isExpanded = !isExpanded;
					console.log('Set isExpanded for \'' + name + '\' to ' + isExpanded);
					if (localStorage) {
						// LocalStorage is available, persist it
						localStorage.setItem(storageKey, isExpanded);
					}
					displayExpandState();
				};
				addClosingElements = function() {
					// Display the initial state
					//displayExpandState();  //display initial state
					if (!isExpanded) {
						_itemContainer.classList.add('collapsed');
					}
				}
			}
			return _itemContainer;
		}
		addSubContainer = function() {
			_subContainer = document.createElement('div');
			_subContainer.className = 'items block-items';
			var sliderContainer = document.createElement('div');
			sliderContainer.className = 'slider-container';
			sliderContainer.appendChild(_subContainer);
			_itemContainer.appendChild(sliderContainer);
			return _subContainer;
		}
	})();
	else (function(){  //define function to have a separate variable scope
		// Render Item is (sub-)Item
		//console.log('Render Item ' + name);
		var _itemContainer;
		var _subContainer;
		addItemContainer = function() {
			var groupContainer;
			if (contItems != null) {
				groupContainer = document.createElement('div');  //make a div for the continuation group
				groupContainer.className = 'group';
				container.appendChild(groupContainer);
			} else {
				groupContainer = container;  //there is no group, use same container
			}
			_itemContainer = document.createElement('div');
			_itemContainer.className = 'item';
			groupContainer.appendChild(_itemContainer);
			return _itemContainer;
		}
		addSubContainer = function() {
			_subContainer = document.createElement('div');
			_subContainer.className = 'items';
			container.appendChild(_subContainer);
			return _subContainer;
		}
	})();
	// Create element itself
	if (name == '---') {
		// Special separator item
		var item = document.createElement('hr');
		item.className = 'separator';
		container.appendChild(item);
	} else {
		var itemContainer = addItemContainer();
		// Create textContainer to hold the name/label
		var textContainer = null;
		var setTextClass = function(className, add) {
			if (textContainer != null) {
				if (add)
					textContainer.classList.add(className);
				else
					textContainer.classList.remove(className);
			}
		};
		if (name != null) {
			if (icon_present && name == '_') {
				// Do not display the text
			} else {
				textContainer = document.createElement('span');
				textContainer.appendChild(document.createTextNode(name));
				if (check != null) {
					// This is a checkbox item, give the name the correct class
					textContainer.className = 'checkbox-label';
				} else {
					textContainer.className = 'link-name';
				}
			}
		}
		// Create and add checkbox in Item container
		if (check != null) {
			// Render a checkbox
			var checkbox = document.createElement('input');
			checkbox.type = 'checkbox';
			checkbox.className = 'todo-checkbox';
			checkbox.onchange = function() {
				var re = new RegExp('(^(?:[^\\n]*\\n){' + link.lineNum + '}\\s*)\\[.?\\]');
				var newCheck;
				if (checkbox.checked) {
					// Change checkbox to checked
					console.log('Check checkbox on line ' + link.lineNum);
					newCheck = '[x]';
				} else {
					// Change checkbox to checked
					console.log('Uncheck checkbox on line ' + link.lineNum);
					newCheck = '[ ]';
				}
				Links = Links.replace(re, '$1' + newCheck);
				writeLocalLinks(Links);
				setTextClass('checked', checkbox.checked);
			};
			if (check === true) {
				checkbox.checked = true;
				setTextClass('checked', true);
			} else if (check === false) {
				checkbox.checked = false;
				setTextClass('checked', false);
			}
			itemContainer.appendChild(checkbox);
		}
		// Create hyperlink in Item container
		var linkContainer;  //this container holds the link
		if (url != null) {
			linkContainer = document.createElement('a');
			linkContainer.href = url;
			linkContainer.className = 'link';
			if (target != null)
				linkContainer.target = target;
			if (tooltip != null)
				linkContainer.title = tooltip;
			itemContainer.appendChild(linkContainer);
		} else {
			linkContainer = itemContainer;  //there is no separate link
		}

		// Create and add icon
		var icon_present = outputIcon(linkContainer, null, icon, url);
		// Add textContainer
		if (textContainer != null)
			linkContainer.appendChild(textContainer);
		// If there is continuation, output those items in this container too
		if (contItems != null) {
			outputItems(contItems, level, itemContainer, myPath);
		}
	}
	// Create sub-Items in container
	if (subItems != null) {
		if (addSubContainer) {
			var subContainer = addSubContainer();
			outputItems(subItems, level+1, subContainer, myPath);
		}
	}
	// Add closing elements
	if (addClosingElements) {
		addClosingElements();
	}
}

// Output a <div> element as next child of the container.
function outputText(lines, container) {
	var html = lines.join('\n');
	var div = document.createElement('div');
	div.className = 'text-block';
	div.innerHTML = html;
	container.appendChild(div);
}

// Render array of Links to the container at specified level.
function outputItems(links, level, container, parentPath = '') {
	for (var i = 0; i < links.length; ++i) {
		var link = links[i];
		if (link.type == 'link') {
			outputItem(link, level, container, parentPath);
		} else if (link.type == 'text') {
			outputText(link.lines, container);
		}
	}
}

// }}}

// Output Icon {{{

// Create <img> item in the container.
// If alt_text is defined, use that.
// icon_url is what is specified in the icon=URL argument, see explanation at
// the top of this file.
// Returns true if a non-empty icon is generated.
//
// To retrieve the icon, first try the primary URL. If that fails and skip_alternatives==false,
// try these alternatives:
// - http://www.google.com/s2/favicons?domain=<target_url domain>
// - http://www.google.com/s2/favicons?domain=<icon_url domain>
function outputIcon(container, alt_text, icon_url, target_url, skip_alternatives = false) {
	// By default, construct icon_url from target_url
	if ((icon_url == null || icon_url == 'default') && target_url != null) {
		icon_url = getDefaultIconUrl(target_url);
	}

	// Resolve the IconDefs
	if (icon_url != null) {
		icon_url = resolveIconDefs(icon_url);
	}

	var icon_present = false;

	// Render icon_url
	var m;  //for regex matches
	if (icon_url == null) {
		console.log('Loading icon for target \'' + target_url + '\': null');
	} else if (icon_url == 'none') {
		console.log('Loading icon for target \'' + target_url + '\': \'' + icon_url + '\'');
	} else if (m = icon_url.match(/^html:(.+)/i)) {
		var html = m[1];
		// Create a 'data:...' pseudo URL that holds the data as SVG and put this text in a text node.
		var iconDiv = document.createElement('div');
		iconDiv.className = 'icon text-icon';
		var htmlDiv = document.createElement('div');
		htmlDiv.innerHTML = html;  //also takes care of HTML rendering
		FillScaler.observe(htmlDiv);
		iconDiv.appendChild(htmlDiv);
		container.appendChild(iconDiv);
		icon_present = true;
	} else {
		console.log('Loading icon for target \'' + target_url + '\': \'' + icon_url + '\'');
		var img = document.createElement('img');
		icon_present = true;
		if (icon_url == 'empty') {
			img.style.visibility = 'hidden';
			icon_present = false;  //there is an image, but still empty
		} else if (m = icon_url.match(/^char:(.+)/i)) {
			var text = m[1];
			// Create a 'data:...' pseudo URL that holds the data as SVG and put this text in a text node.
			icon_url = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">' + text + '</text></svg>';
			img.src = icon_url;
		} else {
			var alternatives = [], methods = [], urls = [];  //prepare options to use for the icon
			if (m = icon_url.match(/^alt(?::([^?]+))?(?:\?(.+))?/i)) {
				// icon_url contains an alt specification
				var method = m[1];
				var url = m[2];
				if (method == null || method == '' || method == 'any' || method == '*') {
					// Add all known methods
					methods.push('google');
				} else {
					// Add only the specified method
					methods.push(method);
				}
				if (url != null && url != '') {
					// Add the specified URL only
					urls.push(url);
				} else {
					// Add the icon_url (but that doesn't contain a URL) and target_url
					if (target_url != null && target_url != '') {
						urls.push(target_url);
					}
				}
			} else {
				// icon_url contains a URL of the icon
				alternatives.push(icon_url);
				if (!skip_alternatives) {
					// Try the alternatives in order of 'likely correct'.
					// Note that the google-favicons always returns an image, even a generic one, so it
					// will always prevent further alternatives to be attempted.
					methods.push('google');
					if (icon_url != null) {
						urls.push(icon_url);
					}
					if (target_url != null) {
						urls.push(target_url);
					}
				}
			}
			//console.log('All methods for ' + icon_url); console.log(methods);
			//console.log('All urls for ' + icon_url); console.log(urls);
			// Go through methods and urls and add alternatives
			for (var m = 0; m < methods.length; ++m) {
				var method = methods[m];
				for (var u = 0; u < urls.length; ++u) {
					if (method == 'google') {
						alternatives.push(getGoogleAltIconUrl(urls[u]));
					} else {
						console.error('Unknown alt icon method: ' + method);
					}
				}
			}
			//console.log('All alternatives for ' + icon_url); console.log(alternatives);
			// Remove duplicates
			var seen = {};
			var alt_list = alternatives;  //may have duplicates
			alternatives = [];  //get the unique ones
			for (var a = 0; a < alt_list.length; ++a) {
				if (!seen[alt_list[a]]) {
					seen[alt_list[a]] = true;
					alternatives.push(alt_list[a]);
				}
			}
			//console.log('All unique alternatives for ' + icon_url); console.log(alternatives);
			// Set the icon urls until we find one that works
			var try_next = function() {
				if (alternatives.length > 0) {
					// Try next alternative
					//console.log('alternatives.length=' + alternatives.length);
					//console.log('alternatives[0]=' + alternatives[0]);
					var alt = alternatives.shift();
					//console.log('alternatives.length=' + alternatives.length);
					if (img.src != null && img.src != '') {
						console.warn('Cannot load icon \'' + img.src + '\', try \'' + alt + '\'');
					}
					img.src = alt;
				} else {
					// Stop trying
					console.error('Cannot load icon: ' + img.src);
					if (alt_text != null) {
						// prepare to show the alt text
						img.src = '';
					} else {
						// hide entire image
						img.style.visibility = 'hidden';
					}
					img.onerror = null;  //stop handling errors
				}
			}
			img.onerror = try_next;
			try_next();  //set first alternative
		}
		if (alt_text != null) {
			img.alt = alt_text;
		}
		img.className = 'icon';
		container.appendChild(img);
	}

	return icon_present;
}

// Take icon_url and perform the icondef replacements.
// Returns the resolved value or the original value if no icondefs matched.
function resolveIconDefs(icon_url) {
	var retval = icon_url;
	var seen = {};  //to break cycles
	seen[icon_url] = 1;
	var override = IconDefs[icon_url];
	while (override !== undefined && !seen[override]) {
		console.log('Replace icon=' + icon_url + ' by IconDefs ' + override);
		retval = override;
		seen[override] = 1;
		override = IconDefs[override];
	}
	//console.log('Returning ' + retval);
	return retval;
};

// Define a ResizeObserver that is used to resize entries to 100% of their
// parent's size. This is used for icons that are defined with html:<x>.
var FillScaler = new ResizeObserver(function(entries) {
	for (var entry of entries) {
		var element = entry.target;
		// Get entries current size
		var w, h;
		if (entry.borderBoxSize) {
			var rect = entry.borderBoxSize[0];  //area of 1st (and only) fragment
			var writingMode = element.style.writingMode;
			//console.log('FillScaler: Writing mode ' + writingMode);
			if (writingMode.match(/^vertical/i)) {
				// Vertical writing-mode, so inline direction is vertical
				h = rect.inlineSize;
				w = rect.blockSize;
			} else {
				// Assume horizontal writing-mode, so inline direction is horizontal
				w = rect.inlineSize;
				h = rect.blockSize;
			}
		} else {
			var rect = entry.contentRect;
			w = entry.contentRect.width;
			h = entry.contentRect.height;
		}
		console.log('FillScaler: Element size ' + w + ' x ' + h);
		// Get parent's current size
		var parent = element.parentElement;
		var pw = parent.offsetWidth;
		var ph = parent.offsetHeight;
		//console.log('FillScaler: Parent size ' + pw + ' x ' + ph);
		// Calculate new scaling factor
		var scaleX = pw / w;
		var scaleY = ph / h;
		//console.log('FillScaler: Scale with ' + scaleX + ' x ' + scaleY);
		// Check if the change is big enough
		var changeX = element._scaleX / scaleX;
		var changeY = element._scaleY / scaleY;
		//console.log('FillScaler: Scale change ' + changeX + ' x ' + changeY);
		if (isNaN(changeX) || changeX < 0.98 || changeX > 1.02 || isNaN(changeY) || changeY < 0.98 || changeY > 1.02) {
			// More than 2% change
			console.log('FillScaler: Set scale ' + scaleX + ' x ' + scaleY);
			element._scaleX = scaleX;
			element._scaleY = scaleY;
			entry.target.style.scale = scaleX + ' ' + scaleY;
		} else {
			console.log('FillScaler: Scale change too small ' + changeX + ' x ' + changeY);
		}
	}
});

// Return the URL where the default icon should be.
function getDefaultIconUrl(site_url) {
	return site_url.replace(/(?:(?:(?<!\/)\/(?!\/)|\?|#).*)?$/, '/favicon.ico');  //replace first single '/', '?' or '#' and onwards
}

// Return the URL for an icon of the site_url's domain.
// This method uses the Google database.
function getGoogleAltIconUrl(site_url) {
	var domain = site_url
		.replace(/^[^\/]*\/\//, '')  //remove scheme
		.replace(/\/.*/, '');  //remove path
	return 'http://www.google.com/s2/favicons?domain=' + domain;
}

// }}}

// }}}

// SearchBox related functions {{{

// The search functions will be accessed by name (lower case identifier).
// Every identifier has sub-keys for different functions.
// A search function has the search query as input and should return a URL to
// go to for the results.

var SearchFunction = {
	'duck duck go' : {
		'text'   : getTemplateUrl('https://duckduckgo.com?q=%urlinput'),
	},
	'google' : {
		'text'   : getTemplateUrl('https://www.google.com/search?q=%urlinput'),
	},
	'wikipedia' : {
		'text'   : getTemplateUrl('https://www.wikipedia.org/wiki/Special:Search?go=Go&search=%urlinput'),
	},
	'youtube' : {
		'text'   : getTemplateUrl('https://www.youtube.com/results?search_query=%urlinput'),
	},
	'wayback machine' : {
		'text'   : getWaybackSearchUrl,
		'domain' : getWaybackDomainUrl,
	},
	'google maps' : {
		'text'   : getTemplateUrl('https://maps.google.com/?q=%urlinput'),
	},
	'default' : {
		'text'   : getNoUrl,
		'domain' : getWithSchemaUrl,
	},
};

// Return a URL to handle the address (ie beautify it to go to it).
function getWithSchemaUrl(address) {
	var url = address;
	if (!url.match(/^[\w+-]+:/)) {
		url = 'http://' + url;  //add default scheme
	}
	return url;
}

// This is a dummy search function, that can be used as a default.
function getNoUrl(intput) {
	return null;
}

// This function returns a functions that uses the template to construct a URL.
// The template is a URL with the following placeholders:
// - %input: Replaced with the supplied input value.
// - %urlinput: Replaced with the URL-encoded input value.
function getTemplateUrl(template) {
	return function(input) {
		var encoded_input = encodeURIComponent(input).replace(' ', '+');
		return template
			.replace('%input', input)
			.replace('%urlinput', encoded_input);
	};
}

// Returns a URL to perform a lookup for the domain with Wayback Machine.
function getWaybackDomainUrl(domain) {
	var ts = getWaybackTimestamp();
	return 'https://web.archive.org/web/' + ts + '/' + domain;
};

// Returns a URL to perform a search for input with Wayback Machine.
function getWaybackSearchUrl(input) {
	var ts = getWaybackTimestamp();
	var encoded_input = encodeURIComponent(input).replace(' ', '+');
	return 'https://web.archive.org/web/' + ts + '/' + encoded_input;
};

// Create a Wayback Machine timestamp that can be used in queries.
function getWaybackTimestamp(date = new Date()) {
	var pad = function(number, positions) {
		var neg = false;
		if (number < 0) {
			neg = true;
			positions--;  //space for '-'
			number = -number;
		}
		var s = '';
		for (var i = 2, limit = 10; i <= positions; ++i, limit *= 10) {
			if (number < limit) s += '0';
		}
		s += number;
		if (neg) s = '-' + s;
		return s;
	};
	// I assume the format is 'yyyymmddhhmmss*' with yyyy the year
	// to query and the rest '0'.
	var timestamp = pad(date.getFullYear(), 4) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		'*';
	return timestamp;
}

var EmptySearchCounter = 0;

// Process search input.
// Redirects to search.
// May return if search input is not clear.
function processSearchInput(searchBox, getSearchUrl, getDomainSearchUrl = getWithSchemaUrl) {
	var input = searchBox.value;
	if (input.match(/^\s*$/)) {
		console.log('Empty search string');
		// Set the blink anymated style
		searchBox.classList.add('blink');
		//console.log('searchBox.className=' + searchBox.className);
		// Set the funny feedback text with angry faces
		++EmptySearchCounter;
		var funny_feedback;
		if (EmptySearchCounter <= 2)
			funny_feedback = '';
		else if (EmptySearchCounter <= 3)
			funny_feedback = UNICODE_ANGRY_FACE;
		else if (EmptySearchCounter <= 6)
			funny_feedback = UNICODE_POUTING_FACE.repeat(EmptySearchCounter - 3);
		else
			funny_feedback = UNICODE_FACE_WITH_LOOK_OF_TRIUMPH.repeat(EmptySearchCounter - 3);
		searchBox.placeholder = funny_feedback;
		// Set the event to clean up
		searchBox.onanimationend = function() {
			//console.log('animation end');
			searchBox.classList.remove('blink');
			//console.log('searchBox.className=' + searchBox.className);
			searchBox.placeholder = '';  //remove funny feedback
		};
	} else {
		EmptySearchCounter = 0;
		var m = input.match(/^\s*(\S+\.\S+)\s*$/);
		var url = null;
		if (m && getDomainSearchUrl) {
			//console.log('Looks like URL');
			url = getDomainSearchUrl(m[1]);
			console.log('Go to URL \'' + url + '\'');
		} else {
			url = getSearchUrl(input);
			console.log('Search \'' + url + '\'');
		}
		if (url) {
			window.location.href = url;
		} else {
			console.log('No URL to go to');
		}
	}
}

// Create search button to container and set up the event callback.
// This also adds icons to the buttons. Do that here instead of with
// static HTML, because I saw that the browser tries to render static
// images before the JavaScript generated ones and I'd like to render
// the links as soon as possible.
// The displayed icon is specified by icon_url. If this is 'alt', the
// target domain is derived from getSearchUrl().
function addSearchButton(container, search_box, button_id, label_text, tooltip, icon_url, getSearchUrl, getDomainSearchUrl) {
	var btn = document.createElement('button');
	if (btn) {
		// Configure the button
		btn.id = 'BtnSearch' + button_id;
		btn.className = 'button';
		btn.onclick = function() {
			processSearchInput(search_box, getSearchUrl, getDomainSearchUrl);
			return false;  //skip default handling
		}
		btn.title = tooltip;

		// Add icon
		var target_domain = getSearchUrl('dummy');
		//console.log('target_domain=' + target_domain);
		//console.log('favicon=' + getDefaultIconUrl(target_domain));
		// When determining the icon, don't consider alternatives,
		// except when icon_url == 'alt...'
		outputIcon(btn, tooltip, icon_url, target_domain, true);

		// Add link text
		var label = document.createElement('span');
		label.className = 'label';
		var textNode = document.createTextNode(label_text);
		label.appendChild(textNode);
		btn.appendChild(label);

		// Add the button to the container
		container.appendChild(btn);
	}
}

function addSearchButtons(searchBox, container) {
	for (var i = 0; i < SearchButtonDefs.length; ++i) {
		// Get the fields from the definition
		var def = SearchButtonDefs[i];
		var f = 0;

		// Determine Identifier
		var id = def[f++];
		if (!id) continue;  //id is mandatory, ignore this entry if absent
		var key = id.toLowerCase();  //lower case version

		// Determine referenced Search URL Function
		var getSearchUrl = SearchFunction[key]['text'];

		// Determine referenced Domain Search URL Function
		var getDomainSearchUrl = SearchFunction[key]['domain'];

		// Determine Label
		var label = def[f++] || id;

		// Determine Tooltip
		var tooltip = def[f++] || id;

		// Determine Icon
		var icon = def[f++];
		if (!icon) {
			if (getSearchUrl) {
				// Search URL function is defined. This is
				// needed to retrieve the 'default' icon.
				icon = 'default';
			} else {
				// There is no Search URL function, use a
				// standard magnifying glass icon.
				icon = 'html:&#x1F50D;';
			}
		}

		// Determine final Search URL Function
		if (!getSearchUrl) {
			// No Search Function, use default (assume it exists)
			getSearchUrl = SearchFunction['default']['text'];
		}

		// Determine final Domain Search URL Function
		if (!getDomainSearchUrl) {
			// No Search Function, use default (assume it exists)
			getDomainSearchUrl = SearchFunction['default']['domain'];
		}

		// Log the fields
		console.log('addSearchButtons: Identifier=\'' + id + '\'');
		console.log('addSearchButtons: Label=\'' + label + '\'');
		console.log('addSearchButtons: Tooltip=\'' + tooltip + '\'');
		console.log('addSearchButtons: Icon=\'' + icon + '\'');
		console.log('addSearchButtons: getSearchUrl=\'' + getSearchUrl + '\'');
		console.log('addSearchButtons: getDomainSearchUrl=\'' + getDomainSearchUrl + '\'');
		console.log(SearchFunction);

		// Create the button
		addSearchButton(container, searchBox, id, label, tooltip, icon, getSearchUrl, getDomainSearchUrl);
	}
}

// }}}

// Edit Settings {{{

// Set up the events for the settings panel.
function initSettingsPanel() {
	var iconSettings = document.getElementById('SettingsIcon');
	var pnlSettings = document.getElementById('SettingsPanel');
	var txtSettings = document.getElementById('SettingsText');
	var btnSave = document.getElementById('BtnSaveSettings');
	var btnClear = document.getElementById('BtnClearSettings');
	var btnCancel = document.getElementById('BtnCancelSettings');
	var visible = false;
	var showSettings = function() {
		txtSettings.value = Links;
		// Slide to visible
		pnlSettings.classList.add('slide-in');
		pnlSettings.classList.add('show');
		pnlSettings.onanimationend = function() {
			pnlSettings.classList.remove('slide-in');
		};
		visible = true;
	};
	var hideSettings = function(save) {
		if (save) {
			if (save == 'clear') {
				console.log('Clear settings');
				txtSettings.value = '';
				writeLocalLinks(null);  //remove persisted Links
				loadLinks(true);  //re-resolve Links
			} else if (txtSettings.value == '') {
				console.log('Clear settings');
				writeLocalLinks(null);  //remove persistet Links
				loadLinks(true);  //re-resolve Links
			} else {
				console.log('Save settings');
				Links = txtSettings.value;
				writeLocalLinks(Links);
				processLinks();  //Render Links
			}
		}
		// slide to hidden
		pnlSettings.classList.add('slide-out');
		pnlSettings.onanimationend = function() {
			pnlSettings.classList.remove('show');
			pnlSettings.classList.remove('slide-out');
		};
		visible = false;
	};
	if (iconSettings && pnlSettings) {
		iconSettings.onclick = function() {
			if (visible) hideSettings(false); else showSettings();
		};
	}
	if (btnSave) {
		btnSave.onclick = function() {
			if (visible) hideSettings(true);
			return false;  //stop default button action
		};
	}
	if (btnClear) {
		btnClear.onclick = function() {
			if (visible) hideSettings('clear');
			return false;  //stop default button action
		};
	}
	if (btnCancel) {
		btnCancel.onclick = function() {
			if (visible) hideSettings(false);
			return false;  //stop default button action
		};
	}
}

// }}}

// Initialization {{{

// Function to set the title to the specified string.
function setPageTitle(title) {
	var titleCtl = document.getElementById('Title');
	if (titleCtl)
		titleCtl.innerText = title;
}

// From the Links configuration, parse its content and display it.
function processLinks() {
	// Parse Links
	parseLinks();

	// Set page title
	if (PageTitle) {
		setPageTitle(PageTitle);
	}

	// Render links
	var container = document.getElementById('LinksBox');
	container.textContent = '';
	outputItems(RootLinks, 1, container);

	// Fill SearchForm
	// Use a static input field, so that the browser retains its contents
	// after going back to this page.
	if (SearchButtonDefs != null && SearchButtonDefs.length > 0) {
		// There are SearchButtens, fill SearchForm
		console.log('There are ' + SearchButtonDefs.length + ' SearchButtonDefs');
		// Focus SearchBox
		var searchBox = document.getElementById('SearchBox');
		if (searchBox) {
			searchBox.focus();
			searchBox.select();
		}
		// Initialize the search buttons
		var buttonBox = document.getElementById('SearchButtons');
		buttonBox.textContent = '';
		addSearchButtons(searchBox, buttonBox);
	} else {
		// No SearchButtons defined, hide SearchForm
		console.log('There are no SearchButtonDefs');
		var searchForm = document.getElementById('SearchForm');
		if (searchForm) {
			console.log('Hide SearchForm');
			searchForm.style.display = 'none';
		}
	}
}

// Load the Links and render them.
// If reload==true, the Links are completely resolved again and possibly
// reloaded from URLs.
function loadLinks(reload) {
	if (LinksPromise == null || reload) {
		// Resolve links if not already done so
		LinksPromise = resolveLinks();
	}

	LinksPromise.then((value) => {
		// Links have been resolved
		//console.log(value);
		Links = value;

		// Process the Links
		processLinks();
	});
}

// Initialize the JavaScript on the page
function init() {
	initSettingsPanel();
	loadLinks();
}
window.onload = init;

// }}}
</script>

</head>

<body>

<h1 id="Title">Favorites</h1>

<span id="SettingsIcon">&#x2699;</span>

<div id="SettingsPanel">
<form id="SettingsForm">
<div id="SettingsContainer">
<textarea id="SettingsText" wrap="off" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Settings"></textarea>
<div class="button-bar">
<button id="BtnSaveSettings" class="button">Save</button>
<button id="BtnClearSettings" class="button">Clear</button>
<button id="BtnCancelSettings" class="button">Cancel</button>
</div>
</div>
</form>
<hr>
</div>

<form id="SearchForm" class="search-form">
Search:
<input id="SearchBox" name="q" type="text" size="40" class="box"/>
<span id="SearchButtons"></span>
</form>

<div id="LinksBox"></div>

</body>

</html>

<!-- vim: set fdm=marker: -->

