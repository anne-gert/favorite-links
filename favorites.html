<!DOCTYPE html>
<html>

<!--
For description of this file, see README.md
For syntax description of Links, see help.html
-->

<head>

<!-- This page may contain UTF-8 encoded text, especially in the Links definition. -->
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>Favorites</title>

<style>
/* CSS styles {{{ */

/****************************************************************************
 * Global definitions
 ****************************************************************************/

/* Color palette - dark theme */
.dark-theme {
	--foreground: #DDDDDD;
	--background: #2E323B;
	--accent-color: #50A0EE;
	--block-foreground: #000000;
	--block-background: #C9CDD0;
	--block-border: #EEEEEE;
	--selection-foreground: #000000;
	--selection-background: #DDDDFF;
	--code-foreground: var(--foreground);
	--code-background: #282828;
	--link-color: #6666FF;
	--disabled-color: #888888;
	--error-border-color: #FF6600;
	--error-background-color: #FFD8C0;
}

/* Color palette - light theme */
.light-theme {
	--foreground: #444444;
	--background: #D0D8E0;
	--accent-color: #5050CC;
	--block-foreground: #222222;
	--block-background: #D9DDE0;
	--block-border: #666666;
	--selection-foreground: #FFFFFF;
	--selection-background: #000099;
	--code-foreground: var(--foreground);
	--code-background: #C0C0C0;
	--link-color: #2222AA;
	--disabled-color: #888888;
	--error-border-color: #FFBB88;
	--error-background-color: #FFEEDD;
}

:root {
	/* Define variables that will be used on visible elements */
	--font-family: 'Segoe UI', 'Lucida Grande', Helvetica, sans-serif;
	--font-size: 100%
	/* Set default font and size */
	font-family: var(--font-family);
	font-size: 12pt;  /* absolute, so --font-size can be relative too */
}


/****************************************************************************
 * Resizing for mobile devices
 ****************************************************************************/

/*
https://www.w3schools.com/css/css_rwd_mediaqueries.asp advices the following sizes:
- max-width=600px: Extra small devices (phones)
- min-width=600px: Small devices (portrait tablets and large phones)
- min-width=768px: Medium devices (landscape tablets)
- min-width=992px: Large devices (laptops/desktops)
- min-width=1200px: Extra large devices (large laptops and desktops)

https://www.w3schools.com/cssref/css_units.php makes the following recommendations:
- Use relative lengths (em, %, rem, vw, vh) for screen display.
- Use absolute lengths (cm, px, pt) for print display.
- Pixels (px) are only literal pixels for low-dpi devices. For high-dpi
  devices, 1px is multiple physical pixels.
  The ratio of physical to logical pixels can be retrieved in JavaScript with
  window.devicePixelRatio;
- Here it defines: 1in = 2.54cm = 25.4mm = 72pt = 6pc = 96px

https://stackoverflow.com/questions/8785643/what-exactly-is-device-pixel-ratio describes the direct use of device-pixel-ratio in CSS:
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	only screen and (min--moz-device-pixel-ratio: 1.5),
	only screen and (-o-device-pixel-ratio: 3/2),
	only screen and (min-device-pixel-ratio: 1.5) {
	... high-resolution screens ...
}

Also, disable automatic text-sizing, because that determines the font-size
for each block independently.
*/
@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
	only screen and (min--moz-device-pixel-ratio: 1.5),
	only screen and (-o-device-pixel-ratio: 3/2),
	only screen and (min-device-pixel-ratio: 1.5) {
	/* high-resolution screens */
	:root {
		/* Make text bigger, because otherwise it gets too small on
		   phones. (I'm not sure why, because 12pt should be the same
		   absolute size on every screen. */
		font-size: 18pt;
	}
	html {
		text-size-adjust: none;
		-moz-text-size-adjust: none;
		-webkit-text-size-adjust: none;
	}
	input[type=checkbox] {
		/* For mobile, make checkboxes bigger with more padding for fat fingers. */
		transform: scale(2);
		margin: 0.7em;
		position: relative; left: -0.5em;
	}
	/* For some reason, the right-hand side of the items is hidden (if overflow=clip it
	   *is* shown, but then the animation does not work correctly. Also using another
	   unit besides fr makes the animation not work correctly.
	   Since this only happens on mobile (I tested Firefox as well as Chrome on Android),
	   I can force a bit of extra padding on the block-items level.
	   I also tested if the font-adjustment had any influence. It didn't. */
	.block-items {
		padding-right: 1em;
	}
}

body, input, textarea, button {
	font-family: var(--font-family);
	font-size: var(--font-size);
}

body {
	color: var(--accent-color); background: var(--background);
}
::selection {
	color: var(--selection-foreground); background: var(--selection-background);
}


/****************************************************************************
 * Shared styles for displaying text-blocks
 * These syles are shared between all pages
 ****************************************************************************/

.text-block {
	color: var(--foreground); background: var(--background);
}
.text-block h1, .text-block h2, .text-block h3, .text-block dt {
	color: var(--accent-color);
}
.text-block code, .text-block pre {
	color: var(--code-foreground); background: var(--code-background);
	padding: 0.1em 0.4em;
}
.text-block dt {
	display: inline;
}
.text-block a {
	color: var(--link-color);
	text-decoration: none;
}
.text-block a:hover {
	text-decoration: underline;
}


/****************************************************************************
 * Section styles
 ****************************************************************************/

.section {
	display: block;
}


/****************************************************************************
 * Block styles
 ****************************************************************************/

.block {
	display: inline-block;
	vertical-align: top;
	border: .15em solid var(--block-border);
	border-radius: .5em;
	padding: 1em;
	margin: .5em;
	color: var(--block-foreground); background: var(--block-background);
}
.items {
	margin-left: 2em;
}
.block-items {  /* First indentatiion level in a Block (kind-of like the title of a Block) */
	margin-left: 0.5em;
}


/****************************************************************************
 * Item and SubItem styles
 ****************************************************************************/

.item {
	display: block;
	padding: 0.1em;
}

/* Item Groups for continuation */

.group .item {
	display: inline;
	margin-left: 0.4em;
}
.group .item:first-child {
	margin-left: unset;
}

/* Item Checkboxes */

.todo-checkbox {
	margin-right: 0.2em;
}
.todo-checkbox:checked {
}
.checkbox-label {
}
.checkbox-label.checked {
	color: var(--disabled-color);
	text-decoration: line-through;
}

/* Item Icons */

.item-icon {
	width: 1.0em; height: 1.0em;
	margin-right: 0.2em;
	vertical-align: -10%;
}
.link .item-icon {
	vertical-align: -15%;
}
.items > .item {  /* selects all non-grouped elements */
}
.link {  /* selects all links */
}
.items > .item .link {  /* selects all non-grouped links */
	vertical-align: 15%;
}
.items > .group > .item .link {  /* selects all grouped links */
}
.text-icon {
	display: inline-block;
	padding: 0em;
	text-decoration: none;
}
.text-icon div {
	position: absolute;
	margin: 0em; padding: 0em;
	transform-origin: 0 0;
}

/* Item Separator */

.item .separator {
	margin: 0em -1em 0em -1em;
}


/****************************************************************************
 * Search Form
 ****************************************************************************/

.search-form .textbox {
	font-size: 110%;
}
.search-form .button {
	margin: 0.3em;
}
.search-form .button .item-icon {
	width: 1.5em; height: 1.5em;
	vertical-align: -25%;
}
.search-form .button .label {
	margin: 0em 0.3em;
}


/****************************************************************************
 * Settings Form
 ****************************************************************************/

.settings-icon {
	position: absolute;
	top: 10px; right: 10px;
	font-size: 200%;
	cursor: pointer;
}
.settings-form .panel {
	width: 95%;
}
.settings-form .textbox {
	width: 100%;
	height: 47em;
	resize: both;
	overflow: scroll;
	color: var(--foreground); background: var(--background);
	font-family: monospace;
}
.settings-form .buttonbar {
	text-align: right;
}
.settings-form .button {
}


/****************************************************************************
 * blink animation
 ****************************************************************************/

.blink {
	border: .15em solid transparent;
	animation: 500ms 4 blinker;
}
@keyframes blinker {
	30% {
		border-color: var(--error-border-color);
		background-color: var(--error-background-color);
	}
}


/****************************************************************************
 * settings-form animation
 ****************************************************************************/

.settings-form {
	display: none;
	height: 50em;
}
.settings-form.show {
	display: block;
}
.settings-form.expanding {
	animation: 700ms ease settings-form-slider;
}
.settings-form.collapsing {
	animation: 700ms ease reverse settings-form-slider;
}
@keyframes settings-form-slider {
	0% {
		transform: scaleY(0);
		transform-origin: top;
		height: 0em;
	}
	100% {
		transform: scaleY(1);
		transform-origin: top;
		height: 50em;
	}
}


/****************************************************************************
 * slider-container and resize-button animation
 ****************************************************************************/

/* Note: On Firefox, if all collapsing/expanding animations do not take the
   same amount of time, it becomes jerky. Therefore, use the same amount of
   time and arrange different animation speeds with the @keyframes. */

.slider-container {
	/* As described in https://keithjgrant.com/posts/2023/04/transitioning-to-height-auto/,
	   animating height to height:auto is not always possible, e.g. on Firefox. A solution
	   is to animate grid-template-rows and add an extra intermediate <div>. */
	display: grid;
	grid-template-rows: 1fr;
	grid-template-columns: 1fr;
}
.slider-container > .items {  /* the first level of items in the container */
	overflow: hidden;
	white-space: nowrap;
}
.collapsing .slider-container {
	animation:
		400ms ease-out reverse block-expanding-x,
		400ms ease-out reverse block-expanding-y;
}
.expanding .slider-container {
	animation:
		400ms ease-out block-expanding-x,
		400ms ease-out block-expanding-y;
}
.collapsed .slider-container {
	grid-template-rows: 0fr;
	grid-template-columns: 0fr;
}
@keyframes block-expanding-x {
	0% {
		grid-template-columns: 0fr;
	}
	60%, 100% {
		grid-template-columns: 1fr;
	}
}
@keyframes block-expanding-y {
	0%, 20% {
		transform: scaleY(0);
		transform-origin: top;
		grid-template-rows: 0fr;
	}
	100% {
		transform: scaleY(1);
		transform-origin: top;
		grid-template-rows: 1fr;
	}
}

/* resize-button animation */

.resize-icon {
	float: right;
	position: relative;
	top: -0.9em; right: -0.6em;
	cursor: pointer;
	color: var(--disabled-color);
	transform: rotate(90deg);
}
.collapsing .resize-icon {
	animation: 400ms ease animate-resize-icon;
}
.expanding .resize-icon {
	animation: 400ms ease reverse animate-resize-icon;
}
.collapsed .resize-icon {
	color: var(--block-foreground);
	transform: rotate(0deg);
}
@keyframes animate-resize-icon {
	0%, 30% {
		color: var(--disabled-color);
		transform: rotate(90deg);
	}
	70%, 100% {
		color: var(--block-foreground);
		transform: rotate(0deg);
	}
}

/* }}} */
</style>

<script>
// Some constants {{{

const UNICODE_BLACK_DOWN_POINTING_TRIANGLE = '\u{25BC}';
const UNICODE_BLACK_RIGHT_POINTING_TRIANGLE = '\u{25B6}';
const UNICODE_GEARS = '\u{2699}';  //gears wheel

// DefaultLinks is a textual part with a copy of example-links.txt at the end.
const DefaultLinks = `
// For the syntax description, see help.html.

!title Example Favorites

!text
<a name="description"></a>
<h2>Description</h2>

<p>
<a href="favorites.html">favorites.html</a> is a single page that can be
configured to show <u>links</u> and <u>todo lists</u>, organized in
<u>sections</u>, <u>blocks</u> and <u>items</u>. This configuration can be
downloaded via a URL and/or edited in the browser's LocalStorage (see below).
<br>
This page can be set as home page in the browser's settings and as the Tab
start page via an add-on like <a
href="https://addons.mozilla.org/en-US/firefox/addon/new-tab-override/">New Tab
Override</a>.
</p>
!endtext

Section

!text
<p>
The configuration consists primarily of a list of <a
href="help.html#link-syntax">Link Definitions</a>.  The Links form an
hierarchical structure, indicated by the line's indentation:
<ul>
<li><dt>Section</dt>: The first indentation level is the Section. Sections are
    separated by horizontal lines.
<li><dt>Block</dt>: The second indentation level are the blocks within a
    Section. Each Block is a visual area that can be collapsed and expanded.
<li><dt>Item</dt>: The third indentation level are the Items that populate
    the Blocks.
<li><dt>SubItem</dt>: The fourth and higher indentation levels are SubItems
    that are displayed under their respective parent Items
</ul>
</p>
!endtext

    Block
        Item
            SubItem
                SubSubItem
                SubSubItem
                    ...
            SubItem
        Item
            SubItem

!text
<p>
Each link can be a hyperlink, have an icon and/or a checkbox.
</p>
!endtext

!text
<a name="usage"></a>
<h2>Usage</h2>

<p>
The standard usage is to open the page favorites.html (or possibly set it as
your home page). Upon first opening, it shows a default example page.  This
page can be edited by going to the Settings (gears (&#x2699;) icon) and just
edit and save the textual configuration. Optionally, this configuration can be
maintained in a separate text file and copy-pasted into the Settings.
<br>
Since GitHub provides for a way to serve HTML pages directly, this can be used
to open and use favorites.html directly from <a
href="https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html">GitHub</a>.
Save the target of this link to your home page and you're set.
</p>

<p>
See <a href="help.html#usage">Help</a> for more information on how to use a
separate URL to retrieve the configuration.
</p>

<p>
In addition to Links, the configuration also supports comments, different
web-search functions and other directives, see <a
href="help.html#line-syntax">Line Syntax</a> for further details.
</p>
!endtext

Examples

!text
<p>
These are some examples of the available features.
</p>
!endtext

    Search
        DuckDuckGo https://duckduckgo.com
        Google Maps icon=alt https://maps.google.com
        Wikipedia https://www.wikipedia.org
        YouTube https://www.youtube.com
    Source
        GitHub favorite-links https://github.com/anne-gert/favorite-links
            Use favorites.html icon=github https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html
            Example Links override icon=github https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/favorites.html&links-override=url:example-links.txt
            Help icon=github https://html-preview.github.io/?url=https://github.com/anne-gert/favorite-links/master/help.html
        Firefox
            Home page settings icon=firefox target=manual about:preferences#home
            Plugins
                New Tab Override https://addons.mozilla.org/en-US/firefox/addon/new-tab-override/
    To Do
        Shopping
            [ ] Books
            [x] Presents
        At work
            [x] icon=firefox Install Firefox https://www.mozilla.org/firefox/download
            [ ] icon=github Start using favorite-links as todo-list
            []  icon=empty Write review
                & Goto Blog icon=none url=https://blog.example.com
    Socials
        Facebook https://www.facebook.com
            Instagram https://www.instagram.com/
            WhatsApp Web https://web.whatsapp.com/
        ---
        LinkedIn https://www.linkedin.com/

// Icon definitions
!icondef firefox    https://www.mozilla.org/media/img/favicons/firefox/browser/favicon.ico
!icondef github     https://github.com

// Search button definitions
//      Identifier   | Label  | Tooltip | Icon
!search Duck Duck Go | Search |
!search Wikipedia
!search YouTube
!search Google Maps  | Maps   |         | alt
`;

const KeyLinks = 'links';

// }}}

// Loading Links {{{

// This function returns a Promise to set the Links content. It is intended to
// be called as soon as possible, so that a download may start.
// When the page is ready to use the result, it can wait for the Promise and
// use it.
//
// The contents of Links can be obtained in the following way:
// 1) If the links-override= query string is set on the URL, that contents is
//    used. This can also be a url:xxx value.
// 2) Otherwise if there is a 'links' key in LocalStorage, that value is used.
// 3) Otherwise if the links= query string is set on the URL, that contents is
//    used. This can also be a url:xxx value.
// 4) If Links matches 'url:<url>', the contents of that URL is downloaded and
//    evaluated as script. It should set the Links variable.
// 5) If Links is empty at this point, use a default contents.
// 6) Links should now have a value that can be parsed as specified below.
function resolveLinks() {
	let links = null;

	let params = new URLSearchParams(location.search);
	//console.log(params);

	// Step 1) Check if links-override is defined in the query string
	if (links == null) {
		let v = params.get('links-override');
		if (v) {
			// Use this URL argument for links
			console.log('Use links-override= URL argument');
			links = v;
		}
	}

	// Step 2) Check if links is defined in LocalStorage
	if (links == null) {
		let v = readLocalLinks();
		if (v !== false) {
			// LocalStorage is available, use persistent value
			console.log('Use links from the LocalStorage');
			links = v;
		}
	}

	// Step 3) Check if links is defined in the query string
	if (links == null) {
		let v = params.get('links');
		if (v) {
			// Use this URL argument for links
			console.log('Use links= URL argument');
			links = v;
		}
	}

	// Step 4) If links is a URL, resolve it
	if (links != null) {
		let matchTargetUrl = links.match(/^\s*url\s*:\s*((https?:\/\/)?(.*?))\s*$/i);
		//console.log(matchTargetUrl);
		// Captured:
		// 1: url
		// 2: protocol
		// 3: domain + path + rest
		if (matchTargetUrl) {
			// links is a URL
			let url = matchTargetUrl[1];
			if (!matchTargetUrl[2]) {
				// URL is relative, check if we need to adjust it
				let matchBaseUrl = window.location.href.match(/^([^\/]*?:\/\/)([^\/]*\bhtml-?preview\.github\.[^\/]*)([^?#]*)/i);
				//console.log(matchBaseUrl);
				// Captured:
				// 1: protocol
				// 2: host ('html-preview.github.io')
				// 3: path without query string or fragment
				if (matchBaseUrl) {
					// The current URL is html-preview.github.io (or similar)
					// This should have a url= parameter that contains the real location
					let referredUrl = params.get('url');
					//console.log(referredUrl);
					let matchReferredUrl = referredUrl.match(/^([^\/]*:\/\/)([^\/]*\bgithub\.[^\/]*)([^?#]*)/i);
					//console.log(matchReferredUrl);
					// Captured:
					// 1: protocol
					// 2: host ('github.com')
					// 3: path without query string or fragment
					if (matchReferredUrl) {
						// The referred URL is on github.com

						// We are now in a situation where this page is hosted
						// on GitHub and links tries to point to a file on
						// there as well.
						// If you have a normal link to github.com, you get the
						// file inside the environment. If you use
						// raw.githubusercontent.com, you get the content of the
						// file, but with Content-Type=text/plain. When
						// html-preview.github.io is used, it uses
						// raw-githubcontent.com and serves it with
						// Content-Type=text/html.
						console.log('Fix links= relative URL for GitHub');
						// To make this relative link work, it should be grafted
						// onto githubusercontent.
						let matchReferredPath = matchReferredUrl[3].match(/(.*?)([^\/]*)$/);
						//console.log(matchReferredPath);
						// Captured:
						// 1: directory
						// 2: filename (everything after last '/')
						url = matchReferredUrl[1] + 'raw.githubusercontent.com' + matchReferredPath[1] + matchTargetUrl[3];
					}
				}
			}

			// Retrieve the url
			console.log('Links defined by URL \'' + url + '\'');
			links = new Promise((resolveFunc, rejectFunc) => {
				let xhr = new XMLHttpRequest();
				xhr.open('GET', url);
				xhr.onreadystatechange = function() {
					if (this.readyState == 4) {
						// Request has been handled
						if (this.status == 200) {
							// Success
							console.log('Loaded links successfully');
							resolveFunc(xhr.responseText);
						} else {
							// Failed
							console.log('Failed to load links, use standard example links');
							resolveFunc(DefaultLinks);
						}
					}
				};
				xhr.send();  //send the request
			});
		} else {
			// Links is not a URL
			links = Promise.resolve(links);  //make it into a Promise
		}
	}

	// Step 5) If links is still empty, use a default contents.
	if (links == null) {
		console.log('Use standard example links');
		links = Promise.resolve(DefaultLinks);
	}

	// Step 6) Now links can be parsed when init() is called.
	return links;  //return the Promise for later consumption
}

// Start resolving the links here.
var LinksPromise = resolveLinks();

// Read links settings from LocalStorage.
// Return links or false in case of error or if it does not exist.
function readLocalLinks() {
	if (localStorage) {
		let v = localStorage.getItem(KeyLinks);
		if (v) return v;
	}
	return false;
}

// Store links in LocalStorage.
// If value is null, empty or whitespace, delete value from LocalStorage.
// Return true if success, false if not saved.
function writeLocalLinks(value) {
	if (localStorage) {
		if (value == null || value.match(/^\s*$/))
			localStorage.removeItem(KeyLinks);
		else
			localStorage.setItem(KeyLinks, value);
		return true;
	}
	return false;
}
// }}}

// Parsing Links {{{

// Global variables in which parseLinks() puts its output.
var Links = null;  //links text, input for parseLinks()
var PageTitle = null;  //specified title
var PageTheme = null;  //specified color theme
var FontSize = null;  //specified font-size (may be relative, but that doesn't work very well)
var SearchButtonDefs = null;  //specified search button declarations
var RootLinks = null;  //array of Link objects that have no parents (i.e. are roots)
var IconDefs = null;  //specified icondef declarations


// Parse the string in Links and fills the global variables above.
function parseLinks() {
	// Parse the input lines
	let allLinks = [];  //specified Link objects
	PageTitle = null;
	PageTheme = null;
	FontSize = null;
	SearchButtonDefs = [];
	RootLinks = [];
	IconDefs = {};
	let textBlock = null;  //used for literal !text ... !endtext blocks
	let openParents = [];  //currently open parents: 0 is root, 1 its child, etc
	let openParentIndentSpaces = [];  //indentation level (number of spaces) for each open parent
	let lines = Links.split(/\r?\n\r?/);  //lines with Link specifications
	for (let i = 0; i < lines.length; ++i) {
		let line = lines[i];
		//console.log('Line=\'' + line + '\'');
		let m;  //for regex matches

		// If we're in a !text block, add this line to the block
		if (textBlock != null) {
			// We're in a !text block
			// Check if it is the end of a literal !text block
			m = line.match(/^\s*!endtext\s*$/i);
			if (m) {
				// It is the end, save the object and reset textBlock.
				// Add this object to the last item.
				let level = openParents.length - 1;  //current level
				if (level > 0) {
					// Level not root or Section level.
					// If a block is inserted into blocks, the layout
					// gets all weird. Therefore, limit !text blocks
					// to maximum of Section level.
					level = 0;
				}
				if (level >= 0) {
					// Add this block as child of this item
					openParents[level].subs.push(textBlock);
				} else {
					// There are no items yet
					RootLinks.push(textBlock);
				}
				// Do not add this block as an open parent itself.
				allLinks.push(textBlock);  //all items go here
				textBlock = null;  //reset
				continue;
			}
			// Otherwise add this line too
			textBlock.lines.push(line);
			continue;
		}

		// Remove vim folding markers at the end of lines
		line = line.replace(/\s*(?:{{{|}}})\s*$/, '');

		// Skip empty lines
		if (line.match(/^\s*(?:\/\/|#|;|$)/))
			continue;

		// Check if it is a title definition
		m = line.match(/^\s*!title\s+(.+?)\s*$/i);
		if (m) {
			// This is an title
			PageTitle = m[1];  //save string
			continue;
		}

		// Check if it is a theme definition
		m = line.match(/^\s*!theme\s+(.+?)\s*$/i);
		if (m) {
			// This is a theme
			PageTheme = m[1];  //save string
			continue;
		}

		// Check if it is a font-size definition
		m = line.match(/^\s*!size\s+(.+?)\s*$/i);
		if (m) {
			// This is a size
			FontSize = m[1];  //save string
			continue;
		}

		// Check if it is an icon definition
		m = line.match(/^\s*!icondef\s+(\S+)(?:\s+|\s*=\s*)(\S+)\s*$/i);
		if (m) {
			// This is an icondef
			IconDefs[m[1]] = m[2];  //save mapping
			continue;
		}

		// Check if it is a search button definition
		m = line.match(/^\s*!search\s+(.+?)\s*$/i);
		if (m) {
			// This is a search button definition
			let def = m[1].split(/\s*\|\s*/);  //split fields on '|', allowing whitespace
			SearchButtonDefs.push(def);  //save button def
			continue;
		}

		// Check if it is the start of a literal !text block
		m = line.match(/^\s*!text\s*$/i);
		if (m) {
			// Mark the start of a !text block
			textBlock = {  //special type of Link object
				'lineNum'  : i,  //start of this !text block
				'type'     : 'text',
				'lines'    : [],
				'toString' : function() { return '{ !text, #Lines=' + this.lines.length + ' }' },
			};
			continue;
		}

		// Take out indentation
		let indent = 0;
		m = line.match(/^(\s+)(.*)$/);
		if (m) {
			indent = m[1].replaceAll('\t', '        ').length;
			line = m[2];  //the rest
		}
		// Take out continucation: & ...
		let cont = false;
		m = line.match(/^&\s*(.*)$/);
		if (m) {
			cont = true;
			line = m[1];  //the rest
		}
		// Take out Icon: /icon=non-whitespace/
		let icon = null;
		m = line.match(/^(.*)(?:\s|^)icon=(\S*)(.*)$/i);
		if (m) {
			icon = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out Check: start with '[ ]' '[]' or '[x]'
		let check = null;
		m = line.match(/^(\s*)(?:(\[ ?\])|(\[x\]))(.*)$/i);
		if (m) {
			if (m[2]) check = false;
			if (m[3]) check = true;
			line = m[1] + m[4];  //the rest
		}
		// Take out Target: /target=non-whitespace/
		let target = null;
		m = line.match(/^(.*)(?:\s|^)target=(\S*)(.*)$/i);
		if (m) {
			target = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out URL: /url=non-whitespace/ or last /schema:non-whitespace/
		let url = null;
		m = line.match(/^(.*)(?:\s|^)url=(\S*)(.*)$/i);
		if (!m)
			m = line.match(/^(.*)(?:\s|^)([-+a-zA-Z]{2,}:\S+)(.*)$/);
		if (m) {
			url = m[2];
			line = m[1] + m[3];  //the rest
		}
		// Take out Name: what remains without leading&trailing whitespae
		let name = line.trim();

		// Handle special items
		if (name.match(/^---+$/)) {  //name with 3 or more '-'
			// This is a separator
			name = '---';  //standardize to 3 '-'
			let minLevel = 2;  //item level
			if (openParentIndentSpaces.length <= minLevel) {
				continue;  //no open parent at this level yet, skip this item
			} else {
				if (indent < openParentIndentSpaces[minLevel]) {
					// Separator has lower indent than level 2, pretend it's
					// at the same level as the line before
					indent = openParentIndentSpaces[openParentIndentSpaces.length - 1];
				}
			}
		}

		// Create the Link object
		let link = {
			'lineNum'  : i,
			'type'     : 'link',
			'name'     : name,
			'url'      : url,
			'icon'     : icon,
			'check'    : check,
			'target'   : target,
			'cont'     : [],
			'subs'     : [],
			'toString' : function() { return '{ Name=\'' + this.name + '\', URL=' + this.url + ', Icon=' + this.icon + ', check=' + check + ', #SubItems=' + this.subs.length + ' }' },
		};
		//console.log('Indentation=' + indent + ', Link=' + link);

		if (cont) {
			// This link is a continuation of the previous link
			// Ignore the indentation and add it to the last parent
			let level = openParents.length - 1;
			openParents[level].cont.push(link);
			// Do not add this link as a possible parent itself
		} else {
			// Find parent level with indentation strictly less
			let level;
			for (level = openParentIndentSpaces.length - 1; level >= 0 && openParentIndentSpaces[level] >= indent; --level) {}
			// Remove all open parents after that
			openParentIndentSpaces.length = level + 1;
			openParents.length = level + 1;
			// Add this link to the parent's children
			if (level >= 0) {
				// It has a parent
				openParents[level].subs.push(link);
			} else {
				// It has no parent
				RootLinks.push(link);
			}
			// Add this link as open parent
			openParentIndentSpaces.push(indent);
			openParents.push(link);
		}

		// Add this Link
		allLinks.push(link);
	}

	// Log all links
	//for (let i = 0; i < allLinks.length; ++i) console.log('Link=' + allLinks[i]);
	// Log all roots
	//for (let i = 0; i < RootLinks.length; ++i) console.log('RootLink=' + RootLinks[i]);
}

// }}}

// Rendering Links {{{

// Output Link {{{

// Render Link object, including its children to the container at specified level.
// Level 1 is called Section and is rendered with a heading.
// Level 2 is called Block and is rendered as a rectangular block.
// Level 3 is called Item and is rendered as a line in a Block.
// Level 4 and higher are called sub-Items and are rendered as indented Items.
function outputItem(link, level, container, parentPath) {
	//console.log('outputItem ' + link.toString());
	// Copy input data
	let name = link.name;
	let url = link.url;
	let icon = link.icon;
	let check = link.check;
	let target = link.target;
	let tooltip = null;
	let contItems = link.cont;
	if (contItems != null && contItems.length == 0) contItems = null;
	let subItems = link.subs;
	if (subItems != null && subItems.length == 0) subItems = null;
	if (name == '') name = null;
	if (url == '') url = null;
	if (icon == '') icon = null;
	if (target == '') target = null;
	let myPath = parentPath + '->' + name;
	// Fill in defaults for missing elements
	if (name == null) {
		if (url != null) {
			name = url;  //name defaults to url
		} else {
			name = 'LINK';  //default name
		}
	}
	// Change URL if target=manual
	if (target == 'manual') {
		let msg = 'Due to security reasons, this URL cannot be opened automatically.\nCopied URL \'' + url + '\' to clipboard.\n\nManually paste this to the address bar.';
		msg = msg.replaceAll('\'', '\\\'').replaceAll('\n', '\\n');
		tooltip = url;  //preserve original URL
		url = 'javascript:navigator.clipboard.writeText(\'' + url + '\');alert(\'' + encodeURI(msg) + '\');void(0)';
		target = null;
	}
	// Render the item
	// State variables for this item; will be used in closures
	let addItemContainer;  //function to add a container to put the Item into
	let addSubContainer;  //function to add a container to put the subItems into
	let addClosingElements = null;  //function to add closing elements to the container
	// Create element container
	if (level == 1) {
		// Render Item as Section
		//console.log('Render Section ' + name);
		let _itemContainer;
		let _subContainer;
		addItemContainer = function() {
			_itemContainer = document.createElement('h2');
			container.appendChild(_itemContainer);
			return _itemContainer;
		}
		addSubContainer = function() {
			_subContainer = document.createElement('div');
			_subContainer.className = 'section';
			container.appendChild(_subContainer);
			return _subContainer;
		};
		addClosingElements = function() {
			let closingElements = document.createElement('hr');
			container.appendChild(closingElements);
		}
	} else if (level == 2) {
		// Render Item as Block
		//console.log('Render Block ' + name);
		let _itemContainer;
		let _subContainer;
		addItemContainer = function() {
			_itemContainer = document.createElement('div');
			_itemContainer.className = 'block';
			container.appendChild(_itemContainer);
			if (subItems != null) {
				let expandIcon = document.createElement('span');  //container to display '-' or '+'
				expandIcon.className = 'resize-icon';
				expandIcon.textContent = UNICODE_BLACK_RIGHT_POINTING_TRIANGLE;
				_itemContainer.appendChild(expandIcon);
				let isExpanded = true;  //true if block is expanded
				let storageKey = 'expanded ' + myPath;
				if (localStorage) {
					// LocalStorage is available, use persistent value
					let v = localStorage.getItem(storageKey);
					console.log('Preset isExpanded for \'' + myPath + '\' to ' + v);
					if (v == 'false')
						isExpanded = false;
				}
				let displayExpandState = function() {
					console.log('Display isExpanded for \'' + myPath + '\' as ' + isExpanded);
					if (isExpanded) {
						// Expand this block
						_itemContainer.classList.add('expanding');
						_itemContainer.onanimationend = function() {
							_itemContainer.classList.remove('collapsed');
							_itemContainer.classList.remove('expanding');
						};
						// Reflect action of resize-icon
						expandIcon.title = 'Hide';
					} else {
						// Collapse this block
						_itemContainer.classList.add('collapsing');
						_itemContainer.onanimationend = function() {
							_itemContainer.classList.add('collapsed');
							_itemContainer.classList.remove('collapsing');
						};
						// Reflect action of resize-icon
						expandIcon.title = 'Show';
					}
				};
				expandIcon.onclick = function() {
					isExpanded = !isExpanded;
					console.log('Set isExpanded for \'' + name + '\' to ' + isExpanded);
					if (localStorage) {
						// LocalStorage is available, persist it
						localStorage.setItem(storageKey, isExpanded);
					}
					displayExpandState();
				};
				addClosingElements = function() {
					// Display the initial state
					//displayExpandState();  //display initial state
					if (isExpanded) {
						expandIcon.title = 'Hide';
					} else {
						_itemContainer.classList.add('collapsed');
						expandIcon.title = 'Show';
					}
				}
			}
			return _itemContainer;
		}
		addSubContainer = function() {
			_subContainer = document.createElement('div');
			_subContainer.className = 'items block-items';
			let sliderContainer = document.createElement('div');
			sliderContainer.className = 'slider-container';
			sliderContainer.appendChild(_subContainer);
			_itemContainer.appendChild(sliderContainer);
			return _subContainer;
		}
	} else {
		// Render Item is (sub-)Item
		//console.log('Render Item ' + name);
		let _itemContainer;
		let _subContainer;
		addItemContainer = function() {
			let groupContainer;
			if (contItems != null) {
				groupContainer = document.createElement('div');  //make a div for the continuation group
				groupContainer.className = 'group';
				container.appendChild(groupContainer);
			} else {
				groupContainer = container;  //there is no group, use same container
			}
			_itemContainer = document.createElement('div');
			_itemContainer.className = 'item';
			groupContainer.appendChild(_itemContainer);
			return _itemContainer;
		}
		addSubContainer = function() {
			_subContainer = document.createElement('div');
			_subContainer.className = 'items';
			container.appendChild(_subContainer);
			return _subContainer;
		}
	}
	// Create element itself
	if (name == '---') {
		// Special separator item
		let item = document.createElement('hr');
		item.className = 'separator';
		container.appendChild(item);
	} else {
		let itemContainer = addItemContainer();
		// The containers are structured as follows:
		// - groupContainer: Only if there are continued Items
		//     - itemContainer: Holds the entire (Sub)Item
		//         - checkbox: Only if it is a checkbox item
		//         - linkContainer: Only if there is a URL
		//             - icon: In itemContainer if there is no linkContainer
		//             - textContainer: Only present if there is a name
		//                              In itemContainer if there is no linkContainer
		//                 - text: name
		//         - continued items
		//         - items: Only if there are subItems

		// Declare textContainer to hold the name/label
		let textContainer = null;
		let setTextClass = function(className, add) {
			if (textContainer != null) {
				if (add)
					textContainer.classList.add(className);
				else
					textContainer.classList.remove(className);
			}
		};

		// Create checkbox
		let checkbox = null;
		if (check != null) {
			// Render a checkbox
			checkbox = document.createElement('input');
			checkbox.type = 'checkbox';
			checkbox.className = 'todo-checkbox';
			checkbox.onchange = function() {
				let re = new RegExp('(^(?:[^\\n]*\\n){' + link.lineNum + '}\\s*)\\[.?\\]');
				let newCheck;
				if (checkbox.checked) {
					// Change checkbox to checked
					console.log('Check checkbox on line ' + link.lineNum);
					newCheck = '[x]';
				} else {
					// Change checkbox to checked
					console.log('Uncheck checkbox on line ' + link.lineNum);
					newCheck = '[ ]';
				}
				Links = Links.replace(re, '$1' + newCheck);
				writeLocalLinks(Links);
				setTextClass('checked', checkbox.checked);
			};
			checkbox.checked = check;
		}

		// Create icon_control
		let icon_control = outputIcon(null, icon, url);

		// Create textContainer to hold the name/label
		if (name != null) {
			if (icon_control.present && name == '_') {
				// Do not display the text
			} else {
				textContainer = document.createElement('span');
				textContainer.appendChild(document.createTextNode(name));
				if (check != null) {
					// This is a checkbox item, give the name the correct class
					textContainer.className = 'checkbox-label';
					setTextClass('checked', check);
				} else {
					textContainer.className = 'link-name';
				}
			}
		}

		// Create hyperlink
		let hyperlink = null;
		if (url != null) {
			hyperlink = document.createElement('a');
			hyperlink.href = url;
			hyperlink.className = 'link';
			if (target != null)
				hyperlink.target = target;
			if (tooltip != null)
				hyperlink.title = tooltip;
		}

		// Add checkbox to the itemContainer
		if (checkbox != null) {
			itemContainer.appendChild(checkbox);
		}

		// Add hyperlink to itemContainer
		// Alias linkContainer to hyperlink if it exists, itemContainer otherwise
		let linkContainer;  //this container holds the link
		if (hyperlink != null) {
			itemContainer.appendChild(hyperlink);
			linkContainer = hyperlink;
		} else {
			linkContainer = itemContainer;
		}

		// Add icon_control to linkContainer
		if (icon_control.element != null) {
			linkContainer.appendChild(icon_control.element);
		}

		// Add textContainer to linkContainer
		if (textContainer != null) {
			linkContainer.appendChild(textContainer);
		}

		// If there is continuation, output those items in this itemContainer too
		if (contItems != null) {
			outputItems(contItems, level, itemContainer, myPath);
		}
	}
	// Create sub-Items in container
	if (subItems != null) {
		if (addSubContainer) {
			let subContainer = addSubContainer();
			outputItems(subItems, level+1, subContainer, myPath);
		}
	}
	// Add closing elements
	if (addClosingElements) {
		addClosingElements();
	}
}

// Output a <div> element as next child of the container.
function outputText(lines, container) {
	let html = lines.join('\n');
	let div = document.createElement('div');
	div.className = 'text-block';
	div.innerHTML = html;
	container.appendChild(div);
}

// Render array of Links to the container at specified level.
function outputItems(links, level, container, parentPath = '') {
	for (let i = 0; i < links.length; ++i) {
		let link = links[i];
		if (link.type == 'link') {
			outputItem(link, level, container, parentPath);
		} else if (link.type == 'text') {
			outputText(link.lines, container);
		}
	}
}

// }}}

// Output Icon {{{

// Create element for icon and return that
// If alt_text is defined, use that.
// icon_url is what is specified in the icon=URL argument, see explanation at
// the top of this file.
// Returns object with:
// - present: true if a non-empty icon is generated.
// - element: represents the icon, may be null.
//
// To retrieve the icon, first try the primary URL. If that fails and skip_alternatives==false,
// try these alternatives:
// - http://www.google.com/s2/favicons?domain=<target_url domain>
// - http://www.google.com/s2/favicons?domain=<icon_url domain>
function outputIcon(alt_text, icon_url, target_url, skip_alternatives = false) {
	// By default, construct icon_url from target_url
	if ((icon_url == null || icon_url == 'default') && target_url != null) {
		icon_url = getDefaultIconUrl(target_url);
	}

	// Resolve the IconDefs
	if (icon_url != null) {
		icon_url = resolveIconDefs(icon_url);
	}

	let icon_present = false;
	let icon_element = null;

	// Render icon_url
	let m;  //for regex matches
	if (icon_url == null) {
		console.log('Loading icon for target \'' + target_url + '\': null');
	} else if (icon_url == 'none') {
		console.log('Loading icon for target \'' + target_url + '\': \'' + icon_url + '\'');
	} else if (m = icon_url.match(/^html:(.+)/i)) {
		let html = m[1];
		// Create a 'data:...' pseudo URL that holds the data as SVG and put this text in a text node.
		let iconDiv = document.createElement('div');
		iconDiv.className = 'item-icon text-icon';
		let htmlDiv = document.createElement('div');
		htmlDiv.innerHTML = html;  //also takes care of HTML rendering
		FillScaler.observe(htmlDiv);
		iconDiv.appendChild(htmlDiv);
		icon_element = iconDiv;
		icon_present = true;
	} else {
		console.log('Loading icon for target \'' + target_url + '\': \'' + icon_url + '\'');
		let img = document.createElement('img');
		icon_present = true;
		if (icon_url == 'empty') {
			img.style.visibility = 'hidden';
			icon_present = false;  //there is an image, but still empty
		} else if (m = icon_url.match(/^char:(.+)/i)) {
			let text = m[1];
			// Create a 'data:...' pseudo URL that holds the data as SVG and put this text in a text node.
			icon_url = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">' + text + '</text></svg>';
			img.src = icon_url;
		} else {
			let alternatives = [], methods = [], urls = [];  //prepare options to use for the icon
			if (m = icon_url.match(/^alt(?::([^?]+))?(?:\?(.+))?/i)) {
				// icon_url contains an alt specification
				let method = m[1];
				let url = m[2];
				if (method == null || method == '' || method == 'any' || method == '*') {
					// Add all known methods
					methods.push('google');
				} else {
					// Add only the specified method
					methods.push(method);
				}
				if (url != null && url != '') {
					// Add the specified URL only
					urls.push(url);
				} else {
					// Add the icon_url (but that doesn't contain a URL) and target_url
					if (target_url != null && target_url != '') {
						urls.push(target_url);
					}
				}
			} else {
				// icon_url contains a URL of the icon
				alternatives.push(icon_url);
				if (!skip_alternatives) {
					// Try the alternatives in order of 'likely correct'.
					// Note that the google-favicons always returns an image, even a generic one, so it
					// will always prevent further alternatives to be attempted.
					methods.push('google');
					if (icon_url != null) {
						urls.push(icon_url);
					}
					if (target_url != null) {
						urls.push(target_url);
					}
				}
			}
			//console.log('All methods for ' + icon_url); console.log(methods);
			//console.log('All urls for ' + icon_url); console.log(urls);
			// Go through methods and urls and add alternatives
			for (let m = 0; m < methods.length; ++m) {
				let method = methods[m];
				for (let u = 0; u < urls.length; ++u) {
					if (method == 'google') {
						alternatives.push(getGoogleAltIconUrl(urls[u]));
					} else {
						console.error('Unknown alt icon method: ' + method);
					}
				}
			}
			//console.log('All alternatives for ' + icon_url); console.log(alternatives);
			// Remove duplicates
			let seen = {};
			let alt_list = alternatives;  //may have duplicates
			alternatives = [];  //get the unique ones
			for (let a = 0; a < alt_list.length; ++a) {
				if (!seen[alt_list[a]]) {
					seen[alt_list[a]] = true;
					alternatives.push(alt_list[a]);
				}
			}
			//console.log('All unique alternatives for ' + icon_url); console.log(alternatives);
			// Set the icon urls until we find one that works
			let try_next = function() {
				if (alternatives.length > 0) {
					// Try next alternative
					//console.log('alternatives.length=' + alternatives.length);
					//console.log('alternatives[0]=' + alternatives[0]);
					let alt = alternatives.shift();
					//console.log('alternatives.length=' + alternatives.length);
					if (img.src != null && img.src != '') {
						console.warn('Cannot load icon \'' + img.src + '\', try \'' + alt + '\'');
					}
					img.src = alt;
				} else {
					// Stop trying
					console.error('Cannot load icon: ' + img.src);
					if (alt_text != null) {
						// prepare to show the alt text
						img.src = '';
					} else {
						// hide entire image
						img.style.visibility = 'hidden';
					}
					img.onerror = null;  //stop handling errors
				}
			}
			img.onerror = try_next;
			try_next();  //set first alternative
		}
		if (alt_text != null) {
			img.alt = alt_text;
		}
		img.className = 'item-icon';
		icon_element = img;
	}

	return {
		'present' : icon_present,
		'element' : icon_element,
	};
}

// Take icon_url and perform the icondef replacements.
// Returns the resolved value or the original value if no icondefs matched.
function resolveIconDefs(icon_url) {
	let retval = icon_url;
	let seen = {};  //to break cycles
	seen[icon_url] = 1;
	let override = IconDefs[icon_url];
	while (override !== undefined && !seen[override]) {
		console.log('Replace icon=' + icon_url + ' by IconDefs ' + override);
		retval = override;
		seen[override] = 1;
		override = IconDefs[override];
	}
	//console.log('Returning ' + retval);
	return retval;
};

// Define a ResizeObserver that is used to resize entries to 100% of their
// parent's size. This is used for icons that are defined with html:<x>.
var FillScaler = new ResizeObserver(function(entries) {
	for (let entry of entries) {
		let element = entry.target;
		// Get entries current size
		let w, h;
		if (entry.borderBoxSize) {
			let rect = entry.borderBoxSize[0];  //area of 1st (and only) fragment
			let writingMode = element.style.writingMode;
			//console.log('FillScaler: Writing mode ' + writingMode);
			if (writingMode.match(/^vertical/i)) {
				// Vertical writing-mode, so inline direction is vertical
				h = rect.inlineSize;
				w = rect.blockSize;
			} else {
				// Assume horizontal writing-mode, so inline direction is horizontal
				w = rect.inlineSize;
				h = rect.blockSize;
			}
		} else {
			let rect = entry.contentRect;
			w = entry.contentRect.width;
			h = entry.contentRect.height;
		}
		console.log('FillScaler: Element size ' + w + ' x ' + h);
		// Get parent's current size
		let parent = element.parentElement;
		let pw = parent.offsetWidth;
		let ph = parent.offsetHeight;
		//console.log('FillScaler: Parent size ' + pw + ' x ' + ph);
		// Calculate new scaling factor
		let scaleX = pw / w;
		let scaleY = ph / h;
		//console.log('FillScaler: Scale with ' + scaleX + ' x ' + scaleY);
		// Check if the change is big enough
		let changeX = element._scaleX / scaleX;
		let changeY = element._scaleY / scaleY;
		//console.log('FillScaler: Scale change ' + changeX + ' x ' + changeY);
		if (isNaN(changeX) || changeX < 0.98 || changeX > 1.02 || isNaN(changeY) || changeY < 0.98 || changeY > 1.02) {
			// More than 2% change
			console.log('FillScaler: Set scale ' + scaleX + ' x ' + scaleY);
			element._scaleX = scaleX;
			element._scaleY = scaleY;
			entry.target.style.scale = scaleX + ' ' + scaleY;
		} else {
			console.log('FillScaler: Scale change too small ' + changeX + ' x ' + changeY);
		}
	}
});

// Return the URL where the default icon should be.
function getDefaultIconUrl(site_url) {
	return site_url.replace(/(?:(?:(?<!\/)\/(?!\/)|\?|#).*)?$/, '/favicon.ico');  //replace first single '/', '?' or '#' and onwards
}

// Return the URL for an icon of the site_url's domain.
// This method uses the Google database.
function getGoogleAltIconUrl(site_url) {
	let domain = site_url
		.replace(/^[^\/]*\/\//, '')  //remove scheme
		.replace(/\/.*/, '');  //remove path
	return 'http://www.google.com/s2/favicons?domain=' + domain;
}

// }}}

// }}}

// SearchBox related functions {{{

// The search functions will be accessed by name (lower case identifier).
// Every identifier has sub-keys for different functions.
// A search function has the search query as input and should return a URL to
// go to for the results.

var SearchFunction = {
	'duck duck go' : {
		'text'   : getTemplateUrl('https://duckduckgo.com?q=%urlinput'),
	},
	'google' : {
		'text'   : getTemplateUrl('https://www.google.com/search?q=%urlinput'),
	},
	'wikipedia' : {
		'text'   : getTemplateUrl('https://www.wikipedia.org/wiki/Special:Search?go=Go&search=%urlinput'),
	},
	'youtube' : {
		'text'   : getTemplateUrl('https://www.youtube.com/results?search_query=%urlinput'),
	},
	'wayback machine' : {
		'text'   : getWaybackSearchUrl,
		'domain' : getWaybackDomainUrl,
	},
	'google maps' : {
		'text'   : getTemplateUrl('https://maps.google.com/?q=%urlinput'),
	},
	'default' : {
		'text'   : getNoUrl,
		'domain' : getWithSchemaUrl,
	},
};

// Return a URL to handle the address (ie beautify it to go to it).
function getWithSchemaUrl(address) {
	let url = address;
	if (!url.match(/^[\w+-]+:/)) {
		url = 'http://' + url;  //add default scheme
	}
	return url;
}

// This is a dummy search function, that can be used as a default.
function getNoUrl(intput) {
	return null;
}

// This function returns a functions that uses the template to construct a URL.
// The template is a URL with the following placeholders:
// - %input: Replaced with the supplied input value.
// - %urlinput: Replaced with the URL-encoded input value.
function getTemplateUrl(template) {
	return function(input) {
		let encoded_input = encodeURIComponent(input).replace(' ', '+');
		return template
			.replace('%input', input)
			.replace('%urlinput', encoded_input);
	};
}

// Returns a URL to perform a lookup for the domain with Wayback Machine.
function getWaybackDomainUrl(domain) {
	let ts = getWaybackTimestamp();
	return 'https://web.archive.org/web/' + ts + '/' + domain;
};

// Returns a URL to perform a search for input with Wayback Machine.
function getWaybackSearchUrl(input) {
	let ts = getWaybackTimestamp();
	let encoded_input = encodeURIComponent(input).replace(' ', '+');
	return 'https://web.archive.org/web/' + ts + '/' + encoded_input;
};

// Create a Wayback Machine timestamp that can be used in queries.
function getWaybackTimestamp(date = new Date()) {
	let pad = function(number, positions) {
		let neg = false;
		if (number < 0) {
			neg = true;
			positions--;  //space for '-'
			number = -number;
		}
		let s = '';
		for (let i = 2, limit = 10; i <= positions; ++i, limit *= 10) {
			if (number < limit) s += '0';
		}
		s += number;
		if (neg) s = '-' + s;
		return s;
	};
	// I assume the format is 'yyyymmddhhmmss*' with yyyy the year
	// to query and the rest '0'.
	let timestamp = pad(date.getFullYear(), 4) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		pad(0, 2) +
		'*';
	return timestamp;
}

// Process search input.
// Redirects to search.
// May return if search input is not clear.
function processSearchInput(searchBox, getSearchUrl, getDomainSearchUrl = getWithSchemaUrl) {
	let input = searchBox.value;
	if (input.match(/^\s*$/)) {
		console.log('Empty search string');
		// Set the blink animated style
		searchBox.classList.add('blink');
		searchBox.onanimationend = function() {
			//console.log('animation end');
			searchBox.classList.remove('blink');
		};
	} else {
		let m = input.match(/^\s*(\S+\.\S+)\s*$/);
		let url = null;
		if (m && getDomainSearchUrl) {
			//console.log('Looks like URL');
			url = getDomainSearchUrl(m[1]);
			console.log('Go to URL \'' + url + '\'');
		} else {
			url = getSearchUrl(input);
			console.log('Search \'' + url + '\'');
		}
		if (url) {
			window.location.href = url;
		} else {
			console.log('No URL to go to');
		}
	}
}

// Create search button to container and set up the event callback.
// This also adds icons to the buttons. Do that here instead of with
// static HTML, because I saw that the browser tries to render static
// images before the JavaScript generated ones and I'd like to render
// the links as soon as possible.
// The displayed icon is specified by icon_url. If this is 'alt', the
// target domain is derived from getSearchUrl().
function addSearchButton(container, search_box, button_id, label_text, tooltip, icon_url, getSearchUrl, getDomainSearchUrl) {
	let btn = document.createElement('button');
	if (btn) {
		// Configure the button
		btn.id = 'BtnSearch' + button_id;
		btn.className = 'button';
		btn.onclick = function() {
			processSearchInput(search_box, getSearchUrl, getDomainSearchUrl);
			return false;  //skip default handling
		}
		btn.title = tooltip;

		// Add icon
		let target_domain = getSearchUrl('dummy');
		//console.log('target_domain=' + target_domain);
		//console.log('favicon=' + getDefaultIconUrl(target_domain));
		// When determining the icon, don't consider alternatives,
		// except when icon_url == 'alt...'
		let icon = outputIcon(tooltip, icon_url, target_domain, true);
		if (icon.element != null) btn.appendChild(icon.element);

		// Add link text
		let label = document.createElement('span');
		label.className = 'label';
		let textNode = document.createTextNode(label_text);
		label.appendChild(textNode);
		btn.appendChild(label);

		// Add the button to the container
		container.appendChild(btn);
	}
}

function addSearchButtons(searchBox, container) {
	for (let i = 0; i < SearchButtonDefs.length; ++i) {
		// Get the fields from the definition
		let def = SearchButtonDefs[i];
		let f = 0;

		// Determine Identifier
		let id = def[f++];
		if (!id) continue;  //id is mandatory, ignore this entry if absent
		let key = id.toLowerCase();  //lower case version

		// Determine referenced Search URL Function
		let getSearchUrl = SearchFunction[key]['text'];

		// Determine referenced Domain Search URL Function
		let getDomainSearchUrl = SearchFunction[key]['domain'];

		// Determine Label
		let label = def[f++] || id;

		// Determine Tooltip
		let tooltip = def[f++] || id;

		// Determine Icon
		let icon = def[f++];
		if (!icon) {
			if (getSearchUrl) {
				// Search URL function is defined. This is
				// needed to retrieve the 'default' icon.
				icon = 'default';
			} else {
				// There is no Search URL function, use a
				// standard magnifying glass icon.
				icon = 'html:&#x1F50D;';
			}
		}

		// Determine final Search URL Function
		if (!getSearchUrl) {
			// No Search Function, use default (assume it exists)
			getSearchUrl = SearchFunction['default']['text'];
		}

		// Determine final Domain Search URL Function
		if (!getDomainSearchUrl) {
			// No Search Function, use default (assume it exists)
			getDomainSearchUrl = SearchFunction['default']['domain'];
		}

		// Log the fields
		console.log('addSearchButtons: Identifier=\'' + id + '\'');
		console.log('addSearchButtons: Label=\'' + label + '\'');
		console.log('addSearchButtons: Tooltip=\'' + tooltip + '\'');
		console.log('addSearchButtons: Icon=\'' + icon + '\'');
		console.log('addSearchButtons: getSearchUrl=\'' + getSearchUrl + '\'');
		console.log('addSearchButtons: getDomainSearchUrl=\'' + getDomainSearchUrl + '\'');
		//console.log(SearchFunction);

		// Create the button
		addSearchButton(container, searchBox, id, label, tooltip, icon, getSearchUrl, getDomainSearchUrl);
	}
}

// }}}

// Edit Settings {{{

// Set up the events for the settings panel.
function initSettingsPanel() {
	let iconSettings = document.getElementById('SettingsIcon');
	let pnlSettings = document.getElementById('SettingsForm');
	let txtSettings = document.getElementById('SettingsText');
	let btnSave = document.getElementById('BtnSaveSettings');
	let btnClear = document.getElementById('BtnClearSettings');
	let btnCancel = document.getElementById('BtnCancelSettings');
	let visible = false;
	let showSettings = function() {
		txtSettings.value = Links;
		// Slide to visible
		pnlSettings.classList.add('expanding');
		pnlSettings.classList.add('show');
		pnlSettings.onanimationend = function() {
			pnlSettings.classList.remove('expanding');
		};
		visible = true;
	};
	let hideSettings = function(save) {
		if (save) {
			if (save == 'clear') {
				console.log('Clear settings');
				txtSettings.value = '';
				writeLocalLinks(null);  //remove persisted Links
				loadLinks(true);  //re-resolve Links
			} else if (txtSettings.value == '') {
				console.log('Clear settings');
				writeLocalLinks(null);  //remove persistet Links
				loadLinks(true);  //re-resolve Links
			} else {
				console.log('Save settings');
				Links = txtSettings.value;
				writeLocalLinks(Links);
				processLinks();  //Render Links
			}
		}
		// slide to hidden
		pnlSettings.classList.add('collapsing');
		pnlSettings.onanimationend = function() {
			pnlSettings.classList.remove('show');
			pnlSettings.classList.remove('collapsing');
		};
		visible = false;
	};
	if (iconSettings && pnlSettings) {
		iconSettings.onclick = function() {
			if (visible) hideSettings(false); else showSettings();
		};
	}
	if (txtSettings) {
		txtSettings.onkeydown = function(e) {
			//console.log('KeyCode=' + e.keyCode);
			if (e.keyCode == 9) {
				// This is the TAB key -> Insert 4 spaces
				textInsert(this, () => ' '.repeat(4));
				return false;  //stop further handling
			} else if (e.keyCode == 13) {
				// This is the Enter key -> Copy indentation from current line
				textInsert(this, (before, mid, after) => {
					let m = before.match(/(?:^|\r|\n)([ \t]*)[^\r\n]*$/);  //match: 'linebreak whitespace line end'
					return '\n' + m[1];  //insert linebreak plus matched whitespace
				});
				return false;  //stop further handling
			}
			return true;
		};
	}
	if (btnSave) {
		btnSave.onclick = function() {
			if (visible) hideSettings(true);
			return false;  //stop default button action
		};
	}
	if (btnClear) {
		btnClear.onclick = function() {
			if (visible) hideSettings('clear');
			return false;  //stop default button action
		};
	}
	if (btnCancel) {
		btnCancel.onclick = function() {
			if (visible) hideSettings(false);
			return false;  //stop default button action
		};
	}
}

// Assume the ctl is an input control.
// Return the sanitized insertion point or selection range.
function getSelectionPos(ctl) {
	// The selection position indicates the selection, but also the insertion point
	let start = ctl.selectionStart;  //char pos AT which the selection starts
	let end = ctl.selectionEnd;  //char pos AFTER the selection end
	// Sanitize, so it is within the string:
	// - start is in [0, len]
	// - end is in [start, len]
	let len = ctl.value.len;
	if (start == null || start < 0) start = 0;
	if (start > len) start = len;
	if (end == null || end < start) end = start;
	if (end > len) end = len;

	return [start, end];
}

// Assume the ctl is an input control.
// Determine the strings before and after the insertion point.
// Then call the inserter with these values. The inserter should return the insertion string.
// Update ctl and place the new insertion point after the insertion.
function textInsert(ctl, inserter) {
	let pos = getSelectionPos(ctl);
	let start = pos[0], end = pos[1];
	// Do the insertion, replace the selection if any
	let before = ctl.value.substring(0, start), mid = ctl.value.substring(start, end), after = ctl.value.substring(end);
	let mid2 = inserter(before, mid, after);
	ctl.value = before + mid2 + after;
	// Put the insertion point after the insertion
	let newPos = start + mid2.length;
	ctl.selectionStart = ctl.selectionEnd = newPos;
}

// }}}

// Initialization {{{

// Function to set the title to the specified string.
function setPageTitle(title) {
	// Determine value or default
	if (title == null) title = 'Favorites';
	// Set the title
	console.log('Set PageTitle to \'' + title + '\'');
	let titleCtl = document.getElementById('Title');
	if (titleCtl)
		titleCtl.innerText = title;
}

// Function to set the theme of the body to the specified string.
// NB: The string theme can contain multiple CSS-class names.
function setPageTheme(theme) {
	// Determine value or default
	if (theme == null) theme = 'dark-theme';
	// Overwrite the current values
	document.body.className = theme;
}

// Function to set the font-size to the specified string.
function setFontSize(size) {
	// Determine value or default
	if (size == null) size = '100%';
	// Set the --font-size variable that is used in the CSS classes
	console.log('Set FontSize to \'' + size + '\'');
	document.documentElement.style.setProperty('--font-size', size);
}

// From the Links configuration, parse its content and display it.
function processLinks() {
	// Parse Links
	parseLinks();

	// Set page title, theme and font size
	setPageTitle(PageTitle);
	setPageTheme(PageTheme);
	setFontSize(FontSize);

	// Render links
	let container = document.getElementById('LinksBox');
	container.textContent = '';
	outputItems(RootLinks, 1, container);

	// Fill SearchForm
	// Use a static input field, so that the browser retains its contents
	// after going back to this page.
	if (SearchButtonDefs != null && SearchButtonDefs.length > 0) {
		// There are SearchButtens, fill SearchForm
		console.log('There are ' + SearchButtonDefs.length + ' SearchButtonDefs');
		// Focus SearchBox
		let searchBox = document.getElementById('SearchBox');
		if (searchBox) {
			searchBox.focus();
			searchBox.select();
		}
		// Initialize the search buttons
		let buttonBox = document.getElementById('SearchButtons');
		buttonBox.textContent = '';
		addSearchButtons(searchBox, buttonBox);
	} else {
		// No SearchButtons defined, hide SearchForm
		console.log('There are no SearchButtonDefs');
		let searchForm = document.getElementById('SearchForm');
		if (searchForm) {
			console.log('Hide SearchForm');
			searchForm.style.display = 'none';
		}
	}
}

// Load the Links and render them.
// If reload==true, the Links are completely resolved again and possibly
// reloaded from URLs.
function loadLinks(reload) {
	if (LinksPromise == null || reload) {
		// Resolve links if not already done so
		LinksPromise = resolveLinks();
	}

	LinksPromise.then((value) => {
		// Links have been resolved
		//console.log(value);
		Links = value;

		// Process the Links
		processLinks();
	});
}

// Initialize the JavaScript on the page
function init() {
	initSettingsPanel();
	loadLinks();
}
window.onload = init;

// }}}
</script>

</head>

<body class="dark-theme">

<h1 id="Title">Favorites</h1>

<span id="SettingsIcon" class="settings-icon" title="Settings">&#x2699;</span>

<form id="SettingsForm" class="settings-form">
<div class="panel">
<textarea id="SettingsText" wrap="off" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Settings" class="textbox"></textarea>
<div class="buttonbar">
<button id="BtnSaveSettings" class="button">Save</button>
<button id="BtnClearSettings" class="button">Clear</button>
<button id="BtnCancelSettings" class="button">Cancel</button>
</div>
</div>
<hr>
</form>

<form id="SearchForm" class="search-form">
Search:
<input id="SearchBox" name="q" type="text" size="40" class="textbox"/>
<span id="SearchButtons"></span>
</form>

<div id="LinksBox"></div>

</body>

</html>

<!-- vim: set fdm=marker: -->

